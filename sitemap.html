<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Site Map - Dreamex Datalab</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    :root { --primary-color:#2c3e50; --secondary-color:#34495e; --accent-color:#e74c3c; --success-color:#27ae60; --warning-color:#f39c12; --info-color:#3498db; --light-color:#ecf0f1; --dark-color:#2c3e50; --sidebar-width:250px; --transition-speed:.25s; }
    * { box-sizing:border-box; margin:0; padding:0; }
    body { font-family: 'Segoe UI', Arial, sans-serif; background:#f5f7fa; color:#222; }
    .app-container { display:flex; min-height:100vh; }
    .sidebar { width:var(--sidebar-width); background:var(--primary-color); color:#fff; padding:1rem; position:fixed; top:0; left:0; bottom:0; overflow-y:auto; transition:transform .3s ease; z-index:1000; }
    .sidebar.collapsed { transform:translateX(-100%); }
    .main-content { flex:1; margin-left:var(--sidebar-width); padding:0.3rem; padding-top:3.2rem; transition:margin-left .3s ease; }
    .main-content.sidebar-collapsed { margin-left:0; }
    .main-content.sidebar-collapsed .top-nav { left:0.5rem; }
    .logo h2 { text-align:center; padding:1rem 0; border-bottom:1px solid rgba(255,255,255,0.1); font-size:1.05rem; letter-spacing:.5px; }
    .menu { list-style:none; margin-top:2rem; }
    .menu li { margin-bottom:0.45rem; }
    .menu a { display:flex; align-items:center; gap:10px; color:#fff; text-decoration:none; padding:0.6rem 0.75rem; border-radius:6px; font-size:0.82rem; font-weight:500; transition:background .25s; }
    .menu a:hover, .menu a.active { background:rgba(255,255,255,0.12); }
    .submenu { list-style:none; margin-left:0.75rem; display:none; margin-top:0.25rem; }
    .menu-dropdown:hover .submenu { display:block; }
    .submenu a { font-size:0.75rem; padding:0.45rem 0.65rem; }
    [data-feature]:not(.menu-visible) { display:none !important; }
    .menu-dropdown:not(.menu-visible) { display:none !important; }
    .sidebar.menu-loading .menu-item,
    .sidebar.menu-loading .menu-dropdown,
    .sidebar.menu-loading li[data-feature],
    .sidebar.menu-loading [data-feature] { display: none !important; }
    .sidebar.menu-loading .menu-visible,
    .sidebar.menu-loading li.menu-visible,
    .sidebar.menu-loading [data-feature].menu-visible { display:block !important; }
    .menu-loading [data-feature] { display:none !important; }
    .menu-loading .menu-dropdown { display:none !important; }
    .menu-visible, li.menu-visible, [data-feature].menu-visible { display:block !important; }
    .top-nav { display:flex; justify-content:space-between; align-items:center; padding:0.5rem 0.75rem; background-color:#fff; box-shadow:0 2px 5px rgba(0,0,0,0.1); margin-bottom:0.3rem; position:fixed; top:0.25rem; right:0.5rem; left:calc(var(--sidebar-width) + 0.5rem); height:50px; min-height:50px; z-index:100; transition:left 0.3s ease; }
    .sidebar-toggle-btn { background:none; border:none; cursor:pointer; font-size:1.1rem; padding:0.4rem; color:#555; }
    .top-nav-left { display:flex; align-items:center; gap:0.75rem; }
    .company-branding { display:flex; align-items:center; gap:0.5rem; }
    #headerCompanyLogo { width:32px; height:32px; object-fit:contain; display:none; }
    #headerCompanyName { font-weight:600; font-size:0.85rem; }
  .top-nav-right { display:flex; align-items:center; gap:1rem; }
  .notifications { position:relative; display:flex; align-items:center; }
  .notification-btn { background:none; border:none; cursor:pointer; position:relative; font-size:1.2rem; padding:0.5rem; display:flex; align-items:center; justify-content:center; }
  .notification-badge { position:absolute; top:-5px; right:-5px; background-color:var(--accent-color); color:white; border-radius:50%; padding:0.2rem 0.5rem; font-size:0.7rem; display:none; }
  .notification-dropdown { display:none; position:absolute; right:0; top:100%; width:320px; background:#fff; border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.15); z-index:1000; border:1px solid #e9ecef; max-height:400px; overflow:hidden; }
  .notification-dropdown.show { display:block; }
    .user-profile { position:relative; }
    .profile-btn { background:none; border:none; border-radius:50%; overflow:hidden; width:38px; height:38px; cursor:pointer; }
    .profile-btn img { width:100%; height:100%; object-fit:cover; }
    .profile-dropdown { display:none; position:absolute; right:0; top:110%; background:#fff; border-radius:8px; min-width:200px; box-shadow:0 6px 18px rgba(0,0,0,0.12); overflow:hidden; }
    .profile-dropdown.show { display:block; }
    .profile-dropdown ul { list-style:none; }
    .profile-dropdown li a { display:block; padding:0.65rem 0.85rem; font-size:0.72rem; text-decoration:none; color:#1e293b; font-weight:500; }
    .profile-dropdown li a:hover { background:#f1f5f9; }
    .page-header { background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: #fff; padding: 0.55rem 0.75rem; margin: 0.35rem 0 0.5rem 0; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 10px 28px rgba(0,0,0,0.18), 0 6px 16px rgba(0,0,0,0.14); font-size: 0.9rem; }
    .map-wrapper { background:#fff; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,.1); overflow:hidden; }
    #securityMap { width:100%; height: calc(100vh - 180px); min-height:520px; }
  .toolbar { display:flex; gap:0.5rem; align-items:center; }
    .toolbar .btn { border:none; background:transparent; padding:0.5rem; border-radius:6px; cursor:pointer; font-size:1rem; transition:all 0.2s ease; min-width:36px; height:36px; display:flex; align-items:center; justify-content:center; color:#fff; }
    .toolbar .btn:hover { background:rgba(255,255,255,0.1); transform:translateY(-1px); }
    .toolbar .btn.primary { background:transparent; color:#fff; }
    .toolbar .btn.primary:hover { background:rgba(255,255,255,0.15); }
  /* Enhanced Modal Styles - Position Details Style */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(5px);
    z-index: 3000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease-in-out;
  }
  
  .modal.show {
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1;
    visibility: visible;
  }
  
  .modal-dialog {
    background: linear-gradient(to bottom right, #ffffff, #f8f9fa);
    border-radius: 16px;
    width: 95%;
    max-width: 800px;
    max-height: 90vh;
    overflow: hidden;
    position: relative;
    transform: scale(0.7);
    opacity: 0;
    transition: all 0.3s ease-in-out;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    flex-direction: column;
  }
  
  .modal.show .modal-dialog {
    transform: scale(1);
    opacity: 1;
  }
  
  .modal-header {
    padding: 1.5rem 2rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255, 255, 255, 0.95);
    position: sticky;
    top: 0;
    z-index: 2;
    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.03);
  }
  
  .modal-header h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #1a1a1a;
    margin: 0;
    position: relative;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .modal-header h3::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 0;
    width: 40px;
    height: 3px;
    background: #3b82f6;
    border-radius: 2px;
  }
  
  .modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: #666;
    cursor: pointer;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }
  
  .modal-close:hover {
    background-color: #f0f0f0;
    color: #333;
    transform: rotate(90deg);
  }
  
  .modal-body {
    padding: 1.25rem 1.5rem;
    overflow-y: auto;
    max-height: calc(90vh - 200px);
    scrollbar-width: thin;
    scrollbar-color: #ddd transparent;
    position: relative;
  }
  
  .modal-body::-webkit-scrollbar {
    width: 6px;
  }
  
  .modal-body::-webkit-scrollbar-track {
    background: transparent;
  }
  
  .modal-body::-webkit-scrollbar-thumb {
    background-color: #ddd;
    border-radius: 3px;
  }
  
  .modal-body::-webkit-scrollbar-thumb:hover {
    background-color: #bbb;
  }
  
  .modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid rgba(0, 0, 0, 0.08);
    display: flex;
    gap: 0.85rem;
    align-items: center;
    flex-wrap: wrap;
    justify-content: flex-end;
    background: rgba(255, 255, 255, 0.95);
    position: sticky;
    bottom: 0;
    z-index: 2;
    box-shadow: 0 -2px 15px rgba(0, 0, 0, 0.03);
  }
  /* Enhanced Form Styles */
  .form-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
  }
  
  .form-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .form-group label {
    font-size: 0.875rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 0.25rem;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }
  
  .form-group label i {
    font-size: 0.75rem;
    color: #6b7280;
  }
  
  .form-group input,
  .form-group select {
    padding: 0.75rem;
    font-size: 0.875rem;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background: #fff;
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  }
  
  .form-group input:focus,
  .form-group select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    transform: translateY(-1px);
  }
  
  .helper-text {
    font-size: 0.75rem;
    color: #6b7280;
    margin-top: 0.25rem;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }
  
  .helper-text i {
    font-size: 0.7rem;
    color: #9ca3af;
  }
  
  /* Enhanced Button Styles */
  .btn {
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    font-size: 0.875rem;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.2s ease;
    border: none;
    cursor: pointer;
    min-height: 2.5rem;
    justify-content: center;
    text-decoration: none;
    background-color: transparent;
    color: #6b7280;
    border: 1px solid #d1d5db;
  }
  
  .btn:hover {
    background-color: #f9fafb;
    color: #374151;
    border-color: #9ca3af;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .btn.primary {
    background-color: #3b82f6;
    color: white;
    border-color: #3b82f6;
  }
  
  .btn.primary:hover {
    background-color: #2563eb;
    border-color: #2563eb;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }
  
  .btn i {
    font-size: 0.875rem;
  }
  
  /* Form Section Dividers */
  .form-section {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: rgba(248, 250, 252, 0.5);
    border-radius: 8px;
    border: 1px solid rgba(226, 232, 240, 0.5);
  }
  
  .form-section-title {
    font-size: 0.875rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 0.75rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .form-section-title i {
    font-size: 0.875rem;
    color: #3b82f6;
  }
  </style>
</head>
<body>
  <div class="app-container">
    <nav class="sidebar menu-loading" id="sidebar">
      <div class="logo"><h2>Dreamex Datalab</h2></div>
      <ul class="menu" id="roleBasedMenu">
            <li class="menu-item" data-feature="home_view"><a href="index.html"><i class="fas fa-home"></i> Home</a></li>
            <li class="menu-dropdown" data-feature="health_view">
                <a href="#"><i class="fas fa-medkit"></i> Health</a>
                <ul class="submenu">
                    <li data-feature="health_assessment_view" data-requires-permission="health_assessment_view"><a href="health-assessment.html">Assessment</a></li>
                    <li data-feature="health_consultation_view" data-requires-permission="health_consultation_view"><a href="health-consultation.html">Consultation</a></li>
                    <li data-feature="medical_folder_view" data-requires-permission="medical_folder_view"><a href="medical-folder.html">Medical Folder</a></li>
                </ul>
            </li>
            <li class="menu-dropdown" data-feature="safety_view" data-requires-permission="safety_view">
                <a href="#"><i class="fas fa-shield-alt"></i> Safety</a>
                <ul class="submenu">
                    <li data-feature="training_view" data-requires-permission="training_view"><a href="trainingboard.html">Training</a></li>
                    <li data-feature="jsa_view" data-requires-permission="jsa_view"><a href="jsaboard.html">Job Safety Analysis</a></li>
                    <li data-feature="ptw_view" data-requires-permission="ptw_view"><a href="ptwboard.html">Permit to Work</a></li>
                    <li data-feature="incident_view" data-requires-permission="incident_view"><a href="incidentboard.html">Incident Reports</a></li>
                    <li data-feature="inspection_view" data-requires-permission="inspection_view"><a href="inspectionboard.html">Inspection</a></li>
                    <li data-feature="audit_view" data-requires-permission="audit_view"><a href="auditboard.html">Audit</a></li>
                </ul>
            </li>
                <li class="menu-dropdown" data-feature="investigation_view" data-requires-permission="investigation_view">
                	<a href="#"><i class="fas fa-search-plus"></i> Investigation</a>
                	<ul class="submenu">
                    <li data-feature="investigation_dashboard_view" data-requires-permission="investigation_dashboard_view"><a href="investigation-dashboard.html">Investigation Dashboard</a></li>
                    <li data-feature="investigation_list_view" data-requires-permission="investigation_list_view"><a href="investigation-list.html">Investigation List</a></li>
                    <li data-feature="create_investigation_view" data-requires-permission="create_investigation_view"><a href="investigation-create.html">Create Investigation</a></li>
                	</ul>
                </li>
      <!-- Risk Management (separate section) -->
      <li class="menu-dropdown" data-feature="risk_view" data-requires-permission="risk_view">
        <a href="#"><i class="fas fa-exclamation-triangle"></i> Risk Management</a>
        <ul class="submenu">
          <li data-feature="risk_view" data-requires-permission="risk_view"><a href="riskboard.html">Risk Management</a></li>
        </ul>
      </li>
            <li class="menu-dropdown" data-feature="fuel_management" data-requires-permission="fuel_management">
                <a href="#"><i class="fas fa-gas-pump"></i> Fuel Management</a>
                <ul class="submenu">
                    <li data-feature="vessel_offloading" data-requires-permission="vessel_offloading"><a href="vessel-offloading.html">Vessel Offloading</a></li>
                    <li data-feature="fuel_storage" data-requires-permission="fuel_storage"><a href="fuelstor.html">Fuel Storage Status</a></li>
                    <li data-feature="tank_transfer" data-requires-permission="tank_transfer"><a href="tank-transfer.html">Tank-to-Tank Transfer</a></li>
                    <li data-feature="truck_loading" data-requires-permission="truck_loading"><a href="fuel-truck-loading.html">Fuel Truck Loading</a></li>
                    <li data-feature="quality_analysis" data-requires-permission="quality_analysis"><a href="fuel-quality-analysis.html">Fuel Quality Analysis</a></li>
                    <li data-feature="fuel_distribution" data-requires-permission="fuel_distribution"><a href="fueldist.html">Fuel Distribution</a></li>
                    <li data-feature="fuel_consumption_analysis" data-requires-permission="fuel_consumption_analysis"><a href="fuelanalys.html">Consumption Analysis</a></li>
          <li data-feature="fuel_daily_report" data-requires-permission="fuel_daily_report"><a href="fueldaily.html">Daily Fuel Report</a></li>
                </ul>
            </li>
            <li class="menu-dropdown" data-feature="environment_view">
                <a href="#"><i class="fas fa-leaf"></i> Environment</a>
                <ul class="submenu">
                    <li data-feature="water_view" data-requires-permission="water_view"><a href="waterboard.html">Water Quality</a></li>
                </ul>
            </li>
            <li class="menu-dropdown" data-feature="security_view" data-requires-permission="security_view">
                <a href="#"><i class="fas fa-lock"></i> Security</a>
                <ul class="submenu">
                    <li data-feature="access_view" data-requires-permission="access_view"><a href="accessboard.html">Access Request</a></li>
                    <li data-feature="access_daily_view" data-requires-permission="access_daily_view"><a href="accessdaily.html">Daily Access Control</a></li>
                    <li data-feature="removal_view" data-requires-permission="removal_view"><a href="removalboard.html">Property Removal</a></li>
                    <li data-feature="security_site_map_view" data-requires-permission="security_site_map_view"><a href="sitemap.html">Security Site Map</a></li>
                    <li data-feature="security_level_evaluation_view" data-requires-permission="security_level_evaluation_view"><a href="seclevel.html">Security Level Evaluation</a></li>
                    <li data-feature="nfc_view" data-requires-permission="nfc_view"><a href="nfc.html">NFC Card Management</a></li>
                </ul>
            </li>
            <li class="menu-dropdown" data-feature="logistics_view" data-requires-permission="logistics_view">
                <a href="#"><i class="fas fa-truck"></i> Logistics</a>
                <ul class="submenu">
          <li data-feature="fleet_view" data-requires-permission="fleet_view"><a href="fleet.html">Fleet Management</a></li>
          <li data-feature="travel_view" data-requires-permission="travel_view"><a href="travel.html">Travel Requests</a></li>
                </ul>
            </li>
            <li class="menu-dropdown" data-feature="accommodation_view" data-requires-permission="accommodation_view">
                <a href="#"><i class="fas fa-bed"></i> Accommodation</a>
                <ul class="submenu">
                    <li data-feature="camp_view" data-requires-permission="camp_view"><a href="camp.html">Camp Management</a></li>
                    <li data-feature="camp_settings_view" data-requires-permission="camp_settings_view"><a href="campset.html">Camp Settings</a></li>
                </ul>
            </li>
            <li class="menu-dropdown" data-feature="hr_view" data-requires-permission="hr_view">
                <a href="#"><i class="fas fa-users"></i> HR</a>
                <ul class="submenu">
                    <li data-feature="human_hr_view" data-requires-permission="human_hr_view"><a href="human-hr.html"><i class="fas fa-user-tie"></i> Human HR</a></li>
                    <li data-feature="staff_management_view" data-requires-permission="staff_management_view"><a href="staff.html">Staffing</a></li>
                    <li data-feature="authority_to_recruit_view" data-requires-permission="authority_to_recruit_view"><a href="recruit.html">Authority to Recruit</a></li>
                    <li data-feature="job_advertising_view" data-requires-permission="job_advertising_view"><a href="jobpost.html">Job Advertising</a></li>
                    <li data-feature="screening_view" data-requires-permission="screening_view"><a href="jobscreen.html">Screening</a></li>
                    <li data-feature="interview_view" data-requires-permission="interview_view"><a href="interview.html">Interview</a></li>
                    <li data-feature="offer_view" data-requires-permission="offer_view"><a href="offer.html">Offer Management</a></li>
                    <li data-feature="contract_view" data-requires-permission="contract_view"><a href="contract.html">Contract Management</a></li>
                    <li data-feature="salary_management_view" data-requires-permission="salary_management_view"><a href="salary.html">Salary Management</a></li>
                    <li data-feature="onboarding_view" data-requires-permission="onboarding_view"><a href="onboard.html">Onboarding</a></li>
                    <li data-feature="chart_view" data-requires-permission="chart_view"><a href="chart.html">Chart Setup</a></li>
                    <li data-feature="chartboard_view" data-requires-permission="chartboard_view"><a href="chartboard.html">Org Chart</a></li>
                    <li data-feature="kpi_dashboard_view" data-requires-permission="kpi_dashboard_view"><a href="kpi.html">KPI</a></li>
                </ul>
            </li>
            <!-- Project Management as section button with submenu -->
            <li class="menu-dropdown" data-feature="project_management_section">
                <a href="#"><i class="fas fa-project-diagram"></i> Project Management</a>
                <ul class="submenu">
                    <li data-feature="project_dashboard_view" data-requires-permission="project_dashboard_view"><a href="project-dashboard.html"><i class="fas fa-tachometer-alt"></i> Project Dashboard</a></li>
                    <li data-feature="project_create_view" data-requires-permission="project_create_view"><a href="project-create.html"><i class="fas fa-plus-circle"></i> Create Project</a></li>
                    <li data-feature="project_list_view" data-requires-permission="project_list_view"><a href="project-list.html"><i class="fas fa-list"></i> Project List</a></li>
                    <li data-feature="project_reports_view" data-requires-permission="project_reports_view"><a href="project-reports.html"><i class="fas fa-chart-bar"></i> Project Reports</a></li>
                </ul>
            </li>
            <!-- Inventory Management as section button with submenu -->
            <li class="menu-dropdown" data-feature="inventory_view" data-requires-permission="inventory_view">
                <a href="#"><i class="fas fa-boxes"></i> Inventory Management</a>
                <ul class="submenu">
                    <li data-feature="inventory_dashboard_view" data-requires-permission="inventory_dashboard_view"><a href="inventory-dashboard.html"><i class="fas fa-tachometer-alt"></i> Inventory Dashboard</a></li>
                    <li data-feature="inventory_items_view" data-requires-permission="inventory_items_view"><a href="inventory-items.html"><i class="fas fa-cubes"></i> Items Management</a></li>
                    <li data-feature="inventory_warehouses_view" data-requires-permission="inventory_warehouses_view"><a href="inventory-warehouses.html"><i class="fas fa-warehouse"></i> Warehouses</a></li>
                    <li data-feature="inventory_reservations_view" data-requires-permission="inventory_reservations_view"><a href="inventory-reservations.html"><i class="fas fa-bookmark"></i> Material Reservations</a></li>
                    <li data-feature="inventory_approvals_view" data-requires-permission="inventory_approvals_view"><a href="inventory-approvals.html"><i class="fas fa-check-circle"></i> Approvals</a></li>
                    <li data-feature="inventory_issue_view" data-requires-permission="inventory_issue_view"><a href="inventory-issue.html"><i class="fas fa-shipping-fast"></i> Material Issue</a></li>
                </ul>
            </li>
            <li data-feature="communication_view"><a href="info.html"><i class="fas fa-comments"></i> Communication</a></li>
            <li class="menu-dropdown" data-feature="settings_view">
                <a href="#"><i class="fas fa-cog"></i> Settings</a>
                <ul class="submenu">
                    <li data-feature="account_settings_view" data-requires-permission="account_settings_view"><a href="account.html">Account Settings</a></li>
                    <li data-feature="company_management_view" data-requires-permission="company_management_view"><a href="companymanagement.html">Company Management</a></li>
                    <li data-feature="approval_settings_view" data-requires-permission="approval_settings_view"><a href="approval-settings.html">Approval Flow Settings</a></li>
                    <li data-feature="field_setup_view" data-requires-permission="field_setup_view"><a href="fieldsetup.html">Field Setup</a></li>
                    <li data-feature="preferences_view" data-requires-permission="preferences_view"><a href="preferences.html">Preferences</a></li>
                    <li data-feature="notification_settings_view" data-requires-permission="notification_settings_view"><a href="notification-settings.html">Notification Settings</a></li>
                    <li data-feature="audit_log_view" data-requires-permission="audit_log_view"><a href="auditlog.html"><i class="fas fa-history"></i> Audit Log</a></li>
                    <li data-feature="user_management_view" data-requires-permission="user_management_view"><a href="users.html">User & Role Management</a></li>
                    <li data-feature="role_permissions_view" data-requires-permission="role_permissions_view"><a href="roles.html">Role Permissions</a></li>
                </ul>
            </li>
        </ul>
    </nav>
    <main class="main-content" id="mainContent">
      <nav class="top-nav">
        <div class="top-nav-left">
          <button id="sidebarToggle" class="sidebar-toggle-btn" title="Toggle Menu"><i class="fas fa-bars"></i></button>
          <div class="company-branding">
            <img id="headerCompanyLogo" alt="Company Logo" />
            <span id="headerCompanyName"></span>
          </div>
        </div>
        <div class="top-nav-right">
          <div class="notifications">
            <button id="notificationBtn" class="notification-btn">
              <i class="fas fa-bell"></i>
              <span class="notification-badge">0</span>
            </button>
            <div class="notification-dropdown">
              <div class="notification-header" style="padding:12px 16px; border-bottom:1px solid #e9ecef; background:#f8f9fa; display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0; color:#333; font-size:14px; font-weight:600;">Notifications</h3>
                <button class="mark-all-read" style="background:none; border:none; color:#3498db; cursor:pointer; font-size:12px; padding:4px 8px; border-radius:4px;">Mark all as read</button>
              </div>
              <div class="notification-list"></div>
              <div class="notification-empty" style="padding:40px 20px; text-align:center; color:#999; display:none;">
                <i class="fas fa-inbox" style="font-size:32px; margin-bottom:12px; color:#ddd;"></i>
                <div class="notification-empty-title" style="font-size:14px; font-weight:500; margin-bottom:4px; color:#666;">No notifications</div>
                <div class="notification-empty-message" style="font-size:12px; color:#999;">You're all caught up</div>
              </div>
            </div>
          </div>
          <div class="user-profile" style="position:relative;">
            <button id="userProfileBtn" class="profile-btn"><img src="" alt="User Avatar" /></button>
            <div class="profile-dropdown"><ul></ul></div>
          </div>
        </div>
      </nav>

      <div class="page-header">
        <h1><i class="fas fa-map"></i> Site Map</h1>
        <div class="toolbar">
          <button id="btnAddItem" class="btn" title="Add Security Element"><i class="fas fa-plus"></i></button>
          <button id="btnDrawFence" class="btn" title="Draw Fence"><i class="fas fa-draw-polygon"></i></button>
          <button id="btnDrawArea" class="btn" title="Draw Analysis Area"><i class="fas fa-vector-square"></i></button>
          <button id="btnAnalyzeAll" class="btn" title="Analyze All Areas & Export PDF"><i class="fas fa-chart-pie"></i></button>
          <button id="btnUndo" class="btn" title="Undo Last Action"><i class="fas fa-rotate-left"></i></button>
          <button id="btnExportJson" class="btn" title="Export to JSON"><i class="fas fa-file-export"></i></button>
          <button id="btnImportJson" class="btn" title="Import from JSON"><i class="fas fa-file-import"></i></button>
          <button id="btnImportExcel" class="btn" title="Import from Excel"><i class="fas fa-file-excel"></i></button>
          <button id="btnSaveCompany" class="btn primary" title="Save to Company Database"><i class="fas fa-save"></i></button>
          <button id="btnLoadCompany" class="btn" title="Load from Company Database"><i class="fas fa-folder-open"></i></button>
          <button id="btnScreenshot" class="btn" title="Take Screenshot"><i class="fas fa-camera"></i></button>
           <button id="btnFindCenter" class="btn" title="Find Center of Element"><i class="fas fa-bullseye"></i></button>
           <button id="btnEraseAll" class="btn danger" title="Erase Everything from Map"><i class="fas fa-trash-alt"></i></button>
        </div>
      </div>

      <section class="map-wrapper">
        <div id="securityMap"></div>
      </section>

      <!-- Add Item Modal -->
      <div id="addItemModal" class="modal" aria-hidden="true">
        <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="addItemTitle">
          <div class="modal-header">
            <h3 id="addItemTitle"><i class="fas fa-shield-alt"></i> Add Security Element</h3>
            <button class="modal-close" id="addItemClose" aria-label="Close"><i class="fas fa-times"></i></button>
          </div>
          <div class="modal-body">
            <div class="form-section">
              <div class="form-section-title">
                <i class="fas fa-cog"></i>
                Element Configuration
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                  <label for="itemType">
                    <i class="fas fa-tag"></i>
                    Security Type
                  </label>
                  <select id="itemType">
                    <option value="camera">📹 Camera</option>
                    <option value="agent-post">🛡️ Security Post</option>
                    <option value="sensor">📡 Sensor</option>
                    <option value="alarm">🔔 Alarm</option>
                    <option value="supervisor">👮 Supervisor</option>
                  </select>
                </div>
                <div class="form-group">
                  <label for="itemName">
                    <i class="fas fa-signature"></i>
                    Element Name
                  </label>
                  <input id="itemName" placeholder="e.g., CAM-01, POST-A1" />
                  <div class="helper-text">
                    <i class="fas fa-info-circle"></i>
                    Unique identifier for this security element
                  </div>
                </div>
              </div>
            </div>

            <div class="form-section camera-only">
              <div class="form-section-title">
                <i class="fas fa-video"></i>
                Camera Coverage Settings
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                  <label for="camType">
                    <i class="fas fa-cogs"></i>
                    Camera Type
                  </label>
                  <select id="camType">
                    <option value="fixed">📹 Fixed Camera (Standard)</option>
                    <option value="bullet">🎯 Bullet Camera (Long Range)</option>
                    <option value="dome">🔵 Dome Camera (Wide Coverage)</option>
                    <option value="ptz">🔄 PTZ Camera (Pan-Tilt-Zoom)</option>
                    <option value="thermal">🌡️ Thermal Camera (Heat Detection)</option>
                    <option value="360">🔄 360° Camera (Panoramic)</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-info-circle"></i>
                    Camera type affects range, angle, and image quality
                  </div>
                </div>
                <div class="form-group">
                  <label for="camHeight">
                    <i class="fas fa-arrows-alt-v"></i>
                    Height Above Ground (meters)
                  </label>
                  <input id="camHeight" type="number" min="1" max="30" step="0.5" value="3.5" />
                  <div class="helper-text">
                    <i class="fas fa-ruler-vertical"></i>
                    Optimal: 3-4m for general surveillance, 6-8m for perimeter
                  </div>
                </div>
                <div class="form-group">
                  <label for="camResolution">
                    <i class="fas fa-tv"></i>
                    Resolution (pixel density)
                  </label>
                  <select id="camResolution">
                    <option value="720p">📺 720p (1280x720) - HD</option>
                    <option value="1080p" selected>🖥️ 1080p (1920x1080) - Full HD</option>
                    <option value="4k">📱 4K (3840x2160) - Ultra HD</option>
                    <option value="8k">🖥️ 8K (7680x4320) - Professional</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-expand"></i>
                    Higher resolution provides better image detail and identification
                  </div>
                </div>
                <div class="form-group">
                  <label for="camEnvironmentalResistance">
                    <i class="fas fa-shield-alt"></i>
                    Environmental Resistance
                  </label>
                  <select id="camEnvironmentalResistance">
                    <option value="ip54">🏠 IP54 (Indoor/Light Outdoor)</option>
                    <option value="ip65" selected>🌧️ IP65 (Weather Resistant)</option>
                    <option value="ip66">🌊 IP66 (Heavy Rain/Dust Proof)</option>
                    <option value="ip67">💧 IP67 (Waterproof)</option>
                    <option value="ik10">🔨 IK10 (Vandal Resistant)</option>
                    <option value="military">⚔️ Military Grade (Extreme Conditions)</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-umbrella"></i>
                    Protection level against weather, dust, and vandalism
                  </div>
                </div>
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                  <label for="camPowerMode">
                    <i class="fas fa-plug"></i>
                    Power Mode
                  </label>
                  <select id="camPowerMode">
                    <option value="ac">⚡ AC Power (Mains)</option>
                    <option value="poe" selected>🔌 PoE (Power over Ethernet)</option>
                    <option value="poe_plus">🔌 PoE+ (High Power)</option>
                    <option value="battery">🔋 Battery Powered</option>
                    <option value="solar">☀️ Solar Powered</option>
                    <option value="hybrid">🔄 Hybrid (Battery + Solar)</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-battery-full"></i>
                    Power supply method and energy requirements
                  </div>
                </div>
                <div class="form-group">
                  <label for="camAudioOutput">
                    <i class="fas fa-volume-up"></i>
                    Audio Output
                  </label>
                  <select id="camAudioOutput">
                    <option value="none" selected>🔇 No Audio</option>
                    <option value="basic">🔊 Basic Audio Recording</option>
                    <option value="bidirectional">📢 Two-Way Audio</option>
                    <option value="high_quality">🎵 High Quality Audio</option>
                    <option value="noise_reduction">🎧 Noise Reduction Audio</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-microphone"></i>
                    Audio recording and communication capabilities
                  </div>
                </div>
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                  <label for="camMinIllumination">
                    <i class="fas fa-moon"></i>
                    Minimum Illumination (Lux)
                  </label>
                  <select id="camMinIllumination">
                    <option value="0.01">🌙 0.01 Lux (Starlight)</option>
                    <option value="0.1" selected>🌃 0.1 Lux (Low Light)</option>
                    <option value="1">🌆 1 Lux (Twilight)</option>
                    <option value="10">🏙️ 10 Lux (Street Light)</option>
                    <option value="50">💡 50 Lux (Office Light)</option>
                    <option value="infrared">👁️ 0 Lux (IR Night Vision)</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-lightbulb"></i>
                    Minimum light required for clear image capture
                  </div>
                </div>
                <div class="form-group">
                  <label for="camZoom">
                    <i class="fas fa-search-plus"></i>
                    Zoom Capability
                  </label>
                  <select id="camZoom">
                    <option value="fixed" selected>📷 Fixed Lens (No Zoom)</option>
                    <option value="3x">🔍 3x Optical Zoom</option>
                    <option value="5x">🔍 5x Optical Zoom</option>
                    <option value="10x">🔭 10x Optical Zoom</option>
                    <option value="20x">🔭 20x Optical Zoom</option>
                    <option value="30x">🔬 30x+ Professional Zoom</option>
                    <option value="digital">💻 Digital Zoom Only</option>
                  </select>
                  <div class="helper-text">
                    <i class="fas fa-expand-arrows-alt"></i>
                    Optical and digital magnification capabilities
                  </div>
                </div>
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                  <label for="camRadius">
                    <i class="fas fa-circle"></i>
                    Coverage Radius (calculated)
                  </label>
                  <input id="camRadius" type="number" readonly style="background-color: #f8f9fa; color: #6c757d;" value="80" />
                  <div class="helper-text">
                    <i class="fas fa-calculator"></i>
                    Auto-calculated from height and angle
                  </div>
                </div>
                <div class="form-group">
                  <label for="camAngle">
                    <i class="fas fa-angle-double-right"></i>
                    Coverage Angle (degrees)
                  </label>
                  <input id="camAngle" type="number" min="10" max="180" step="5" value="70" />
                  <div class="helper-text">
                    <i class="fas fa-eye"></i>
                    Field of view width
                  </div>
                </div>
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr;">
                <div class="form-group">
                  <label for="camHeading">
                    <i class="fas fa-compass"></i>
                    Heading Direction (degrees)
                  </label>
                  <input id="camHeading" type="number" min="0" max="359" step="1" value="45" />
                  <div class="helper-text">
                    <i class="fas fa-location-arrow"></i>
                    Direction camera is facing (0° = North)
                  </div>
                </div>
              </div>
            </div>

            <div class="form-section">
              <div class="form-section-title">
                <i class="fas fa-map-marker-alt"></i>
                Precise Location
              </div>
              <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                  <label for="itemLatitude">
                    <i class="fas fa-globe-americas"></i>
                    Latitude
                  </label>
                  <input id="itemLatitude" type="number" step="0.000001" placeholder="25.2854" />
                  <div class="helper-text">
                    <i class="fas fa-crosshairs"></i>
                    Precise latitude coordinate (North/South)
                  </div>
                </div>
                <div class="form-group">
                  <label for="itemLongitude">
                    <i class="fas fa-globe-asia"></i>
                    Longitude
                  </label>
                  <input id="itemLongitude" type="number" step="0.000001" placeholder="51.5310" />
                  <div class="helper-text">
                    <i class="fas fa-crosshairs"></i>
                    Precise longitude coordinate (East/West)
                  </div>
                </div>
              </div>
            </div>
            
            <div class="helper-text" style="text-align: center; font-size: 0.8rem; padding: 0.75rem; background: rgba(59, 130, 246, 0.05); border-radius: 6px; border-left: 3px solid #3b82f6;">
              <i class="fas fa-lightbulb"></i>
              <strong>Placement Options:</strong> Use coordinates for precise positioning, click "Place on Map" for visual selection, or add at current map center.
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn" id="btnPlaceOnMap">
              <i class="fas fa-mouse-pointer"></i> 
              Place on Map
            </button>
            <button class="btn primary" id="btnAddNow">
              <i class="fas fa-plus"></i> 
              Add at Center
            </button>
            <button class="btn primary" id="btnAddAtCoords">
              <i class="fas fa-crosshairs"></i> 
              Add at Coordinates
            </button>
          </div>
        </div>
      </div>

      <!-- Excel Import Help Modal -->
      <div id="excelHelpModal" class="modal" aria-hidden="true">
        <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="excelHelpTitle">
          <div class="modal-header">
            <h3 id="excelHelpTitle">Excel Import Format</h3>
            <button class="modal-close" id="excelHelpClose" aria-label="Close"><i class="fas fa-times"></i></button>
          </div>
          <div class="modal-body">
            <p><strong>Required Columns:</strong></p>
            <ul style="margin: 10px 0; padding-left: 20px;">
              <li><strong>Type</strong> - Security element type (camera, post, sensor, alarm, supervisor)</li>
              <li><strong>Latitude</strong> - Coordinate latitude (-90 to 90)</li>
              <li><strong>Longitude</strong> - Coordinate longitude (-180 to 180)</li>
            </ul>
            
            <p><strong>Optional Columns:</strong></p>
            <ul style="margin: 10px 0; padding-left: 20px;">
              <li><strong>Name</strong> - Element name/label</li>
              <li><strong>Radius</strong> - Camera coverage radius (meters)</li>
              <li><strong>Angle</strong> - Camera coverage angle (degrees)</li>
              <li><strong>Heading</strong> - Camera direction (0-360 degrees)</li>
            </ul>
            
            <p><strong>Import Filter:</strong></p>
            <div style="margin: 10px 0;">
              <label for="importTypeFilter" style="font-weight: bold; margin-right: 10px;">Import Only:</label>
              <select id="importTypeFilter" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="all">All Security Elements</option>
                <option value="camera">Cameras Only</option>
                <option value="agent-post">Security Posts Only</option>
                <option value="sensor">Sensors Only</option>
                <option value="alarm">Alarms Only</option>
                <option value="supervisor">Supervisors Only</option>
              </select>
            </div>
            
            <p><strong>Example Excel Format:</strong></p>
            <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 12px;">
              <thead>
                <tr style="background: #f5f5f5;">
                  <th style="border: 1px solid #ddd; padding: 5px;">Type</th>
                  <th style="border: 1px solid #ddd; padding: 5px;">Name</th>
                  <th style="border: 1px solid #ddd; padding: 5px;">Latitude</th>
                  <th style="border: 1px solid #ddd; padding: 5px;">Longitude</th>
                  <th style="border: 1px solid #ddd; padding: 5px;">Radius</th>
                  <th style="border: 1px solid #ddd; padding: 5px;">Angle</th>
                  <th style="border: 1px solid #ddd; padding: 5px;">Heading</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="border: 1px solid #ddd; padding: 5px;">camera</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">CAM-01</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">25.2854</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">51.5310</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">100</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">70</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">45</td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ddd; padding: 5px;">agent-post</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">POST-01</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">25.2844</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">51.5320</td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ddd; padding: 5px;">sensor</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">SENS-01</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">25.2864</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">51.5300</td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ddd; padding: 5px;">alarm</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">ALRM-01</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">25.2834</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">51.5340</td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ddd; padding: 5px;">supervisor</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">SUPV-01</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">25.2874</td>
                  <td style="border: 1px solid #ddd; padding: 5px;">51.5290</td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                  <td style="border: 1px solid #ddd; padding: 5px;"></td>
                </tr>
              </tbody>
            </table>
            
            <p><strong>Supported Types:</strong> camera, agent-post, sensor, alarm, supervisor</p>
            <p><strong>File Formats:</strong> .xlsx, .xls, .csv</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn primary" id="downloadTemplate">Download Template</button>
            <button type="button" class="btn primary" id="doExcelImport">Import Excel File</button>
            <button type="button" class="btn" id="excelHelpOk">Cancel</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCUTmTn0rRBb0M-UkQJxnUMrWqXYU_BgIc",
      authDomain: "users-8be65.firebaseapp.com",
      databaseURL: "https://users-8be65-default-rtdb.firebaseio.com",
      projectId: "users-8be65",
      storageBucket: "users-8be65.firebasestorage.app",
      messagingSenderId: "909025468149",
      appId: "1:909025468149:web:fb4e7c4a8b4bd6d1076e4d",
      measurementId: "G-XHFMRCJQEZ"
    };
    function initializeFirebase(){ if(!window.firebase || !window.firebase.apps || window.firebase.apps.length===0){ window.firebase.initializeApp(firebaseConfig);} return window.firebase; }
    const firebaseApp = initializeFirebase();

    class AuthManager {
      constructor(){ this.currentUser = this.getCurrentUser(); this.currentCompany=null; this.init(); }
      getCurrentUser(){ try{return JSON.parse(localStorage.getItem('currentUser')||'null');}catch{ return null; } }
      setCurrentUser(u){ localStorage.setItem('currentUser', JSON.stringify(u)); localStorage.setItem('user', JSON.stringify(u)); this.currentUser=u; }
      async init(){ if(!this.currentUser){ window.location.href='login.html'; return; } await this.loadUserCompany(); this.updateCompanyBranding(); await this.updateUIForAuthenticatedUser(); this.bindProfileDropdown(); }
      async loadUserCompany(){ if(!this.currentUser) return; try{ const snap=await firebase.database().ref('companies').once('value'); if(!snap.exists()) return; const companies=snap.val(); for(const [cid,comp] of Object.entries(companies)){ if(comp.status!=='active') continue; if(comp.users){ for(const [uid,u] of Object.entries(comp.users)){ if(u.authUid===this.currentUser.uid || uid===this.currentUser.uid){ this.currentUser.companyId=cid; this.currentUser.companyName=comp.companyName; this.currentUser.role=u.role||u.userRole||'user'; this.currentCompany=comp; this.setCurrentUser(this.currentUser); return; } } } } }catch(e){} }
      updateCompanyBranding(){ const logoEl=document.getElementById('headerCompanyLogo'); const nameEl=document.getElementById('headerCompanyName'); if(!this.currentCompany){ if(nameEl) nameEl.textContent=''; return; } if(nameEl) nameEl.textContent=this.currentCompany.companyName||''; const logoUrl=this.currentCompany.logo||this.currentCompany.logoUrl; if(logoEl){ if(logoUrl){ logoEl.src=logoUrl; logoEl.style.display='block'; } }
      }
      getCompanyInitials(name){ if(!name) return 'CO'; const parts=name.trim().split(/\s+/); if(parts.length===1) return parts[0].substring(0,2).toUpperCase(); return (parts[0][0]+(parts[1]?.[0]||'')).toUpperCase(); }
      getUserDisplayName(){ if(!this.currentUser) return 'User'; const clean=v=> typeof v==='string'? v.trim().replace(/\s+/g,' '):''; const cand=[this.currentUser.displayName,this.currentUser.name,this.currentUser.username]; for(const c of cand){ const s=clean(c); if(s) return s; } if(this.currentUser.email) return clean(this.currentUser.email.split('@')[0])||'User'; return 'User'; }
      getUserInitials(){ const dn=this.getUserDisplayName(); const parts=dn.split(' ').filter(Boolean); if(parts.length===1) return parts[0].substring(0,2).toUpperCase(); return (parts[0][0]+parts[1][0]).toUpperCase(); }
      async getUserAvatarUrl(){ if(!this.currentUser) return null; const companyId=this.currentUser.companyId||'default'; const paths=[`companies/${companyId}/avatars/${this.currentUser.uid}/profile.jpg`,`companies/${companyId}/avatars/${this.currentUser.uid}/profile.png`,`companies/${companyId}/avatars/${this.currentUser.uid}/avatar.jpg`,`companies/${companyId}/avatars/${this.currentUser.uid}/avatar.png`,`avatars/${this.currentUser.uid}/profile.jpg`,`avatars/${this.currentUser.uid}/profile.png`,`avatars/${this.currentUser.uid}/avatar.jpg`,`avatars/${this.currentUser.uid}/avatar.png`,`profiles/${this.currentUser.uid}/profile.jpg`,`profiles/${this.currentUser.uid}/profile.png`]; for(const p of paths){ try{ const ref=firebase.storage().ref(p); const url=await ref.getDownloadURL(); return url; }catch(_){ continue; } } return null; }
      async updateUIForAuthenticatedUser(){ const btn=document.getElementById('userProfileBtn'); const list=document.querySelector('.profile-dropdown ul'); if(!btn||!list||!this.currentUser) return; const displayName=this.getUserDisplayName(); const email=this.currentUser.email||''; let avatarUrl=null; try{ avatarUrl=await this.getUserAvatarUrl(); }catch(_){}
        const btnImg=btn.querySelector('img'); if(avatarUrl && btnImg){ btnImg.src=avatarUrl; btnImg.alt=displayName+' Avatar'; btnImg.style.display='block'; btnImg.onerror=()=>{ btnImg.style.display='none'; btn.innerHTML=`<div style="width:38px;height:38px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:0.8rem;">${this.getUserInitials()}</div>`; }; } else { btn.innerHTML=`<div style="width:38px;height:38px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:0.8rem;">${this.getUserInitials()}</div>`; }
        const avatarHtml = avatarUrl ? `<img src="${avatarUrl}" alt="${displayName} Avatar" style="width:32px;height:32px;border-radius:50%;object-fit:cover;">` : `<div style="width:32px;height:32px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:12px;">${this.getUserInitials()}</div>`;
        list.innerHTML = `<li style="border-bottom:1px solid #eee;padding:12px 16px;background:#f8f9fa;"><div style="display:flex;align-items:center;gap:12px;">${avatarHtml}<div><div style="font-weight:600;color:#333;font-size:14px;margin-bottom:2px;">${displayName}</div><div style="color:#666;font-size:12px;">${email}</div></div></div></li><li><a href="profile.html"><i class=\"fas fa-user\"></i> Profile</a></li><li><a href="account.html"><i class=\"fas fa-cog\"></i> Account Settings</a></li><li><a href="#" id="logoutLink"><i class=\"fas fa-sign-out-alt\"></i> Sign out</a></li>`;
        const logoutEl=list.querySelector('#logoutLink'); if(logoutEl){ logoutEl.addEventListener('click', (e)=>{ e.preventDefault(); this.logout(); }); }
      }
      async logout(){ try{ await firebase.auth().signOut(); }catch(_){ } finally { localStorage.removeItem('currentUser'); localStorage.removeItem('user'); window.location.href='login.html'; } }
      bindProfileDropdown(){ const btn=document.getElementById('userProfileBtn'); const dd=document.querySelector('.profile-dropdown'); if(btn && dd){ btn.addEventListener('click', (e)=>{ e.stopPropagation(); dd.classList.toggle('show'); }); document.addEventListener('click',(e)=>{ if(!dd.contains(e.target) && e.target!==btn){ dd.classList.remove('show'); } }); }
      }
    }
    window.authManager = new AuthManager();

  // ===== ROLE-BASED MENU AUTHORIZATION SYSTEM (exact from project-list.html) =====
  let isMenuUpdateInProgress = false;
  function resetMenuVisibility() {
    document.querySelectorAll('[data-feature]').forEach(item => {
      item.classList.remove('menu-visible');
    });
    document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
      dropdown.classList.remove('menu-visible');
    });
  }
  function showBasicMenu() {
    console.log('🔧 Emergency fallback: Showing basic menu items');
    resetMenuVisibility();
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) { sidebar.classList.remove('menu-loading'); }
    const homeItem = document.querySelector('[data-feature="home_view"]');
    if (homeItem) { homeItem.classList.add('menu-visible'); }
  }
  async function updateMenuWithFeatureAuthorization() {
    if (isMenuUpdateInProgress) {
      console.log('🔄 Menu update already in progress, skipping...');
      return;
    }
    isMenuUpdateInProgress = true;
    console.log('🎯 Starting feature-based menu authorization for sitemap.html...');
    try {
      let currentUser = null; let companyId = null; let userRole = null;
      if (window.authManager && window.authManager.currentUser) {
        currentUser = window.authManager.currentUser;
        companyId = currentUser.companyId;
        userRole = currentUser.role;
        console.log('👤 Using AuthManager - User:', currentUser.email, 'Company ID:', companyId, 'Role:', userRole);
      } else if (firebase.auth().currentUser) {
        currentUser = firebase.auth().currentUser;
        console.log('👤 Using Firebase auth - will search for company and role');
      } else {
        console.log('❌ No authenticated user found');
        resetMenuVisibility();
        return;
      }
      if (!companyId && currentUser) {
        console.log('🔍 Searching for user company and role...');
        const database = firebase.database();
        const companiesRef = database.ref('companies');
        const companiesSnapshot = await companiesRef.once('value');
        if (companiesSnapshot.exists()) {
          const companies = companiesSnapshot.val();
          for (const [cId, company] of Object.entries(companies)) {
            if (company.status !== 'active') continue;
            if (company.users && company.users[currentUser.uid]) {
              companyId = cId;
              userRole = company.users[currentUser.uid].role || company.users[currentUser.uid].userRole;
              console.log(`✅ Found user in company: ${companyId} (${company.name}) with role: ${userRole}`);
              break;
            }
          }
        }
      }
      if (!companyId) {
        console.error('❌ No company ID found, cannot determine authorized features');
        resetMenuVisibility();
        return;
      }
      if (!userRole) {
        console.warn('⚠️ No user role found, proceeding with company features only');
      }
      console.log('🏢 STEP 1: Applying company feature authorization...');
      const authorizedPages = await applyFeatureBasedMenuVisibility(companyId);
      if (userRole) {
        console.log('👤 STEP 2: Applying role-based filtering within authorized features...');
        await applyRoleBasedFiltering(companyId, userRole, authorizedPages);
      } else {
        console.log('⚠️ STEP 2: Skipping role-based filtering (no role found)');
      }
    } catch (error) {
      console.error('❌ Error in feature-based menu authorization:', error);
      resetMenuVisibility();
    } finally {
      isMenuUpdateInProgress = false;
    }
  }
  async function applyFeatureBasedMenuVisibility(companyId) {
    try {
      console.log('🔧 Applying feature-based menu visibility for company:', companyId);
      const database = firebase.database();
      const featuresSnapshot = await database.ref('/platformFeatures').once('value');
      if (!featuresSnapshot.exists()) {
        console.log('⚠️ No platform features found - enabling fallback visibility');
        showFallbackMenuItems();
        return [];
      }
      const featuresData = featuresSnapshot.val();
      console.log('📋 Available platform features:', Object.keys(featuresData));
      
      const companySnapshot = await database.ref(`/companies/${companyId}`).once('value');
      const companyData = companySnapshot.val();
      if (!companyData) {
        console.error('❌ Company data not found - enabling fallback visibility');
        showFallbackMenuItems();
        return [];
      }
      
      const subscribedFeatureIds = companyData.selectedFeatures || [];
      console.log('🏢 Company subscribed features:', subscribedFeatureIds);
      console.log('🏢 Company data structure:', {
        hasSelectedFeatures: !!companyData.selectedFeatures,
        selectedFeaturesLength: subscribedFeatureIds.length,
        companyStatus: companyData.status
      });
      
      if (subscribedFeatureIds.length === 0) {
        console.log('⚠️ Company has no subscribed features - enabling fallback visibility');
        showFallbackMenuItems();
        return [];
      }
      
      const authorizedPages = [];
      const missingFeatures = [];
      
      subscribedFeatureIds.forEach(featureId => {
        const feature = featuresData[featureId];
        if (feature && feature.status === 'active' && feature.authorizedPages) {
          console.log(`📦 Adding pages from feature "${feature.name}" (${featureId}):`, feature.authorizedPages);
          authorizedPages.push(...feature.authorizedPages);
        } else {
          console.log(`⚠️ Feature ${featureId} not found, inactive, or missing authorizedPages`);
          missingFeatures.push(featureId);
          if (feature) {
            console.log(`   - Feature exists: ${!!feature}, Status: ${feature.status}, Has pages: ${!!feature.authorizedPages}`);
          }
        }
      });
      
      if (missingFeatures.length > 0) {
        console.warn('🚨 Missing or inactive features:', missingFeatures);
      }
      
      console.log('🔐 All authorized pages:', authorizedPages);
      resetMenuVisibility();
      
      const authorizedFeatures = new Set();
      authorizedPages.forEach(pageInfo => { 
        if (pageInfo.feature) { 
          authorizedFeatures.add(pageInfo.feature); 
        } else {
          console.warn('⚠️ Authorized page missing feature attribute:', pageInfo);
        }
      });
      
      console.log('🎯 Authorized features for sitemap.html:', Array.from(authorizedFeatures));
      
      const allMenuItems = document.querySelectorAll('#roleBasedMenu li[data-feature]');
      const hiddenItems = [];
      let visibleCount = 0;
      
      allMenuItems.forEach(menuItem => {
        const featureAttribute = menuItem.getAttribute('data-feature');
        const isDropdownContainer = menuItem.classList.contains('menu-dropdown');
        if (isDropdownContainer) return;
        
        if (authorizedFeatures.has(featureAttribute)) {
          menuItem.classList.add('menu-visible');
          visibleCount++;
          console.log(`✅ Feature authorized - showing menu item: ${featureAttribute}`);
        } else {
          menuItem.classList.remove('menu-visible');
          hiddenItems.push(featureAttribute);
          console.log(`❌ Feature not authorized - hiding menu item: ${featureAttribute}`);
        }
      });
      
      const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
      const hiddenDropdowns = [];
      
      dropdownMenus.forEach(dropdown => {
        const dropdownFeature = dropdown.getAttribute('data-feature');
        const submenuItems = dropdown.querySelectorAll('.submenu li[data-feature]');
        let hasVisibleChildren = false;
        let visibleChildrenCount = 0;
        
        submenuItems.forEach(submenuItem => { 
          if (submenuItem.classList.contains('menu-visible')) { 
            hasVisibleChildren = true; 
            visibleChildrenCount++;
          } 
        });
        
        if (hasVisibleChildren || authorizedFeatures.has(dropdownFeature)) {
          dropdown.classList.add('menu-visible');
          console.log(`✅ Showing dropdown menu: ${dropdownFeature} (${visibleChildrenCount} visible children or directly authorized)`);
        } else {
          dropdown.classList.remove('menu-visible');
          hiddenDropdowns.push(dropdownFeature);
          console.log(`❌ Hiding dropdown menu: ${dropdownFeature} (no visible children and not authorized)`);
        }
      });
      
      // Summary report
      console.log(`📊 FEATURE AUTHORIZATION SUMMARY:`);
      console.log(`   - Total authorized features: ${authorizedFeatures.size}`);
      console.log(`   - Visible menu items: ${visibleCount}`);
      console.log(`   - Hidden items due to features: ${hiddenItems.length}`, hiddenItems);
      console.log(`   - Hidden dropdowns: ${hiddenDropdowns.length}`, hiddenDropdowns);
      
      return authorizedPages;
    } catch (error) {
      console.error('❌ Error applying feature-based menu visibility:', error);
      console.error('   Error details:', error.message, error.stack);
      showFallbackMenuItems();
      return [];
    }
  }
  async function applyRoleBasedFiltering(companyId, userRole, authorizedPages) {
    try {
      console.log('👤 Applying role-based filtering for role:', userRole);
      const database = firebase.database();
      const permissionsRef = database.ref(`companies/${companyId}/roles/${userRole}/permissions`);
      const permissionsSnapshot = await permissionsRef.once('value');
      if (!permissionsSnapshot.exists()) {
        console.log(`⚠️ No permissions found for role ${userRole} in company ${companyId}`);
        const allRolesRef = database.ref(`companies/${companyId}/roles`);
        const allRolesSnapshot = await allRolesRef.once('value');
        if (allRolesSnapshot.exists()) {
          const allRoles = allRolesSnapshot.val();
          console.log('🔍 Available roles in company:', Object.keys(allRoles));
          if (userRole === 'administrator') {
            console.log('🔑 ADMINISTRATOR - Full roles data:', allRoles);
            if (allRoles.administrator) {
              console.log('🔑 ADMINISTRATOR role found in company:', allRoles.administrator);
              if (allRoles.administrator.permissions) {
                console.log('🔑 ADMINISTRATOR permissions found:', allRoles.administrator.permissions);
                filterMenuByPermissions(allRoles.administrator.permissions);
                return;
              }
            }
          }
          const roleKeys = Object.keys(allRoles);
          const matchingRole = roleKeys.find(key => 
            key.toLowerCase() === userRole.toLowerCase() ||
            key.replace(/\s+/g, '').toLowerCase() === userRole.replace(/\s+/g, '').toLowerCase()
          );
          if (matchingRole && allRoles[matchingRole].permissions) {
            console.log(`✅ Found matching role: ${matchingRole}`);
            const permissions = allRoles[matchingRole].permissions;
            filterMenuByPermissions(permissions);
            return;
          }
        }
        if (userRole === 'administrator') {
          console.log('🔑 ADMINISTRATOR FALLBACK - Skipping role filtering (keeping all company features visible)');
          showSidebarAfterAuth();
          return;
        }
        console.log('❌ No valid permissions found - filtering out items requiring permissions');
        hideItemsRequiringPermissions();
        showSidebarAfterAuth();
        return;
      }
      const permissions = permissionsSnapshot.val();
      console.log('✅ Loaded role permissions:', permissions);
      filterMenuByPermissions(permissions);
    } catch (error) {
      console.error('❌ Error applying role-based filtering:', error);
      showSidebarAfterAuth();
    }
  }
  function filterMenuByPermissions(permissions) {
    console.log('🔍 Filtering visible menu items by role permissions...');
    if (!permissions) {
      console.log('⚠️ No permissions object provided - hiding items requiring permissions');
      hideItemsRequiringPermissions();
      showSidebarAfterAuth();
      return;
    }
    
    console.log('📋 Available permissions:', Object.keys(permissions));
    const visibleMenuItems = document.querySelectorAll('#roleBasedMenu li.menu-visible[data-requires-permission]');
    console.log(`🎯 Found ${visibleMenuItems.length} visible menu items requiring permissions to check`);
    
    const permissionResults = [];
    let hiddenCount = 0;
    
    visibleMenuItems.forEach(item => {
      const requiresPermission = item.getAttribute('data-requires-permission');
      const feature = item.getAttribute('data-feature');
      
      if (requiresPermission) {
        const hasPermission = permissions[requiresPermission];
        const hasViewPermission = hasPermission === true || (hasPermission && hasPermission.view === true);
        
        const result = {
          feature,
          requiresPermission,
          hasPermission: !!hasPermission,
          hasViewPermission,
          permissionValue: hasPermission,
          action: hasViewPermission ? 'KEEP' : 'HIDE'
        };
        permissionResults.push(result);
        
        if (!hasViewPermission) {
          item.classList.remove('menu-visible');
          hiddenCount++;
          console.log(`❌ Hiding menu item (no permission): ${feature} (requires: ${requiresPermission})`);
        } else {
          console.log(`✅ Keeping menu item visible: ${feature} (has permission: ${requiresPermission})`);
        }
      }
    });
    
    // Handle dropdowns
    const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
    const dropdownResults = [];
    
    dropdownMenus.forEach(dropdown => {
      const submenuItems = dropdown.querySelectorAll('.submenu li.menu-visible');
      const dropdownFeature = dropdown.getAttribute('data-feature');
      const dropdownRequires = dropdown.getAttribute('data-requires-permission');
      
      let dropdownAction = 'KEEP';
      let reason = `${submenuItems.length} visible children`;
      
      if (submenuItems.length === 0) {
        if (dropdownRequires) {
          const hasDropdownPermission = permissions[dropdownRequires] === true || (permissions[dropdownRequires] && permissions[dropdownRequires].view === true);
          if (!hasDropdownPermission) {
            dropdown.classList.remove('menu-visible');
            hiddenCount++;
            dropdownAction = 'HIDE';
            reason = 'no children and no permission';
            console.log(`❌ Hiding dropdown (no children and no permission): ${dropdownFeature}`);
          } else {
            reason = 'has dropdown permission';
            console.log(`✅ Keeping dropdown visible (has permission): ${dropdownFeature}`);
          }
        } else {
          dropdown.classList.remove('menu-visible');
          dropdownAction = 'HIDE';
          reason = 'no visible children';
          console.log(`❌ Hiding dropdown (no visible children): ${dropdownFeature}`);
        }
      } else {
        console.log(`✅ Keeping dropdown visible (${submenuItems.length} visible children): ${dropdownFeature}`);
      }
      
      dropdownResults.push({
        dropdown: dropdownFeature,
        requiresPermission: dropdownRequires,
        visibleChildren: submenuItems.length,
        action: dropdownAction,
        reason
      });
    });
    
    // Detailed summary
    console.log(`📊 PERMISSION FILTERING SUMMARY:`);
    console.log(`   - Items checked: ${permissionResults.length}`);
    console.log(`   - Items hidden: ${hiddenCount}`);
    console.log(`   - Permission details:`, permissionResults);
    console.log(`   - Dropdown details:`, dropdownResults);
    
    ensureHomeIsVisible();
    showSidebarAfterAuth();
  }
  function hideItemsRequiringPermissions() {
    console.log('🔒 Hiding all menu items that require permissions...');
    const itemsRequiringPermissions = document.querySelectorAll('#roleBasedMenu li.menu-visible[data-requires-permission]');
    let hiddenCount = 0;
    itemsRequiringPermissions.forEach(item => {
      const feature = item.getAttribute('data-feature');
      const requiresPermission = item.getAttribute('data-requires-permission');
      item.classList.remove('menu-visible');
      hiddenCount++;
      console.log(`❌ Hiding menu item (requires permission): ${feature} (${requiresPermission})`);
    });
    const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
    dropdownMenus.forEach(dropdown => {
      const visibleSubmenuItems = dropdown.querySelectorAll('.submenu li.menu-visible');
      if (visibleSubmenuItems.length === 0) {
        dropdown.classList.remove('menu-visible');
        const dropdownFeature = dropdown.getAttribute('data-feature');
        console.log(`❌ Hiding dropdown (no visible children): ${dropdownFeature}`);
      }
    });
    console.log(`🔒 Hidden ${hiddenCount} items requiring permissions`);
    ensureHomeIsVisible();
  }
  function ensureHomeIsVisible() {
    const homeItem = document.querySelector('#roleBasedMenu li[data-feature="home_view"]');
    if (homeItem && !homeItem.classList.contains('menu-visible')) {
      homeItem.classList.add('menu-visible');
      console.log('✅ Ensured home menu item is visible as fallback');
    }
  }
  function showSidebarAfterAuth() {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('menu-loading');
      console.log('✅ Sidebar loading state removed - menu authorization complete');
    }
  }
  function initializeMenuAuthorization() {
    console.log('🚀 Initializing menu authorization system...');
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) { sidebar.classList.add('menu-loading'); }
    setTimeout(() => { updateMenuWithFeatureAuthorization(); }, 500);
  }
  window.updateMenuWithFeatureAuthorization = updateMenuWithFeatureAuthorization;
  window.debugMenuState = function() {
    console.log('🔧 DEBUG MENU STATE:');
    const user = window.authManager?.currentUser;
    console.log('👤 Current user:', {
      email: user?.email,
      companyId: user?.companyId,
      role: user?.role
    });
    
    const menuItems = document.querySelectorAll('[data-feature]');
    console.log(`📊 Total menu items: ${menuItems.length}`);
    
    const visible = [];
    const hidden = [];
    
    menuItems.forEach(item => {
      const feature = item.getAttribute('data-feature');
      const requiresPermission = item.getAttribute('data-requires-permission');
      const isVisible = item.classList.contains('menu-visible');
      const isDropdown = item.classList.contains('menu-dropdown');
      
      const itemInfo = {
        feature,
        requiresPermission,
        isDropdown,
        isVisible,
        tagName: item.tagName.toLowerCase()
      };
      
      if (isVisible) {
        visible.push(itemInfo);
      } else {
        hidden.push(itemInfo);
      }
    });
    
    console.log(`✅ Visible items (${visible.length}):`, visible);
    console.log(`❌ Hidden items (${hidden.length}):`, hidden);
    
    // Specific check for accommodation/camp items
    const accommodationItems = ['accommodation_view', 'camp_view', 'camp_settings_view'];
    console.log('🏕️ CAMP MANAGEMENT DEBUG:');
    accommodationItems.forEach(feature => {
      const element = document.querySelector(`[data-feature="${feature}"]`);
      if (element) {
        const isVisible = element.classList.contains('menu-visible');
        const requiresPermission = element.getAttribute('data-requires-permission');
        const isDropdown = element.classList.contains('menu-dropdown');
        console.log(`   - ${feature}: visible=${isVisible}, requires=${requiresPermission}, isDropdown=${isDropdown}`);
        
        if (feature === 'accommodation_view' && element.classList.contains('menu-dropdown')) {
          const submenuItems = element.querySelectorAll('.submenu li[data-feature]');
          console.log(`     Submenu items found: ${submenuItems.length}`);
          submenuItems.forEach(sub => {
            const subFeature = sub.getAttribute('data-feature');
            const subVisible = sub.classList.contains('menu-visible');
            const subRequires = sub.getAttribute('data-requires-permission');
            console.log(`       - ${subFeature}: visible=${subVisible}, requires=${subRequires}`);
          });
        }
      } else {
        console.log(`   - ${feature}: ❌ Element not found in DOM`);
      }
    });

    // Specific check for fuel management items
  const fuelManagementItems = ['fuel_management', 'vessel_offloading', 'fuel_storage', 'tank_transfer', 'truck_loading', 'quality_analysis', 'fuel_distribution', 'fuel_consumption_analysis', 'fuel_daily_report'];
    console.log('⛽ FUEL MANAGEMENT DEBUG:');
    fuelManagementItems.forEach(feature => {
      const element = document.querySelector(`[data-feature="${feature}"]`);
      if (element) {
        const isVisible = element.classList.contains('menu-visible');
        const requiresPermission = element.getAttribute('data-requires-permission');
        const isDropdown = element.classList.contains('menu-dropdown');
        console.log(`   - ${feature}: visible=${isVisible}, requires=${requiresPermission}, isDropdown=${isDropdown}`);
        
        if (feature === 'fuel_management' && element.classList.contains('menu-dropdown')) {
          const submenuItems = element.querySelectorAll('.submenu li[data-feature]');
          console.log(`     Submenu items found: ${submenuItems.length}`);
          submenuItems.forEach(sub => {
            const subFeature = sub.getAttribute('data-feature');
            const subVisible = sub.classList.contains('menu-visible');
            const subRequires = sub.getAttribute('data-requires-permission');
            console.log(`       - ${subFeature}: visible=${subVisible}, requires=${subRequires}`);
          });
        }
      } else {
        console.log(`   - ${feature}: ❌ Element not found in DOM`);
      }
    });
    
    // Check loading state
    const sidebar = document.querySelector('.sidebar');
    const isLoading = sidebar?.classList.contains('menu-loading');
    console.log('🔄 Menu loading state:', isLoading);
    
    return { visible, hidden, isLoading, totalItems: menuItems.length };
  };
  
  window.debugAccommodationSpecific = async function() {
    console.log('🏕️ ACCOMMODATION SPECIFIC DEBUG:');
    const user = window.authManager?.currentUser;
    if (!user?.companyId) {
      console.error('❌ No company ID found');
      return;
    }
    
    try {
      const database = firebase.database();
      
      // Check platform features
      const featuresSnap = await database.ref('/platformFeatures').once('value');
      const features = featuresSnap.val() || {};
      console.log('📋 Platform features containing "accommodation" or "camp":');
      Object.entries(features).forEach(([key, feature]) => {
        if (key.toLowerCase().includes('accommodation') || key.toLowerCase().includes('camp') || 
            (feature.name && (feature.name.toLowerCase().includes('accommodation') || feature.name.toLowerCase().includes('camp')))) {
          console.log(`   - ${key}:`, {
            name: feature.name,
            status: feature.status,
            authorizedPages: feature.authorizedPages
          });
        }
      });
      
      // Check company selected features
      const companySnap = await database.ref(`/companies/${user.companyId}/selectedFeatures`).once('value');
      const selectedFeatures = companySnap.val() || [];
      console.log('🏢 Company selected features:', selectedFeatures);
      console.log('🏢 Features containing accommodation/camp:', selectedFeatures.filter(f => 
        f.toLowerCase().includes('accommodation') || f.toLowerCase().includes('camp')));
      
      // Check role permissions
      if (user.role) {
        const permSnap = await database.ref(`/companies/${user.companyId}/roles/${user.role}/permissions`).once('value');
        const permissions = permSnap.val() || {};
        console.log('👤 Role permissions for accommodation/camp:');
        ['accommodation_view', 'camp_view', 'camp_settings_view'].forEach(perm => {
          console.log(`   - ${perm}:`, permissions[perm]);
        });
      }
      
    } catch (error) {
      console.error('❌ Error in accommodation debug:', error);
    }
  };

  window.debugFuelManagementSpecific = async function() {
    console.log('⛽ FUEL MANAGEMENT SPECIFIC DEBUG:');
    const user = window.authManager?.currentUser;
    if (!user?.companyId) {
      console.error('❌ No company ID found');
      return;
    }
    
    try {
      const database = firebase.database();
      
      // Check platform features
      const featuresSnap = await database.ref('/platformFeatures').once('value');
      const features = featuresSnap.val() || {};
      console.log('📋 Platform features containing "fuel":');
      Object.entries(features).forEach(([key, feature]) => {
        if (key.toLowerCase().includes('fuel') || 
            (feature.name && feature.name.toLowerCase().includes('fuel'))) {
          console.log(`   - ${key}:`, {
            name: feature.name,
            status: feature.status,
            authorizedPages: feature.authorizedPages
          });
        }
      });
      
      // Check company selected features
      const companySnap = await database.ref(`/companies/${user.companyId}/selectedFeatures`).once('value');
      const selectedFeatures = companySnap.val() || [];
      console.log('🏢 Company selected features:', selectedFeatures);
      console.log('🏢 Features containing fuel:', selectedFeatures.filter(f => 
        f.toLowerCase().includes('fuel')));
      
      // Check role permissions
      if (user.role) {
        const permSnap = await database.ref(`/companies/${user.companyId}/roles/${user.role}/permissions`).once('value');
        const permissions = permSnap.val() || {};
        console.log('👤 Role permissions for fuel management:');
  ['fuel_management', 'vessel_offloading', 'fuel_storage', 'tank_transfer', 'truck_loading', 'quality_analysis', 'fuel_distribution', 'fuel_consumption_analysis', 'fuel_daily_report'].forEach(perm => {
          console.log(`   - ${perm}:`, permissions[perm]);
        });
      }
      
      // Check DOM elements
      console.log('🔍 DOM elements for fuel management:');
      const fuelDropdown = document.querySelector('[data-feature="fuel_management"]');
      if (fuelDropdown) {
        const isVisible = fuelDropdown.classList.contains('menu-visible');
        const requiresPermission = fuelDropdown.getAttribute('data-requires-permission');
        console.log(`   - fuel_management dropdown: visible=${isVisible}, requires=${requiresPermission}`);
        
        const submenuItems = fuelDropdown.querySelectorAll('.submenu li[data-feature]');
        console.log(`   - Submenu items found: ${submenuItems.length}`);
        submenuItems.forEach(sub => {
          const subFeature = sub.getAttribute('data-feature');
          const subVisible = sub.classList.contains('menu-visible');
          const subRequires = sub.getAttribute('data-requires-permission');
          console.log(`     - ${subFeature}: visible=${subVisible}, requires=${subRequires}`);
        });
      } else {
        console.log('   - ❌ fuel_management dropdown not found in DOM');
      }
      
    } catch (error) {
      console.error('❌ Error in fuel management debug:', error);
    }
  };
  
  function showFallbackMenuItems() {
    console.log('🚨 FALLBACK: Showing essential menu items due to authorization failure');
    resetMenuVisibility();
    
    // Show essential items that should always be available
    const essentialFeatures = ['home_view', 'communication_view'];
    essentialFeatures.forEach(feature => {
      const item = document.querySelector(`[data-feature="${feature}"]`);
      if (item) {
        item.classList.add('menu-visible');
        console.log(`✅ Fallback: Showing essential item: ${feature}`);
      }
    });
    
    showSidebarAfterAuth();
  }
  // ===== END ROLE-BASED MENU AUTHORIZATION SYSTEM =====

    let map; let layers={ posts:L.layerGroup(), cameras:L.layerGroup(), sensors:L.layerGroup(), alarms:L.layerGroup(), supervisors:L.layerGroup(), fences:L.layerGroup(), selections:L.layerGroup() };
    function initMap(){ if(window.map){ try{ window.map.remove(); }catch(_){} } map=L.map('securityMap',{ center:[25.2854,51.5310], zoom:12, zoomControl:true }); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OpenStreetMap contributors', crossOrigin:true }).addTo(map); layers.posts.addTo(map); layers.cameras.addTo(map); layers.sensors.addTo(map); layers.alarms.addTo(map); layers.supervisors.addTo(map); layers.fences.addTo(map); layers.selections.addTo(map);
      const overlays={ 'Posts':layers.posts, 'Cameras':layers.cameras, 'Sensors':layers.sensors, 'Alarms':layers.alarms, 'Supervisors':layers.supervisors, 'Fences':layers.fences, 'Selections':layers.selections };
      L.control.layers({}, overlays, { collapsed:true }).addTo(map);
      const legend=L.control({position:'bottomright'});
      legend.onAdd=function(){ const div=L.DomUtil.create('div','info legend'); div.style.background='#fff'; div.style.padding='6px 8px'; div.style.borderRadius='6px'; div.style.boxShadow='0 2px 6px rgba(0,0,0,0.15)'; div.innerHTML='<div style="font-weight:600;margin-bottom:4px;">Legend</div>'+
        '<div><span style="display:inline-block;width:10px;height:10px;background:#2ecc71;border-radius:50%;margin-right:6px;border:1px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,0.2);"></span>Security Post</div>'+
        '<div><span style="display:inline-block;width:10px;height:10px;background:#3498db;border-radius:50%;margin-right:6px;border:1px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,0.2);"></span>Camera</div>'+
        '<div><span style="display:inline-block;width:10px;height:10px;background:#9b59b6;border-radius:50%;margin-right:6px;border:1px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,0.2);"></span>Sensor</div>'+
        '<div><span style="display:inline-block;width:10px;height:10px;background:#e74c3c;border-radius:50%;margin-right:6px;border:1px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,0.2);"></span>Alarm</div>'+
        '<div><span style="display:inline-block;width:10px;height:10px;background:#f39c12;border-radius:50%;margin-right:6px;border:1px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,0.2);"></span>Supervisor</div>'+
        '<div><span style="display:inline-block;width:10px;height:2px;background:#8e44ad;margin-right:6px;border:1px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,0.2);"></span>Fence</div>';
        return div; };
      legend.addTo(map); }

  const state={ items:[], shapes:[], fences:[], selections:[], nextId: 1 };
  const undoStack = [];
  function pushUndo(action){ undoStack.push(action); if(undoStack.length>100) undoStack.shift(); }
    let editingItemId = null; // Track which item is being edited
    let securityElements = [];
    
    // Fence drawing variables
    let isDrawingFence = false;
    let currentFencePoints = [];
    let currentFencePolyline = null;
    let fenceLayer = null;

  // Area selection drawing variables
  let isDrawingArea = false;
  let currentAreaPoints = [];
  let currentAreaPolygon = null;
    
    function addMarker(type, latlng, data={}, itemId=null){ 
      const colorMap={ 'agent-post':'#2ecc71', 'camera':'#3498db', 'sensor':'#9b59b6', 'alarm':'#e74c3c', 'supervisor':'#f39c12' }; 
      const isCamera = type === 'camera';
      const iconHtml = `<div style="width:12px;height:12px;border-radius:50%;background:${colorMap[type]||'#34495e'};border:2px solid #fff;box-shadow:0 0 0 2px rgba(0,0,0,0.15);cursor:${isCamera?'pointer':'move'};" title="${isCamera?'Click for details':('Drag to move ' + type)}"></div>`; 
      const icon = L.divIcon({ className:'', html:iconHtml, iconSize:[16,16], iconAnchor:[8,8] }); 
      let layer=layers.alarms; 
      if(type==='agent-post') layer=layers.posts; 
      else if(type==='camera') layer=layers.cameras; 
      else if(type==='sensor') layer=layers.sensors; 
      else if(type==='supervisor') layer=layers.supervisors; 
      
  const marker=L.marker(latlng,{ icon, draggable: !isCamera }).addTo(layer); 
      
      // Add drag event handlers for non-camera markers only
      if (!isCamera) {
        marker.on('dragstart', function(e) {
          this.setOpacity(0.7);
          console.log(`Started dragging ${type} ${id}`);
        });
        marker.on('drag', function(e) {
          const currentPos = e.target.getLatLng();
        });
        marker.on('dragend', function(e) {
          this.setOpacity(1.0);
          const newPos = e.target.getLatLng();
          const item = state.items.find(item => item.id === id);
          if (item) {
            const oldPosition = { lat: item.lat, lng: item.lng };
            item.lat = newPos.lat;
            item.lng = newPos.lng;
            updateMarkerPopup(marker, type, newPos, data, id);
            const securityElement = securityElements.find(el => el.id === id);
            if (securityElement) { securityElement.lat = newPos.lat; securityElement.lng = newPos.lng; }
            console.log(`${type} ${id} moved from ${oldPosition.lat.toFixed(6)},${oldPosition.lng.toFixed(6)} to ${newPos.lat.toFixed(6)}, ${newPos.lng.toFixed(6)}`);
          }
        });
      }
      
  // Assign or use existing ID
  const id = itemId || state.nextId++;
  // Expose id on marker for subsequent linkage
  marker._itemId = id;
      
      // Enhanced popup with edit button
      let popupContent = `
        <div style="text-align: center;">
          <strong>${type.replace('-', ' ').toUpperCase()}</strong><br>
          <strong>${data.name||''}</strong><br>`;
      
      // Add camera specifications for cameras
      if (type === 'camera') {
        // Prefer linking by cameraId; fallback to proximity match
        let shape = state.shapes.find(s => s.kind === 'cameraSector' && s.cameraId === id);
        if (!shape) {
          shape = state.shapes.find(s => s.kind === 'cameraSector' && 
            Math.abs(s.center[0] - latlng.lat) < 0.000001 && 
            Math.abs(s.center[1] - latlng.lng) < 0.000001);
        }
        
        if (shape && shape.specs) {
          // Get resolution and environmental resistance from shape data
          const resolution = shape.resolution ? shape.resolution.toUpperCase() : 'N/A';
          const envResistance = shape.environmentalResistance ? shape.environmentalResistance.toUpperCase() : 'N/A';
          const rating = shape.specs.rating;
          
          popupContent += `
            <div style="margin: 8px 0; padding: 6px; background: rgba(52, 152, 219, 0.1); border-radius: 4px; font-size: 11px;">
              <div style="color: #3498db; font-weight: bold;"><i class="fas fa-video"></i> ${shape.specs.type} Camera</div>`;
          
          // Add comprehensive rating if available
          if (rating) {
            popupContent += `
              <div style="margin: 6px 0; padding: 4px; background: ${rating.color}20; border-left: 3px solid ${rating.color}; border-radius: 3px;">
                <div style="color: ${rating.color}; font-weight: bold; font-size: 12px;">
                  🏆 Overall Rating: ${rating.grade} (${rating.percentage}%)
                </div>
                <div style="color: #2c3e50; font-size: 10px; margin-top: 2px;">
                  ${rating.description} • Score: ${rating.totalScore}/${rating.maxScore}
                </div>
              </div>
              <div style="margin: 4px 0; font-size: 10px;">
                <div style="color: #2c3e50; display: grid; grid-template-columns: 1fr 1fr; gap: 2px;">
                  <div>📷 Type: ${rating.categoryRatings.cameraType.rating}</div>
                  <div>📺 Resolution: ${rating.categoryRatings.resolution.rating}</div>
                  <div>🌙 Low Light: ${rating.categoryRatings.lowLight.rating}</div>
                  <div>🔍 Zoom: ${rating.categoryRatings.zoom.rating}</div>
                  <div>🛡️ Protection: ${rating.categoryRatings.protection.rating}</div>
                  <div>⚡ Power: ${rating.categoryRatings.power.rating}</div>
                </div>
              </div>`;
            
            // Add top recommendation if available
            if (rating.recommendations && rating.recommendations.length > 0) {
              popupContent += `
                <div style="margin: 4px 0; padding: 3px; background: rgba(241, 196, 15, 0.1); border-radius: 3px; font-size: 10px; color: #7f8c8d;">
                  💡 ${rating.recommendations[0]}
                </div>`;
            }
          }
          
          popupContent += `
              <div style="color: #2c3e50;">📏 Range: ${shape.specs.range} | 👁️ FOV: ${shape.specs.fov}</div>
              <div style="color: #2c3e50;">📐 Height: ${shape.specs.height} | 📊 Quality: ${shape.specs.quality}</div>
              <div style="color: #2c3e50;">📺 Resolution: ${resolution} | 🛡️ Protection: ${envResistance}</div>
              <div style="color: #7f8c8d;">Coverage: ${shape.specs.coverage}</div>
            </div>`;
        } else if (data.camType) {
          const cameraTypeDisplay = data.camType.charAt(0).toUpperCase() + data.camType.slice(1);
          popupContent += `<small style="color: #3498db;"><i class="fas fa-video"></i> ${cameraTypeDisplay} Camera</small><br>`;
        }
        
        if (data.height) {
          popupContent += `<small style="color: #9b59b6;"><i class="fas fa-arrows-alt-v"></i> Height: ${data.height}m</small><br>`;
        }
      }
      
      popupContent += `<small>Lat: ${latlng.lat.toFixed(6)}, Lng: ${latlng.lng.toFixed(6)}</small><br>
          <button onclick="editSecurityElement(${id})" style="margin-top: 5px; padding: 3px 8px; font-size: 12px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">Edit</button>`;
      
      // Add rating details button for cameras
      if (type === 'camera') {
        popupContent += `<button onclick="showCameraRatingDetails(${id})" style="margin-top: 5px; margin-left: 3px; padding: 3px 8px; font-size: 12px; background: #9b59b6; color: white; border: none; border-radius: 3px; cursor: pointer;">Rating Details</button>`;
      }
      
      popupContent += `<button onclick="deleteSecurityElement(${id})" style="margin-top: 5px; margin-left: 3px; padding: 3px 8px; font-size: 12px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
        </div>
      `;
      marker.bindPopup(popupContent);
      
      // Store marker reference in the item
      const item = { id, type, lat:latlng.lat, lng:latlng.lng, data, marker };
      
      // If editing existing item, replace it
      if (itemId) {
        const existingIndex = state.items.findIndex(item => item.id === itemId);
        if (existingIndex !== -1) {
          state.items[existingIndex] = item;
        }
      } else {
        state.items.push(item);
        // Add undo action for item creation
        pushUndo({ type: 'create-item', id: item.id });
      }
      
      return marker; 
    }

    // Helper function to update marker popup content
    function updateMarkerPopup(marker, type, latlng, data, id) {
      const colorMap={ 'agent-post':'#2ecc71', 'camera':'#3498db', 'sensor':'#9b59b6', 'alarm':'#e74c3c', 'supervisor':'#f39c12' }; 
      
      let popupContent = `
        <div style="text-align: center;">
          <strong>${type.replace('-', ' ').toUpperCase()}</strong><br>
          <strong>${data.name||''}</strong><br>`;
      
      // Add camera specifications for cameras
      if (type === 'camera') {
        // Prefer linking by cameraId; fallback to proximity match
        let shape = state.shapes.find(s => s.kind === 'cameraSector' && s.cameraId === id);
        if (!shape) {
          shape = state.shapes.find(s => s.kind === 'cameraSector' && 
            Math.abs(s.center[0] - latlng.lat) < 0.001 && 
            Math.abs(s.center[1] - latlng.lng) < 0.001);
        }
        
        if (shape && shape.specs) {
          const resolution = shape.resolution ? shape.resolution.toUpperCase() : 'N/A';
          const envResistance = shape.environmentalResistance ? shape.environmentalResistance.toUpperCase() : 'N/A';
          const rating = shape.specs.rating;
          
          popupContent += `
            <div style="margin: 8px 0; padding: 6px; background: rgba(52, 152, 219, 0.1); border-radius: 4px; font-size: 11px;">
              <div style="color: #3498db; font-weight: bold;"><i class="fas fa-video"></i> ${shape.specs.type} Camera</div>`;
          
          if (rating) {
            popupContent += `
              <div style="margin: 6px 0; padding: 4px; background: ${rating.color}20; border-left: 3px solid ${rating.color}; border-radius: 3px;">
                <div style="color: ${rating.color}; font-weight: bold; font-size: 12px;">
                  🏆 Overall Rating: ${rating.grade} (${rating.percentage}%)
                </div>
              </div>`;
          }
          
          popupContent += `
              <div style="color: #2c3e50;">📏 Range: ${shape.specs.range} | 👁️ FOV: ${shape.specs.fov}</div>
              <div style="color: #2c3e50;">📺 Resolution: ${resolution} | 🛡️ Protection: ${envResistance}</div>
            </div>`;
        } else if (data.camType) {
          const cameraTypeDisplay = data.camType.charAt(0).toUpperCase() + data.camType.slice(1);
          popupContent += `<small style="color: #3498db;"><i class="fas fa-video"></i> ${cameraTypeDisplay} Camera</small><br>`;
        }
        
        if (data.height) {
          popupContent += `<small style="color: #9b59b6;"><i class="fas fa-arrows-alt-v"></i> Height: ${data.height}m</small><br>`;
        }
      }
      
      popupContent += `<small>Lat: ${latlng.lat.toFixed(6)}, Lng: ${latlng.lng.toFixed(6)}</small><br>
          <button onclick="editSecurityElement(${id})" style="margin-top: 5px; padding: 3px 8px; font-size: 12px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">Edit</button>`;
      
      if (type === 'camera') {
        popupContent += `<button onclick="showCameraRatingDetails(${id})" style="margin-top: 5px; margin-left: 3px; padding: 3px 8px; font-size: 12px; background: #9b59b6; color: white; border: none; border-radius: 3px; cursor: pointer;">Rating Details</button>`;
      }
      
      popupContent += `<button onclick="deleteSecurityElement(${id})" style="margin-top: 5px; margin-left: 3px; padding: 3px 8px; font-size: 12px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
        </div>
      `;
      
      marker.setPopupContent(popupContent);
    }

    // Helper function to update camera coverage when camera is moved
    function updateCameraCoverage(cameraId, newPosition) {
      console.log(`Updating camera coverage for camera ${cameraId} to position:`, newPosition);
      
      // First, try to auto-link any nearby unlinked coverage shapes to this camera
      try {
        state.shapes.forEach(s => {
          if (s && s.kind === 'cameraSector' && !s.cameraId && s.center) {
            const dist = map.distance(L.latLng(s.center[0], s.center[1]), newPosition);
            if (dist <= 120) { // within 120m considered same camera
              s.cameraId = cameraId;
              console.log(`Auto-linked coverage shape ${s.id} to camera ${cameraId} (dist ${Math.round(dist)}m)`);
            }
          }
        });
      } catch (e) {
        console.warn('Auto-linking camera shapes skipped:', e);
      }

      // Find all camera-related shapes (there might be multiple)
      const cameraShapes = state.shapes.filter(s => 
        (s.kind === 'cameraSector' || s.kind === 'camera') && 
        (s.cameraId === cameraId || s.id === cameraId)
      );
      
      let updatedAny = false;
      cameraShapes.forEach((shape, index) => {
        const shapeIndex = state.shapes.findIndex(s => s.id === shape.id);
        
        if (shapeIndex !== -1) {
          console.log(`Updating shape ${shape.id} of kind ${shape.kind}`);
          
          // Update the center position
          shape.center = [newPosition.lat, newPosition.lng];
          
          // Remove old coverage from map
          if (shape.polygon) {
            layers.cameras.removeLayer(shape.polygon);
          }
          if (shape.circle) {
            layers.cameras.removeLayer(shape.circle);
          }
          if (shape.sector) {
            layers.cameras.removeLayer(shape.sector);
          }
          
          // Preserve all existing specifications
          const specs = shape.specs || {};
          const options = {
            radius: shape.radius || specs.range || 60,
            angle: shape.angle || specs.fov || 60,
            heading: shape.heading || specs.heading || 0,
            camType: shape.camType || specs.type || 'fixed',
            height: shape.height || specs.height || 3.5,
            resolution: shape.resolution || specs.resolution || '1080p',
            environmentalResistance: shape.environmentalResistance || specs.environmentalResistance || 'ip65',
            powerMode: shape.powerMode || specs.powerMode || 'poe',
            audioOutput: shape.audioOutput || specs.audioOutput || 'none',
            minIllumination: shape.minIllumination || shape.minimumIllumination || specs.minimumIllumination || '0.1',
            zoom: shape.zoom || specs.zoom || 'fixed'
          };
          
          console.log('Recreating coverage with options:', options);
          
          // Recreate coverage with new position
          const newCoverage = addCameraCoverage(newPosition, options, shape.id, cameraId);
          
          // Update the shape reference in state
          if (newCoverage) {
            state.shapes[shapeIndex] = newCoverage;
            console.log(`Successfully updated shape ${shape.id}`);
            updatedAny = true;
          }
        }
      });
      
      // If we didn't find any linked shapes, create a fresh coverage from item data
      if (!updatedAny) {
        const item = state.items.find(it => it.id === cameraId && it.type === 'camera');
        const data = (item && item.data) || {};
        const options = {
          radius: data.radius || 60,
          angle: data.angle || 60,
          heading: data.heading || 0,
          camType: data.camType || 'fixed',
          height: data.height || 3.5,
          resolution: data.resolution || '1080p',
          environmentalResistance: data.environmentalResistance || 'ip65',
          powerMode: data.powerMode || 'poe',
          audioOutput: data.audioOutput || 'none',
          minIllumination: data.minIllumination || data.minimumIllumination || '0.1',
          zoom: data.zoom || 'fixed'
        };
        const newShape = addCameraCoverage(newPosition, options, null, cameraId);
        if (newShape) {
          console.log(`Created new coverage shape ${newShape.id} for camera ${cameraId}`);
          updatedAny = true;
        }
      }

      // Also update any securityElements if they exist
      const securityElement = securityElements.find(el => el.id === cameraId);
      if (securityElement) {
        securityElement.lat = newPosition.lat;
        securityElement.lng = newPosition.lng;
        console.log('Updated securityElements array');
      }
      
      console.log(`Camera coverage update completed for camera ${cameraId}`);
    }

    // Utility: link existing camera sector shapes to nearest camera markers
    function linkExistingCameraShapesToMarkers(maxMeters = 120) {
      if (!map) return;
      const cameras = state.items.filter(it => it.type === 'camera');
      if (cameras.length === 0) return;
      state.shapes.forEach(s => {
        if (s && s.kind === 'cameraSector' && !s.cameraId && s.center) {
          let best = null;
          cameras.forEach(cam => {
            const d = map.distance(L.latLng(s.center[0], s.center[1]), L.latLng(cam.lat, cam.lng));
            if (d <= maxMeters && (!best || d < best.d)) best = { id: cam.id, d };
          });
          if (best) {
            s.cameraId = best.id;
            console.log(`Linked orphan coverage shape ${s.id} to camera ${best.id} (${Math.round(best.d)}m)`);
          }
        }
      });
    }
  function addCameraCoverage(center, options={}, shapeId=null, cameraId=null){ 
      const userRadius=options.radius||60; // Keep for fallback/override if needed
      const angle=options.angle||60; 
      const heading=options.heading||0; 
      const camType=options.camType||'fixed';
      const height=options.height||3.5;
      const resolution=options.resolution||'1080p';
      const environmentalResistance=options.environmentalResistance||'ip65';
      const powerMode=options.powerMode||'poe';
      const audioOutput=options.audioOutput||'none';
      const minIllumination=options.minIllumination||'0.1';
      const zoom=options.zoom||'fixed';
      
      // Industry-standard camera coverage calculations
      // Calculate radius based on height, angle, camera type, and zoom
      const effectiveRadius = calculateEffectiveRadius(userRadius, height, camType, zoom, angle);
      const effectiveAngle = calculateEffectiveAngle(angle, camType);
      
      // Calculate comprehensive camera rating
      const cameraRating = calculateCameraRating(camType, height, resolution, environmentalResistance, powerMode, audioOutput, minIllumination, zoom, effectiveRadius, effectiveAngle);
      
      const coveragePattern = calculateCoveragePattern(center, effectiveRadius, effectiveAngle, heading, height, camType, resolution, minIllumination, cameraRating);
      
      const poly=L.polygon(coveragePattern.points,{ 
        color: coveragePattern.color, 
        weight: coveragePattern.weight, 
        fillColor: coveragePattern.fillColor, 
        fillOpacity: coveragePattern.fillOpacity,
        dashArray: coveragePattern.dashArray
      }); 
      poly.addTo(layers.cameras); 
      
      const id = shapeId || state.nextId++;
      const shape = { 
        id, 
        kind:'cameraSector', 
        center, 
        radius: effectiveRadius, 
        angle: effectiveAngle, 
        heading, 
        camType, 
        height, 
        resolution,
        environmentalResistance,
        powerMode,
        audioOutput,
        minIllumination,
        zoom,
        cameraId: cameraId || null,
        polygon: poly,
        specs: coveragePattern.specs
      };
      
      if (shapeId) {
        const existingIndex = state.shapes.findIndex(s => s.id === shapeId);
        if (existingIndex !== -1) {
          state.shapes[existingIndex] = shape;
        } else {
          // If shape ID not found, add as new shape (fallback)
          state.shapes.push(shape);
        }
      } else {
        state.shapes.push(shape);
      }
      
      return shape; 
    }

    // Industry-standard camera coverage calculation functions
    function calculateEffectiveRadius(baseRadius, height, camType, zoom = 'fixed', angle = 60) {
      // Calculate effective radius based on height and angle using trigonometry
      // For security cameras, the effective range is typically limited by:
      // 1. Height-based line of sight calculation
      // 2. Camera type capabilities
      // 3. Angle of coverage (wider angle = shorter effective range for detail recognition)
      
      // Base calculation: Use height and angle to determine theoretical maximum range
      // For person identification: typically need 4-6 pixels per cm of target
      // Standard formula: Range = Height / tan(vertical_angle/2) for optimal coverage
      
      // Calculate theoretical range based on height and angle
      const angleInRadians = (angle * Math.PI) / 180;
      const theoreticalRange = height / Math.tan(angleInRadians / 2);
      
      // Apply camera type multipliers
      let multiplier = 1.0;
      switch(camType) {
        case 'ptz':
          // PTZ cameras can have variable zoom, use maximum effective range
          multiplier = 1.8; // Up to 80% more range with zoom
          break;
        case 'thermal':
          // Thermal cameras have extended detection range
          multiplier = 2.2; // Thermal detection beyond visible range
          break;
        case '360':
          // 360° cameras trade range for coverage
          multiplier = 0.7; // Reduced range due to wide coverage
          break;
        case 'dome':
          // Dome cameras standard range with slight reduction for housing
          multiplier = 0.95;
          break;
        case 'bullet':
          // Bullet cameras optimized for distance
          multiplier = 1.2; // Better focused range
          break;
        case 'fixed':
        default:
          multiplier = 1.0;
          break;
      }
      
      // Zoom capability multiplier
      const zoomMultiplier = {
        'fixed': 1.0,
        '3x': 1.3,
        '5x': 1.5,
        '10x': 2.0,
        '20x': 2.5,
        '30x': 3.0,
        'digital': 1.1  // Digital zoom has limited range benefit
      }[zoom] || 1.0;
      
      // Apply atmospheric and environmental factors (professional standard)
      const environmentalFactor = 0.85; // Account for weather, lighting conditions
      
      // Calculate final effective radius
      const calculatedRadius = theoreticalRange * multiplier * zoomMultiplier * environmentalFactor;
      
      // Ensure minimum practical range and maximum reasonable range
      const minRange = height * 2; // Minimum: twice the height
      const maxRange = height * 50; // Maximum: 50 times the height (very high-end cameras)
      
      return Math.round(Math.max(minRange, Math.min(maxRange, calculatedRadius)));
    }

    function calculateEffectiveAngle(baseAngle, camType) {
      // Industry-standard field of view by camera type
      const standardAngles = {
        'fixed': baseAngle,
        'ptz': Math.min(baseAngle, 60), // PTZ narrow field when zoomed
        'dome': Math.min(baseAngle + 10, 120), // Dome cameras wider view
        'bullet': Math.min(baseAngle, 45), // Bullet cameras focused view
        'thermal': Math.min(baseAngle - 5, 40), // Thermal slightly narrower
        '360': 360 // Full panoramic
      };
      
      return standardAngles[camType] || baseAngle;
    }

    function calculateCoveragePattern(center, radius, angle, heading, height, camType, resolution = '1080p', minIllumination = '0.1', cameraRating = null) {
      const points = [center];
      let steps = 10;
      let color = '#3498db';
      let weight = 1;
      let fillColor = '#3498db';
      let fillOpacity = 0.2;
      let dashArray = null;
      
      // Resolution-based quality enhancement
      const resolutionMultiplier = {
        '720p': 0.8,
        '1080p': 1.0,
        '4k': 1.3,
        '8k': 1.5
      }[resolution] || 1.0;
      
      // Apply resolution enhancement to visualization
      fillOpacity *= (0.8 + resolutionMultiplier * 0.2); // Higher resolution = more visible coverage
      
      // Camera-specific visualization
      switch(camType) {
        case 'ptz':
          color = '#e67e22'; // Orange for PTZ
          fillColor = '#e67e22';
          fillOpacity = 0.25;
          steps = 15; // Smoother arc for PTZ
          break;
        case 'thermal':
          color = '#e74c3c'; // Red for thermal
          fillColor = '#e74c3c';
          fillOpacity = 0.3;
          dashArray = '5,5'; // Dashed line for thermal
          break;
        case '360':
          // Full circle for 360° cameras
          const circlePoints = [];
          for(let i = 0; i <= 36; i++) {
            const a = (i * 10) * Math.PI/180;
            const dx = radius * Math.cos(a) / 111320;
            const dy = radius * Math.sin(a) / 110574;
            circlePoints.push([center[0] + dy, center[1] + dx]);
          }
          return {
            points: circlePoints,
            color: '#9b59b6',
            weight: 2,
            fillColor: '#9b59b6',
            fillOpacity: 0.15,
            dashArray: null,
            specs: { type: '360°', coverage: 'Full panoramic', range: radius }
          };
        case 'dome':
          color = '#2ecc71'; // Green for dome
          fillColor = '#2ecc71';
          fillOpacity = 0.2;
          break;
        case 'bullet':
          color = '#f39c12'; // Yellow for bullet
          fillColor = '#f39c12';
          fillOpacity = 0.25;
          weight = 2; // Thicker line for focused beam
          break;
        default:
          // Standard fixed camera
          break;
      }
      
      // Calculate coverage sector points
      if (camType !== '360') {
        const start = heading - angle/2;
        const end = heading + angle/2;
        
        for(let i = 0; i <= steps; i++) {
          const a = (start + (end - start) * i / steps) * Math.PI/180;
          const dx = radius * Math.cos(a) / 111320;
          const dy = radius * Math.sin(a) / 110574;
          points.push([center[0] + dy, center[1] + dx]);
        }
      }
      
      // Calculate coverage specifications
      const coverageArea = camType === '360' 
        ? Math.PI * Math.pow(radius, 2) 
        : (angle / 360) * Math.PI * Math.pow(radius, 2);
      
      const specs = {
        type: camType.toUpperCase(),
        range: `${radius}m`,
        fov: camType === '360' ? '360°' : `${angle}°`,
        height: `${height}m`,
        resolution: resolution.toUpperCase(),
        coverage: `${Math.round(coverageArea)}m²`,
        quality: calculateImageQuality(radius, height, camType, resolution, minIllumination),
        rating: cameraRating
      };
      
      return {
        points,
        color,
        weight,
        fillColor,
        fillOpacity,
        dashArray,
        specs
      };
    }

    function calculateImageQuality(range, height, camType, resolution = '1080p', minIllumination = '0.1') {
      // Industry standard: image quality degradation over distance
      const baseQuality = {
        'thermal': 85, // Thermal maintains quality over distance
        'ptz': 90,     // PTZ can zoom for quality
        'bullet': 80,  // Bullet optimized for distance
        'dome': 75,    // Dome trades quality for coverage
        '360': 60,     // 360° trades quality for panoramic view
        'fixed': 70    // Standard fixed camera
      };
      
      const base = baseQuality[camType] || 70;
      
      // Resolution quality multiplier
      const resolutionBonus = {
        '720p': -5,    // 5% penalty for lower resolution
        '1080p': 0,    // Baseline
        '4k': 10,      // 10% bonus for 4K
        '8k': 15       // 15% bonus for 8K
      }[resolution] || 0;
      
      // Low light performance bonus
      const lowLightBonus = {
        'infrared': 20,  // IR night vision major bonus
        '0.01': 15,      // Starlight capability
        '0.1': 5,        // Good low light
        '1': 0,          // Standard
        '10': -3,        // Poor low light
        '50': -8         // Daylight only
      }[minIllumination] || 0;
      
      // Quality reduction: 1% per 10m distance, 2% per meter above optimal height (4m)
      const distanceReduction = (range / 10) * 1;
      const heightReduction = height > 4 ? (height - 4) * 2 : 0;
      
      const finalQuality = Math.max(20, base + resolutionBonus + lowLightBonus - distanceReduction - heightReduction);
      
      if (finalQuality >= 80) return 'Excellent';
      if (finalQuality >= 65) return 'Good';
      if (finalQuality >= 50) return 'Fair';
      return 'Poor';
    }

    function calculateCameraRating(camType, height, resolution, environmentalResistance, powerMode, audioOutput, minIllumination, zoom, radius, angle) {
      let totalScore = 0;
      let maxScore = 0;
      const ratings = {};

      // 1. Camera Type Performance (20 points)
      const cameraTypeScores = {
        'thermal': 20,  // Highest performance - all weather, day/night
        'ptz': 18,      // High performance - versatile zoom and pan
        'bullet': 16,   // Good performance - focused long range
        'dome': 14,     // Standard performance - wide coverage
        'fixed': 12,    // Basic performance - standard fixed view
        '360': 10       // Lower individual quality but full coverage
      };
      const typeScore = cameraTypeScores[camType] || 12;
      totalScore += typeScore;
      maxScore += 20;
      ratings.cameraType = { score: typeScore, max: 20, rating: (typeScore/20*100).toFixed(0) + '%' };

      // 2. Resolution Quality (18 points)
      const resolutionScores = {
        '8k': 18,      // Ultra-professional
        '4k': 16,      // Professional
        '1080p': 14,   // Standard HD
        '720p': 10     // Basic HD
      };
      const resScore = resolutionScores[resolution] || 14;
      totalScore += resScore;
      maxScore += 18;
      ratings.resolution = { score: resScore, max: 18, rating: (resScore/18*100).toFixed(0) + '%' };

      // 3. Low Light Performance (16 points)
      const illuminationScores = {
        'infrared': 16,  // Perfect night vision
        '0.01': 15,      // Excellent starlight
        '0.1': 12,       // Good low light
        '1': 10,         // Moderate low light
        '10': 6,         // Poor low light
        '50': 3          // Daylight only
      };
      const lightScore = illuminationScores[minIllumination] || 12;
      totalScore += lightScore;
      maxScore += 16;
      ratings.lowLight = { score: lightScore, max: 16, rating: (lightScore/16*100).toFixed(0) + '%' };

      // 4. Zoom Capability (14 points)
      const zoomScores = {
        '30x': 14,      // Professional surveillance
        '20x': 12,      // High zoom
        '10x': 10,      // Good zoom
        '5x': 8,        // Moderate zoom
        '3x': 6,        // Basic zoom
        'digital': 4,   // Digital only
        'fixed': 2      // No zoom
      };
      const zoomScore = zoomScores[zoom] || 2;
      totalScore += zoomScore;
      maxScore += 14;
      ratings.zoom = { score: zoomScore, max: 14, rating: (zoomScore/14*100).toFixed(0) + '%' };

      // 5. Environmental Protection (12 points)
      const protectionScores = {
        'military': 12,  // Extreme conditions
        'ik10': 11,      // Vandal resistant
        'ip67': 10,      // Waterproof
        'ip66': 9,       // Heavy weather proof
        'ip65': 7,       // Weather resistant
        'ip54': 4        // Basic protection
      };
      const protectionScore = protectionScores[environmentalResistance] || 7;
      totalScore += protectionScore;
      maxScore += 12;
      ratings.protection = { score: protectionScore, max: 12, rating: (protectionScore/12*100).toFixed(0) + '%' };

      // 6. Power Efficiency (10 points)
      const powerScores = {
        'solar': 10,     // Self-sustaining
        'hybrid': 9,     // Battery + solar backup
        'battery': 7,    // Portable but limited
        'poe_plus': 8,   // High power over ethernet
        'poe': 9,        // Standard efficient power
        'ac': 6          // Requires mains power
      };
      const powerScore = powerScores[powerMode] || 9;
      totalScore += powerScore;
      maxScore += 10;
      ratings.power = { score: powerScore, max: 10, rating: (powerScore/10*100).toFixed(0) + '%' };

      // 7. Audio Capabilities (8 points)
      const audioScores = {
        'noise_reduction': 8,  // Professional audio
        'high_quality': 7,     // High quality recording
        'bidirectional': 6,    // Two-way communication
        'basic': 4,            // Basic recording
        'none': 0              // No audio
      };
      const audioScore = audioScores[audioOutput] || 0;
      totalScore += audioScore;
      maxScore += 8;
      ratings.audio = { score: audioScore, max: 8, rating: audioScore > 0 ? (audioScore/8*100).toFixed(0) + '%' : 'N/A' };

      // 8. Installation Quality (6 points)
      let installScore = 3; // Base score
      if (height >= 3 && height <= 4) installScore += 2; // Optimal height
      else if (height >= 2.5 && height <= 6) installScore += 1; // Good height
      if (radius >= 50 && radius <= 150) installScore += 1; // Reasonable range
      installScore = Math.min(installScore, 6);
      totalScore += installScore;
      maxScore += 6;
      ratings.installation = { score: installScore, max: 6, rating: (installScore/6*100).toFixed(0) + '%' };

      // 9. Coverage Efficiency (6 points)
      let coverageScore = 2; // Base score
      if (camType === '360') coverageScore += 4; // Full coverage bonus
      else if (angle >= 60 && angle <= 90) coverageScore += 3; // Good angle
      else if (angle >= 45) coverageScore += 2; // Moderate angle
      else coverageScore += 1; // Narrow but focused
      coverageScore = Math.min(coverageScore, 6);
      totalScore += coverageScore;
      maxScore += 6;
      ratings.coverage = { score: coverageScore, max: 6, rating: (coverageScore/6*100).toFixed(0) + '%' };

      // Calculate overall rating
      const overallPercentage = (totalScore / maxScore) * 100;
      let overallGrade, overallDescription, ratingColor;

      if (overallPercentage >= 90) {
        overallGrade = 'A+';
        overallDescription = 'Professional Grade';
        ratingColor = '#27ae60';
      } else if (overallPercentage >= 85) {
        overallGrade = 'A';
        overallDescription = 'Excellent Performance';
        ratingColor = '#2ecc71';
      } else if (overallPercentage >= 80) {
        overallGrade = 'A-';
        overallDescription = 'Very Good';
        ratingColor = '#f1c40f';
      } else if (overallPercentage >= 75) {
        overallGrade = 'B+';
        overallDescription = 'Good Performance';
        ratingColor = '#f39c12';
      } else if (overallPercentage >= 70) {
        overallGrade = 'B';
        overallDescription = 'Above Average';
        ratingColor = '#e67e22';
      } else if (overallPercentage >= 65) {
        overallGrade = 'B-';
        overallDescription = 'Average';
        ratingColor = '#d35400';
      } else if (overallPercentage >= 60) {
        overallGrade = 'C+';
        overallDescription = 'Below Average';
        ratingColor = '#e74c3c';
      } else if (overallPercentage >= 50) {
        overallGrade = 'C';
        overallDescription = 'Basic Performance';
        ratingColor = '#c0392b';
      } else {
        overallGrade = 'D';
        overallDescription = 'Poor Performance';
        ratingColor = '#8e44ad';
      }

      return {
        totalScore,
        maxScore,
        percentage: overallPercentage.toFixed(1),
        grade: overallGrade,
        description: overallDescription,
        color: ratingColor,
        categoryRatings: ratings,
        recommendations: generateCameraRecommendations(ratings, camType, overallPercentage)
      };
    }

    function generateCameraRecommendations(ratings, camType, overallPercentage) {
      const recommendations = [];

      if (ratings.resolution.score < 14) {
        recommendations.push('💡 Consider upgrading to 4K resolution for better image detail');
      }
      if (ratings.lowLight.score < 12) {
        recommendations.push('🌙 Improve low-light performance with IR or starlight capability');
      }
      if (ratings.zoom.score < 6 && camType !== '360') {
        recommendations.push('🔍 Add optical zoom for better target identification');
      }
      if (ratings.protection.score < 9) {
        recommendations.push('🛡️ Upgrade environmental protection for outdoor reliability');
      }
      if (ratings.audio.score === 0) {
        recommendations.push('🔊 Consider audio recording for enhanced security monitoring');
      }
      if (ratings.power.score < 8) {
        recommendations.push('⚡ Optimize power solution for better efficiency');
      }

      if (overallPercentage >= 85) {
        recommendations.unshift('✅ Excellent camera setup - professional grade performance');
      } else if (overallPercentage >= 75) {
        recommendations.unshift('👍 Good camera configuration with room for enhancement');
      } else if (overallPercentage < 65) {
        recommendations.unshift('⚠️ Consider significant upgrades for professional security');
      }

      return recommendations;
    }

    // Function to show detailed camera rating information
    window.showCameraRatingDetails = function(cameraId) {
      // Try to find camera in securityElements first, then in state.items
      let camera = securityElements.find(el => el.id === cameraId && el.type === 'camera');
      if (!camera) {
        camera = state.items.find(item => item.id === cameraId && item.type === 'camera');
      }
      if (!camera) {
        console.error('Camera not found:', cameraId);
        return;
      }
      
      const rating = calculateCameraRating(camera.specs || camera);
      const recommendations = generateCameraRecommendations(camera.specs || camera);
      
      // Get specs object - handle different data structures
      const specs = camera.specs || camera;
      
      const detailsHtml = `
        <div class="rating-details">
          <div class="rating-header">
            <h2 style="margin: 0 0 10px 0; color: #2c3e50;">📹 Camera Performance Analysis</h2>
            <div class="overall-rating" style="background: ${rating.color}; color: white; padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 20px;">
              <div style="font-size: 32px; font-weight: bold; margin-bottom: 5px;">${rating.grade}</div>
              <div style="font-size: 18px;">${rating.percentage}% Performance Score</div>
              <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">${rating.classification}</div>
            </div>
          </div>
          
          <div class="rating-breakdown">
            <h3 style="color: #2c3e50; margin-bottom: 15px;">📊 Performance Breakdown</h3>
            ${rating.breakdown.map(category => `
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 5px;">
                <span style="font-weight: 500;">${category.category}</span>
                <div style="display: flex; align-items: center;">
                  <div style="width: 100px; height: 8px; background: #e9ecef; border-radius: 4px; margin-right: 10px;">
                    <div style="width: ${(category.score / category.maxScore) * 100}%; height: 100%; background: ${category.score >= category.maxScore * 0.8 ? '#28a745' : category.score >= category.maxScore * 0.6 ? '#ffc107' : '#dc3545'}; border-radius: 4px;"></div>
                  </div>
                  <span style="font-weight: bold; min-width: 60px; text-align: right;">${category.score}/${category.maxScore} pts</span>
                </div>
              </div>
            `).join('')}
          </div>
          
          <div class="recommendations" style="margin-top: 20px;">
            <h3 style="color: #2c3e50; margin-bottom: 15px;">💡 Performance Recommendations</h3>
            ${recommendations.length > 0 ? 
              recommendations.map(rec => `
                <div style="padding: 10px; background: #e8f4f9; border-left: 4px solid #3498db; margin-bottom: 8px; border-radius: 0 5px 5px 0;">
                  <div style="font-weight: 500; color: #2c3e50;">${rec.category}</div>
                  <div style="color: #34495e; margin-top: 3px;">${rec.recommendation}</div>
                </div>
              `).join('') : 
              '<div style="padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; color: #155724; text-align: center;">🎉 Excellent! No improvements needed.</div>'
            }
          </div>
          
          <div class="specifications" style="margin-top: 20px;">
            <h3 style="color: #2c3e50; margin-bottom: 15px;">🔧 Camera Specifications</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Type:</strong> ${specs.cameraType || 'Standard'}
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Resolution:</strong> ${specs.resolution || 'Standard'} pixels
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Environmental:</strong> ${specs.environmentalResistance || 'Standard'}
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Power Mode:</strong> ${specs.powerMode || 'Standard'}
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Audio Output:</strong> ${specs.audioOutput || 'Standard'}
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Min Illumination:</strong> ${specs.minimumIllumination || 'Standard'} lux
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Zoom:</strong> ${specs.zoom || 'Standard'}x
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                <strong>Coverage:</strong> ${specs.range || 10}m range
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Create modal for rating details
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.7); z-index: 10000; display: flex; 
        align-items: center; justify-content: center; padding: 20px;
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: white; border-radius: 12px; padding: 30px; 
        max-width: 800px; max-height: 90vh; overflow-y: auto; 
        box-shadow: 0 10px 30px rgba(0,0,0,0.3); position: relative;
      `;
      
      content.innerHTML = detailsHtml + `
        <div style="text-align: center; margin-top: 25px;">
          <button onclick="this.closest('.rating-modal').remove()" 
                  style="padding: 10px 20px; background: #3498db; color: white; 
                  border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
            Close Details
          </button>
        </div>
      `;
      
      modal.className = 'rating-modal';
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }

    // Fence Drawing Functions
    function toggleFenceDrawing() {
      if (isDrawingFence) {
        stopFenceDrawing();
      } else {
        startFenceDrawing();
      }
    }

    function startFenceDrawing() {
      isDrawingFence = true;
      currentFencePoints = [];
      
      // Change button appearance
      const btn = document.getElementById('btnDrawFence');
      if (btn) {
        btn.style.background = '#e74c3c';
        btn.title = 'Stop Drawing Fence (Click to finish)';
      }
      
      // Change cursor
      document.getElementById('securityMap').style.cursor = 'crosshair';
      
      // We don't remove the existing click handler, we'll check for fence drawing mode in the existing handler
      
      // Add escape key to cancel
      document.addEventListener('keydown', onFenceKeyPress);
      
      alert('Click on the map to draw fence points. Press ESC or click the fence button again to finish.');
    }

    function stopFenceDrawing() {
      isDrawingFence = false;
      
      // Reset button appearance
      const btn = document.getElementById('btnDrawFence');
      if (btn) {
        btn.style.background = '';
        btn.title = 'Draw Fence';
      }
      
      // Reset cursor
      document.getElementById('securityMap').style.cursor = '';
      document.removeEventListener('keydown', onFenceKeyPress);
      
      // Finish current fence if we have points
      if (currentFencePoints.length > 1) {
        finishFence();
      } else if (currentFencePolyline) {
        // Remove incomplete fence
        layers.fences.removeLayer(currentFencePolyline);
      }
      
      // Reset drawing variables
      currentFencePoints = [];
      currentFencePolyline = null;
    }

    function onFenceClick(e) {
      const point = [e.latlng.lat, e.latlng.lng];
      currentFencePoints.push(point);
      
      if (currentFencePoints.length === 1) {
        // Create the polyline for the first point
        currentFencePolyline = L.polyline(currentFencePoints, {
          color: '#8e44ad',
          weight: 3,
          opacity: 0.7,
          dashArray: '5, 10'
        }).addTo(layers.fences);
      } else {
        // Update the polyline with new points
        currentFencePolyline.setLatLngs(currentFencePoints);
      }
    }

    function onFenceKeyPress(e) {
      if (e.key === 'Escape') {
        stopFenceDrawing();
      }
    }

    function finishFence() {
      if (currentFencePoints.length < 2) return;
      
      // Create permanent fence
      const fence = {
        id: state.nextId++,
        type: 'fence',
        points: currentFencePoints,
        name: `Fence ${state.fences.length + 1}`,
        created: new Date().toISOString()
      };
      
      // Add to state
      state.fences.push(fence);
      
      // Remove temporary polyline
      if (currentFencePolyline) {
        layers.fences.removeLayer(currentFencePolyline);
      }
      
      // Create permanent polyline with popup
      const polyline = L.polyline(currentFencePoints, {
        color: '#8e44ad',
        weight: 4,
        opacity: 0.8
      }).addTo(layers.fences);
      
      // Add popup with fence info and coverage analysis
      const popupContent = `
        <div style="min-width: 200px;">
          <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🏗️ ${fence.name}</h4>
          <div style="margin-bottom: 8px;"><strong>Length:</strong> ${calculateFenceLength(fence.points).toFixed(1)}m</div>
          <div style="margin-bottom: 8px;"><strong>Points:</strong> ${fence.points.length}</div>
          <div style="margin-bottom: 10px;"><strong>Created:</strong> ${new Date(fence.created).toLocaleDateString()}</div>
          <button onclick="analyzeFenceCoverage(${fence.id})" 
                  style="padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">
            Analyze Coverage
          </button>
          <button onclick="deleteFence(${fence.id})" 
                  style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">
            Delete
          </button>
        </div>
      `;
      
  polyline.bindPopup(popupContent);
  attachPlacementAwareClick(polyline);
      fence.polyline = polyline;

      // Add undo action for fence creation
      pushUndo({ type:'create-fence', id: fence.id });
    }

    // Area Selection Drawing Functions
    function toggleAreaDrawing() {
      if (isDrawingArea) {
        stopAreaDrawing();
      } else {
        startAreaDrawing();
      }
    }

    function startAreaDrawing() {
      isDrawingArea = true;
      currentAreaPoints = [];
      const btn = document.getElementById('btnDrawArea');
      if (btn) {
        btn.style.background = '#e67e22';
        btn.title = 'Stop Drawing Area (Click to finish)';
      }
      document.getElementById('securityMap').style.cursor = 'crosshair';
      document.addEventListener('keydown', onAreaKeyPress);
      alert('Click on the map to draw an analysis area (polygon). Press ESC or click the button again to finish.');
    }

    function stopAreaDrawing() {
      isDrawingArea = false;
      const btn = document.getElementById('btnDrawArea');
      if (btn) {
        btn.style.background = '';
        btn.title = 'Draw Analysis Area';
      }
      document.getElementById('securityMap').style.cursor = '';
      document.removeEventListener('keydown', onAreaKeyPress);
      if (currentAreaPoints.length >= 3) {
        finishArea();
      } else if (currentAreaPolygon) {
        layers.selections.removeLayer(currentAreaPolygon);
        currentAreaPoints = [];
        currentAreaPolygon = null;
      }
      // Note: finishArea() now handles resetting currentAreaPoints and currentAreaPolygon
    }

    function onAreaClick(e) {
      const point = [e.latlng.lat, e.latlng.lng];
      currentAreaPoints.push(point);
      if (currentAreaPoints.length === 1) {
        currentAreaPolygon = L.polygon(currentAreaPoints, {
          color: '#e67e22', weight: 2, opacity: 0.9, fillOpacity: 0.15, dashArray: '5,8'
        }).addTo(layers.selections);
      } else {
        currentAreaPolygon.setLatLngs([currentAreaPoints]);
      }
    }

    function onAreaKeyPress(e) {
      if (e.key === 'Escape') {
        stopAreaDrawing();
      }
    }

    function finishArea() {
      if (currentAreaPoints.length < 3) return;
      
      // Prompt for area name before creating
      const name = prompt('Enter area name:', `Analysis Area ${state.selections.length + 1}`);
      if (!name || !name.trim()) return; // User cancelled or entered empty name
      
      const area = {
        id: state.nextId++,
        type: 'selection',
        points: [...currentAreaPoints], // Create a copy of the points array
        name: name.trim(),
        created: new Date().toISOString()
      };
      state.selections.push(area);
      console.log(`Area created: ${area.name}, Total areas: ${state.selections.length}`, area);
      if (currentAreaPolygon) layers.selections.removeLayer(currentAreaPolygon);
  const polygon = L.polygon(area.points, { color: '#e67e22', weight: 3, opacity: 0.9, fillOpacity: 0.12 }).addTo(layers.selections);
      const popupContent = buildAreaPopupContent(area);
  polygon.bindPopup(popupContent);
  attachAreaTooltip(area);
  attachPlacementAwareClick(polygon);
      area.polygon = polygon;
      // Add undo action for area creation
      pushUndo({ type:'create-area', id: area.id });
      
      // Reset drawing state for next area
      currentAreaPoints = [];
      currentAreaPolygon = null;
    }

    function buildAreaPopupContent(area){
      const created = new Date(area.created).toLocaleDateString();
      return `
        <div style="min-width: 240px;">
          <h4 style="margin: 0 0 8px 0; color: #e67e22;">📐 ${area.name}</h4>
          <div style="margin-bottom: 6px; font-size:12px; color:#555;"><strong>Points:</strong> ${area.points.length}</div>
          <div style="margin-bottom: 10px; font-size:12px; color:#555;"><strong>Created:</strong> ${created}</div>
          <div style="display:flex; gap:6px;">
            <button onclick="analyzeAreaCoverage(${area.id})" title="Analyze Coverage" 
                    style="padding: 5px 8px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Analyze
            </button>
            <button onclick="editArea(${area.id})" title="Edit Area"
                    style="padding: 5px 8px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Edit
            </button>
            <button onclick="deleteArea(${area.id})" title="Delete Area"
                    style="padding: 5px 8px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Delete
            </button>
          </div>
        </div>`;
    }

    window.editArea = function(areaId){
      const area = state.selections.find(a => a.id === areaId);
      if (!area) return;
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;z-index:10000;';
      const card = document.createElement('div');
      card.style.cssText = 'background:#fff;border-radius:10px;min-width:340px;max-width:90vw;padding:16px 18px;box-shadow:0 10px 28px rgba(0,0,0,.25);font-family:Inter,system-ui,-apple-system,sans-serif;';
      card.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
          <div style="font-weight:700;color:#2c3e50;">Edit Area</div>
          <button id="eaClose" class="icon-btn" title="Close" style="background:none;border:none;color:#666;cursor:pointer;font-size:18px;"><i class="fas fa-times"></i></button>
        </div>
        <div style="display:grid;gap:8px;">
          <label style="font-size:12px;color:#2c3e50;">Name</label>
          <input id="eaName" type="text" value="${area.name || ''}" style="padding:8px 10px;border:1px solid #dcdfe6;border-radius:6px;outline:none;" />
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
          <button id="eaSave" style="padding:6px 10px;background:#3498db;color:#fff;border:none;border-radius:6px;cursor:pointer;">Save</button>
          <button id="eaCancel" style="padding:6px 10px;background:#95a5a6;color:#fff;border:none;border-radius:6px;cursor:pointer;">Cancel</button>
        </div>`;
      overlay.appendChild(card);
      document.body.appendChild(overlay);
      const close = ()=>{ try{ document.body.removeChild(overlay); }catch(_){} };
      card.querySelector('#eaClose').onclick = close;
      card.querySelector('#eaCancel').onclick = close;
      card.querySelector('#eaSave').onclick = ()=>{
        const name = (card.querySelector('#eaName').value || '').trim();
        if (!name) { alert('Name is required'); return; }
        area.name = name;
        // Refresh popup and tooltip content
        if (area.polygon) {
          const html = buildAreaPopupContent(area);
          area.polygon.bindPopup(html);
          area.polygon.unbindTooltip();
          attachAreaTooltip(area);
        }
        close();
      };
      overlay.addEventListener('click',(e)=>{ if(e.target===overlay) close(); });
    }

    function attachAreaTooltip(area){
      if (!area || !area.polygon) return;
      try {
        area.polygon.bindTooltip(area.name || `Area ${area.id}`, { direction: 'center', opacity: 0.9, sticky: true });
        area.polygon.on('click', ()=>{ try{ if (typeof placingMode==='boolean' && placingMode) return; area.polygon.openTooltip(); }catch(_){} });
      } catch (_) {}
    }

      // Normalize Firebase indexed objects back into arrays
      function normalizeIndexedArray(value){
        if (Array.isArray(value)) return value;
        if (value && typeof value === 'object'){
          const keys = Object.keys(value).filter(k => /^\d+$/.test(k)).sort((a,b)=> parseInt(a,10)-parseInt(b,10));
          if (!keys.length) return value;
          return keys.map(k => normalizeIndexedArray(value[k]));
        }
        return value;
      }
      function normalizeLatLngTuple(t){
        // Array form [lat, lng]
        if (Array.isArray(t)) {
          const lat = parseFloat(t[0]);
          const lng = parseFloat(t[1]);
          return [lat, lng];
        }
        // Object form {lat, lng}
        if (t && typeof t === 'object'){
          if (typeof t.lat !== 'undefined' && typeof t.lng !== 'undefined'){
            const lat = parseFloat(t.lat);
            const lng = parseFloat(t.lng);
            return [lat, lng];
          }
          // Indexed object form {"0": lat, "1": lng}
          const keys = Object.keys(t).filter(k => /^\d+$/.test(k)).sort((a,b)=> parseInt(a,10)-parseInt(b,10));
          if (keys.length >= 2){
            const lat = parseFloat(t[keys[0]]);
            const lng = parseFloat(t[keys[1]]);
            return [lat, lng];
          }
        }
        return t;
      }
      function normalizeLatLngPoints(points){
        const arr = normalizeIndexedArray(points);
        const out = [];
        (arr||[]).forEach(p => {
          const pair = normalizeLatLngTuple(p);
          if (Array.isArray(pair)){
            const lat = parseFloat(pair[0]);
            const lng = parseFloat(pair[1]);
            if (!Number.isNaN(lat) && !Number.isNaN(lng)) out.push([lat, lng]);
          }
        });
        return out;
      }

    function calculateFenceLength(points) {
      let length = 0;
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = L.latLng(points[i][0], points[i][1]);
        const p2 = L.latLng(points[i + 1][0], points[i + 1][1]);
        length += p1.distanceTo(p2);
      }
      return length;
    }

    // Fence Coverage Analysis Functions
    window.analyzeFenceCoverage = function(fenceId) {
      const fence = state.fences.find(f => f.id === fenceId);
      if (!fence) return;
      
      const cameras = getAllCameras();
      const lengthCoverage = calculateFenceCoverage(fence, cameras);

      // Attempt area-based coverage if the fence defines a polygon (>= 3 points)
      let areaCoverage = null;
      try {
        areaCoverage = calculateFenceAreaCoverage(fence);
      } catch (e) {
        console.warn('Area coverage calculation skipped:', e);
      }
      
      showFenceCoverageAnalysis(fence, lengthCoverage, areaCoverage);
    };

    window.deleteFence = function(fenceId) {
      if (!confirm('Are you sure you want to delete this fence?')) return;
      
      const fenceIndex = state.fences.findIndex(f => f.id === fenceId);
      if (fenceIndex === -1) return;
      
      const fence = state.fences[fenceIndex];
      // Add undo action for fence deletion with full data snapshot
      pushUndo({ type:'delete-fence', fence: JSON.parse(JSON.stringify(fence)) });
      
      // Remove from map
      if (fence.polyline) {
        layers.fences.removeLayer(fence.polyline);
      }
      
      // Remove from state
      state.fences.splice(fenceIndex, 1);
    };

    // Area coverage analysis using same surface logic
    window.analyzeAreaCoverage = function(areaId) {
      const area = state.selections.find(a => a.id === areaId);
      if (!area) return;
      const pseudoFence = { points: area.points, name: area.name };
      let areaCoverage = null;
      try { areaCoverage = calculateFenceAreaCoverage(pseudoFence); } catch(e){ console.warn('Area coverage calc skipped:', e); }
      // Filter cameras to only those whose coverage intersects this area
      const coveringIds = getCameraIdsCoveringArea(area.points);
      const coveringCameras = getCameraItemsByIds(coveringIds);
      const lengthStats = calculateFenceCoverage(pseudoFence, coveringCameras);
      // Ensure displayed camera count matches filtered set
      lengthStats.cameras = coveringCameras.length;
      showFenceCoverageAnalysis(pseudoFence, lengthStats, areaCoverage);
    };

    window.deleteArea = function(areaId) {
      if (!confirm('Are you sure you want to delete this analysis area?')) return;
      const idx = state.selections.findIndex(a => a.id === areaId);
      if (idx === -1) return;
      const area = state.selections[idx];
      // Add undo action for area deletion with full data snapshot
      pushUndo({ type:'delete-area', area: JSON.parse(JSON.stringify(area)) });
      if (area.polygon) layers.selections.removeLayer(area.polygon);
      state.selections.splice(idx, 1);
    };

    function getAllCameras() {
      // Get cameras from both possible locations
      const cameras = [];
      
      // From state.items
      if (state.items) {
        cameras.push(...state.items.filter(item => item.type === 'camera'));
      }
      
      // From securityElements (if different)
      if (securityElements && securityElements !== state.items) {
        cameras.push(...securityElements.filter(item => item.type === 'camera'));
      }
      
      return cameras;
    }

    function calculateFenceCoverage(fence, cameras) {
      if (!fence.points || fence.points.length < 2) return { percentage: 0, coveredLength: 0, totalLength: 0, gaps: [] };
      
      const fenceSegments = [];
      let totalLength = 0;
      
      // Create fence segments
      for (let i = 0; i < fence.points.length - 1; i++) {
        const start = L.latLng(fence.points[i][0], fence.points[i][1]);
        const end = L.latLng(fence.points[i + 1][0], fence.points[i + 1][1]);
        const segmentLength = start.distanceTo(end);
        
        fenceSegments.push({
          start: start,
          end: end,
          length: segmentLength,
          covered: false,
          coveringCameras: []
        });
        
        totalLength += segmentLength;
      }
      
      // Check camera coverage for each segment
      cameras.forEach(camera => {
        const cameraPos = L.latLng(camera.lat || camera.latitude, camera.lng || camera.longitude);
        const cameraRange = parseFloat(camera.range || camera.specs?.range || 10); // Default 10m range
        
        fenceSegments.forEach(segment => {
          const distanceToSegment = getDistanceToLineSegment(cameraPos, segment.start, segment.end);
          
          if (distanceToSegment <= cameraRange) {
            segment.covered = true;
            segment.coveringCameras.push({
              id: camera.id,
              name: camera.name || `Camera ${camera.id}`,
              distance: distanceToSegment.toFixed(1)
            });
          }
        });
      });
      
      // Calculate coverage statistics
      const coveredSegments = fenceSegments.filter(s => s.covered);
      const coveredLength = coveredSegments.reduce((sum, s) => sum + s.length, 0);
      const coverage = totalLength > 0 ? (coveredLength / totalLength) * 100 : 0;
      
      // Find gaps (uncovered segments)
      const gaps = fenceSegments.filter(s => !s.covered).map((s, index) => ({
        index: index,
        length: s.length.toFixed(1),
        start: `${s.start.lat.toFixed(6)}, ${s.start.lng.toFixed(6)}`,
        end: `${s.end.lat.toFixed(6)}, ${s.end.lng.toFixed(6)}`
      }));
      
      return {
        percentage: coverage,
        coveredLength: coveredLength,
        totalLength: totalLength,
        segments: fenceSegments,
        gaps: gaps,
        cameras: cameras.length
      };
    }

    function getDistanceToLineSegment(point, lineStart, lineEnd) {
      const A = point.lng - lineStart.lng;
      const B = point.lat - lineStart.lat;
      const C = lineEnd.lng - lineStart.lng;
      const D = lineEnd.lat - lineStart.lat;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      
      if (lenSq === 0) {
        // Line segment is actually a point
        return point.distanceTo(lineStart);
      }
      
      let param = dot / lenSq;
      
      let xx, yy;
      if (param < 0) {
        xx = lineStart.lng;
        yy = lineStart.lat;
      } else if (param > 1) {
        xx = lineEnd.lng;
        yy = lineEnd.lat;
      } else {
        xx = lineStart.lng + param * C;
        yy = lineStart.lat + param * D;
      }
      
      const closestPoint = L.latLng(yy, xx);
      return point.distanceTo(closestPoint);
    }

    function showFenceCoverageAnalysis(fence, coverage, areaCoverage = null) {
      const hasArea = !!(areaCoverage && areaCoverage.totalArea > 0);
      const areaPct = hasArea ? (areaCoverage.coveredArea / areaCoverage.totalArea * 100) : 0;
      const areaSummaryBannerBg = hasArea ? (areaPct >= 80 ? '#d4edda' : areaPct >= 50 ? '#fff3cd' : '#f8d7da') : '#e9ecef';
      const areaSummaryBannerFg = hasArea ? (areaPct >= 80 ? '#155724' : areaPct >= 50 ? '#856404' : '#721c24') : '#6c757d';
      const areaSummaryBannerBorder = hasArea ? (areaPct >= 80 ? '#c3e6cb' : areaPct >= 50 ? '#ffeaa7' : '#f5c6cb') : '#ced4da';
      const areaSummaryText = hasArea ? `${areaPct.toFixed(1)}% Surface Coverage` : 'Surface coverage unavailable (need 3+ points)';

      const analysisHtml = `
        <style>
          .fence-modal .fence-analysis { font-size: 12px; line-height: 1.35; }
          .fence-modal .fence-analysis h2 { font-size: 16px !important; }
          .fence-modal .fence-analysis h3 { font-size: 14px !important; }
          .fence-modal .fence-analysis .coverage-summary div[style*="font-size: 22px"] { font-size: 16px !important; }
          .fence-modal .fence-analysis .coverage-summary div[style*="font-size: 13px"] { font-size: 11px !important; }
          .fence-modal .fence-analysis .analysis-stats .stat-value { font-size: 14px !important; }
          .fence-modal .fence-analysis .analysis-stats .stat-label { font-size: 10px !important; }
          .fence-modal .fence-analysis .coverage-gaps p { font-size: 12px !important; }
          .fence-modal .fence-analysis small { font-size: 10px !important; }
          .fence-modal .fence-analysis .segment-details .segment { font-size: 12px; }
          .fence-modal .fence-analysis .recommendations li { font-size: 12px; }
          .fence-modal button { font-size: 12px !important; padding: 8px 14px !important; }
        </style>
        <div class="fence-analysis">
          <div class="analysis-header">
            <h2 style="margin: 0 0 10px 0; color: #8e44ad;">🏗️ Fence Coverage Analysis</h2>
            <h3 style="margin: 0 0 15px 0; color: #2c3e50;">${fence.name}</h3>
            
            <div class="coverage-summary" style="background: ${areaSummaryBannerBg}; 
                                                 color: ${areaSummaryBannerFg}; 
                                                 padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 12px;
                                                 border: 1px solid ${areaSummaryBannerBorder};">
              <div style="font-size: 22px; font-weight: 700; margin-bottom: 5px;" class="stat-value">
                ${areaSummaryText}
              </div>
              ${hasArea ? `<div style="font-size: 13px; opacity: .9;" class="stat-label">${formatArea(areaCoverage.coveredArea)} of ${formatArea(areaCoverage.totalArea)} covered</div>` :
                `<div style="font-size: 13px; opacity: .9;" class="stat-label">Draw at least 3 points to compute surface (m²)</div>`}
            </div>

          </div>
          
          <div class="analysis-stats">
            <h3 style="color: #2c3e50; margin-bottom: 15px;">📊 Coverage Statistics</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px;">
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold; color: #2c3e50;" class="stat-value">${hasArea ? formatArea(areaCoverage.coveredArea) : '—'}</div>
                <div style="font-size: 12px; color: #6c757d;" class="stat-label">Covered Surface</div>
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold; color: #6c757d;" class="stat-value">${hasArea ? formatArea(areaCoverage.totalArea) : '—'}</div>
                <div style="font-size: 12px; color: #6c757d;" class="stat-label">Total Surface</div>
              </div>
              <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold; color: #3498db;" class="stat-value">${coverage.cameras}</div>
                <div style="font-size: 12px; color: #6c757d;" class="stat-label">Total Cameras</div>
              </div>
            </div>
          </div>
          
          
          
          
          <div class="recommendations" style="margin-top: 20px;">
            <h3 style="color: #2c3e50; margin-bottom: 15px;">💡 Recommendations</h3>
            ${hasArea && areaPct < 100 ? `
              <div style="background: #e8f4f9; border-left: 4px solid #3498db; padding: 10px; border-radius: 0 5px 5px 0;">
                <strong>To improve surface coverage:</strong>
                <ul style="margin: 5px 0 0 20px;">
                  <li>Adjust camera positions to better overlap the target area</li>
                  <li>Increase camera height or coverage angle where feasible</li>
                  <li>Add cameras to eliminate uncovered regions within the selected area</li>
                  <li>Verify no obstructions reduce the effective coverage footprint</li>
                </ul>
              </div>
            ` : `
              <div style="background: #d4edda; border-left: 4px solid #28a745; padding: 10px; border-radius: 0 5px 5px 0;">
                <strong>Great!</strong> The selected area has full surface coverage.
              </div>
            `}
          </div>
        </div>
      `;
      
      // Create modal for analysis
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.7); z-index: 10000; display: flex; 
        align-items: center; justify-content: center; padding: 20px;
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: white; border-radius: 12px; padding: 30px; 
        max-width: 900px; max-height: 90vh; overflow-y: auto; 
        box-shadow: 0 10px 30px rgba(0,0,0,0.3); position: relative;
      `;
      
      content.innerHTML = analysisHtml + `
        <style>
          .fence-modal .action-buttons { display: flex; align-items: center; justify-content: center; gap: 8px; }
          .fence-modal .action-buttons .icon-btn { 
            width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center;
            padding: 0 !important; line-height: 1; border-radius: 6px; border: none; cursor: pointer; background: transparent;
            box-shadow: none; transition: all 0.2s ease; color: #6b7280; /* default gray like btn-secondary */
          }
          .fence-modal .action-buttons .icon-btn:hover { background: #f9fafb; color: #374151; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.15); }
          .fence-modal .action-buttons .export-report-btn { color: #3b82f6; }
          .fence-modal .action-buttons .export-report-btn:hover { background: #dbeafe; color: #2563eb; }
          .fence-modal .action-buttons svg { width: 18px; height: 18px; }
          .fence-modal .action-buttons svg path, 
          .fence-modal .action-buttons svg polyline, 
          .fence-modal .action-buttons svg line, 
          .fence-modal .action-buttons svg rect { stroke: currentColor; }
          .fence-modal .action-buttons svg [fill] { fill: currentColor; }
        </style>
        <div class="action-buttons" style="text-align: center; margin-top: 25px;">
          <button class="icon-btn close-analysis-btn" aria-label="Close analysis" title="Close analysis" onclick="this.closest('.fence-modal').remove()">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
          <button class="icon-btn export-report-btn" aria-label="Export report" title="Export report">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="12" y1="18" x2="12" y2="12"></line>
              <polyline points="9 15 12 18 15 15"></polyline>
            </svg>
          </button>
        </div>
      `;
      
      modal.className = 'fence-modal';
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });

      // Bind export button to a robust exporter (supports fence and area subjects)
      const exportBtn = content.querySelector('.export-report-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          try { window.exportAnalysisReport(fence); } catch(e){ console.error('Export failed', e); alert('Export failed: ' + (e?.message||e)); }
        });
      }
    }

    // DMS-styled PDF export for both fence and area analyses
    window.exportAnalysisReport = async function(subjectFence) {
      try {
        if (!subjectFence || !Array.isArray(subjectFence.points) || subjectFence.points.length < 2) {
          alert('Nothing to export: no subject or not enough points.');
          return;
        }

        const companyName = (document.getElementById('headerCompanyName')?.textContent || 'Company').trim();
        const analysisDate = new Date();

  // If subject is an area (polygon), restrict cameras to those covering it
  const coveringIds = getCameraIdsCoveringArea(subjectFence.points);
  const cameras = coveringIds.length ? getCameraItemsByIds(coveringIds) : getAllCameras();
  const lengthCoverage = calculateFenceCoverage(subjectFence, cameras);
        let areaCoverage = null;
        try { areaCoverage = calculateFenceAreaCoverage(subjectFence); } catch(_){}
        const hasArea = !!(areaCoverage && areaCoverage.totalArea > 0);
        const areaPct = hasArea ? (areaCoverage.coveredArea / areaCoverage.totalArea * 100) : null;

        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) { alert('PDF library not loaded'); return; }
        const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const margin = 40;
        const lineHeight = 14;
        const maxY = pageH - margin;
        let y = margin;

        // One-page mode: never add pages; truncate content politely
        const hasSpace = (lines = 1, extra = 0) => (y + (lines * lineHeight) + extra) <= maxY;
        const drawDivider = (padTop = 8, padBottom = 14) => {
          if (!hasSpace(1, padTop + padBottom)) return;
          y += padTop;
          pdf.setDrawColor(224,224,224);
          pdf.line(margin, y, pageW - margin, y);
          y += padBottom;
        };

        // Header (aligning to dmstable.html style)
        if (companyName) {
          pdf.setFont('helvetica', 'bold');
          pdf.setFontSize(14);
          if (hasSpace()) { pdf.text(companyName, margin, y); y += 18; }
        }
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(18);
        if (hasSpace(2)) { pdf.text('Coverage Analysis Report', margin, y); y += 24; }
        pdf.setFontSize(11);
        pdf.setFont('helvetica', 'normal');
  drawDivider(6, 14);

        // Summary rows (label/value like DMS)
        const labelColX = margin;
        const valueColX = margin + 120; // match dmstable label width
        const usableWidth = pageW - valueColX - margin;
        const line = (label, value) => {
          if (value == null || !hasSpace()) return;
          const valueStr = String(value);
          let textLines = pdf.splitTextToSize(valueStr, usableWidth);
          if (!hasSpace(textLines.length)) {
            const available = Math.max(0, Math.floor((maxY - y) / lineHeight));
            if (available === 0) return;
            textLines = textLines.slice(0, available);
            const last = textLines[textLines.length - 1] || '';
            if (last && !last.endsWith('…')) textLines[textLines.length - 1] = last.replace(/(.{0,})$/, '$1…');
          }
          pdf.setTextColor(44,62,80); // label color
          pdf.setFont('helvetica', 'bold');
          pdf.text(String(label)+':', labelColX, y);
          pdf.setTextColor(51,51,51); // value color
          pdf.setFont('helvetica', 'normal');
          pdf.text(textLines, valueColX, y);
          y += lineHeight * textLines.length;
        };

        // Summary (minimal like DMS doc details)
        line('Subject', subjectFence.name || 'Selection');
        line('Report Date', analysisDate.toLocaleString());

  drawDivider(10, 14);

        // Coverage Statistics section
        const heading = (text) => {
          if (!hasSpace(2)) return false;
          pdf.setFont('helvetica', 'bold');
          pdf.setTextColor(44,62,80);
          pdf.setFontSize(13);
          pdf.text(String(text), margin, y);
          y += 18;
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'normal');
          pdf.setTextColor(51,51,51);
          return true;
        };

        if (heading('Coverage Statistics') !== false) {
          line('Surface Coverage', hasArea ? `${areaPct.toFixed(1)}%` : '—');
          line('Surface Covered', hasArea ? `${formatArea(areaCoverage.coveredArea)} of ${formatArea(areaCoverage.totalArea)}` : '—');
          line('Fence Length', `${lengthCoverage.totalLength.toFixed(1)} m`);
          line('Total Cameras', `${lengthCoverage.cameras || cameras.length}`);
        }
        // Removed Coverage Gaps and Segment Coverage Details per request

  drawDivider(10, 14);

        // Recommendations (brief)
        if (heading('Recommendations') !== false) {
          const recs = [];
          if (hasArea && areaPct < 100) recs.push('Add/adjust cameras to improve surface coverage.');
          recs.push('Adjust camera ranges where feasible.');
          recs.push('Optimize camera placement for line-of-sight.');
          for (const r of recs) {
            const wrapped = pdf.splitTextToSize(`• ${r}`, pageW - 2 * margin);
            if (!hasSpace(wrapped.length)) break;
            pdf.text(wrapped, margin, y); y += lineHeight * wrapped.length;
          }
        }

        const fileBase = (subjectFence?.name || 'coverage').replace(/\s+/g, '-').toLowerCase();
        pdf.save(`${fileBase}-analysis.pdf`);
      } catch (err) {
        console.error('PDF export failed:', err);
        alert('Failed to export PDF: ' + (err?.message || err));
      }
    };

    // Compute surface coverage (m²) within a closed fence (polygon)
    function calculateFenceAreaCoverage(fence) {
      if (!Array.isArray(fence.points) || fence.points.length < 3) {
        return null;
      }

      // Build a closed polygon from fence points
      const ring = fence.points.map(p => [p[1], p[0]]); // [lng, lat]
      const first = ring[0];
      const last = ring[ring.length - 1];
      if (first[0] !== last[0] || first[1] !== last[1]) {
        ring.push([first[0], first[1]]);
      }

      const fencePoly = turf.polygon([ring]);
      const totalArea = turf.area(fencePoly); // in m²

      // Collect camera coverage polygons (Leaflet polygons already on map)
      const coveragePolys = [];
      (state.shapes || []).forEach(s => {
        if (!s || s.kind !== 'cameraSector') return;
        // Prefer a sector/polygon geometry if present
        const geomLayers = [s.polygon, s.sector];
        let pushed = false;
        for (const layer of geomLayers) {
          if (!layer || typeof layer.toGeoJSON !== 'function') continue;
          try {
            const featureOrGeom = layer.toGeoJSON();
            const geom = featureOrGeom && featureOrGeom.type === 'Feature' ? featureOrGeom.geometry : featureOrGeom;
            if (geom && (geom.type === 'Polygon' || geom.type === 'MultiPolygon')) {
              coveragePolys.push(geom);
              pushed = true;
              break;
            }
          } catch (_) { /* ignore invalid */ }
        }
        // Fallback: if only a circle exists, approximate it as a polygon using turf.circle
        if (!pushed && s.circle && s.center && s.radius) {
          try {
            const center = [s.center[1], s.center[0]]; // [lng, lat]
            const radiusKm = Number(s.radius) / 1000.0;
            const circlePoly = turf.circle(center, radiusKm, { steps: 64, units: 'kilometers' });
            if (circlePoly && circlePoly.geometry) coveragePolys.push(circlePoly.geometry);
          } catch (_) { /* ignore */ }
        }
      });

      if (coveragePolys.length === 0 || totalArea <= 0) {
        return { totalArea: Math.max(totalArea, 0), coveredArea: 0 };
      }

      // Intersect each coverage poly with fence area and union results to avoid double counting
      let unioned = null;
      coveragePolys.forEach(polyGeom => {
        try {
          const polyFeature = polyGeom.type === 'Feature' ? polyGeom : { type: 'Feature', geometry: polyGeom, properties: {} };
          const inter = turf.intersect(fencePoly, polyFeature);
          if (!inter) return;
          if (!unioned) unioned = inter;
          else {
            try { unioned = turf.union(unioned, inter); } catch (_) { /* union may fail on tiny artifacts */ }
          }
        } catch (_) { /* skip problematic geometry */ }
      });

      const coveredArea = unioned ? turf.area(unioned) : 0;
      return { totalArea, coveredArea };
    }

    function formatArea(m2) {
      if (!isFinite(m2) || m2 < 0) return '0 m²';
      if (m2 < 10000) return `${Math.round(m2)} m²`;
      const hectares = m2 / 10000; // 1 ha = 10,000 m²
      return `${hectares.toFixed(2)} ha`;
    }

    // Return unique camera IDs whose coverage geometry intersects the given area polygon
    function getCameraIdsCoveringArea(areaPoints){
      try{
        if (!Array.isArray(areaPoints) || areaPoints.length < 3) return [];
        const ring = areaPoints.map(p => [p[1], p[0]]);
        const first = ring[0];
        const last = ring[ring.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) ring.push([first[0], first[1]]);
        const areaPoly = turf.polygon([ring]);
        const idSet = new Set();
        (state.shapes || []).forEach(s => {
          if (!s || s.kind !== 'cameraSector') return;
          let geom = null;
          // Prefer an existing polygon/sector on the map
          const layer = s.polygon || s.sector || s.circle;
          if (layer && typeof layer.toGeoJSON === 'function'){
            try {
              const feature = layer.toGeoJSON();
              geom = feature && feature.type === 'Feature' ? feature.geometry : feature;
            } catch(_){}
          }
          // Fallback: approximate circle if only center+radius exist
          if (!geom && s.center && s.radius){
            try{
              const center = [ (Array.isArray(s.center)? s.center[1] : parseFloat(s.center.lng)), (Array.isArray(s.center)? s.center[0] : parseFloat(s.center.lat)) ];
              const radiusKm = Number(s.radius)/1000.0;
              const circlePoly = turf.circle(center, radiusKm, { steps: 64, units: 'kilometers' });
              geom = circlePoly && circlePoly.geometry;
            }catch(_){ }
          }
          if (!geom) return;
          try{
            const feature = geom.type === 'Feature' ? geom : { type:'Feature', geometry: geom, properties:{} };
            const inter = turf.intersect(areaPoly, feature);
            if (inter) idSet.add(s.cameraId);
          }catch(_){ /* ignore */ }
        });
        return Array.from(idSet).filter(id => id != null);
      }catch(_){ return []; }
    }
    function getCameraItemsByIds(ids){
      if (!Array.isArray(ids) || !ids.length) return [];
      const byId = new Map((state.items||[]).filter(i=>i && i.type==='camera').map(i=>[i.id, i]));
      return ids.map(id => byId.get(id)).filter(Boolean);
    }

    function computeAllAreasSummary(){
      if (!state.selections || state.selections.length === 0) return null;
      const out = { items: [], totalArea: 0, totalCovered: 0, overallPct: 0, count: 0 };
      for (const area of state.selections){
        const pseudoFence = { points: area.points, name: area.name };
        let areaCov = null;
        try { areaCov = calculateFenceAreaCoverage(pseudoFence); } catch(_){}
        const total = areaCov ? areaCov.totalArea : 0;
        const covered = areaCov ? areaCov.coveredArea : 0;
        const pct = total>0 ? (covered/total*100) : 0;
        out.items.push({ id: area.id, name: area.name, total, covered, pct });
        out.totalArea += total;
        out.totalCovered += covered;
      }
      out.count = out.items.length;
      out.overallPct = out.totalArea>0 ? (out.totalCovered/out.totalArea*100) : 0;
      // sort by lowest coverage first for actionable insight
      out.items.sort((a,b)=> a.pct - b.pct);
      return out;
    }

    function openAnalyzeAllModal(){
      const summary = computeAllAreasSummary();
      if (!summary) { alert('No analysis areas found. Use "Draw Analysis Area" first.'); return; }
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;z-index:10000;';
      const card = document.createElement('div');
      card.style.cssText = 'background:#fff;border-radius:10px;min-width:420px;max-width:860px;max-height:80vh;overflow:auto;padding:16px 18px;box-shadow:0 10px 28px rgba(0,0,0,.25);font-family:Inter,system-ui,-apple-system,sans-serif;';
      const companyName = (document.getElementById('headerCompanyName')?.textContent || 'Company').trim();
      const now = new Date();
      const rowsHtml = summary.items.map((r,idx)=>`
        <tr>
          <td style="padding:6px 8px;border-bottom:1px solid #eee;color:#2c3e50;">${r.name || ('Area '+r.id)}</td>
          <td style="padding:6px 8px;border-bottom:1px solid #eee;color:#555;">${formatArea(r.covered)} of ${formatArea(r.total)}</td>
          <td style="padding:6px 8px;border-bottom:1px solid #eee;text-align:right;color:${r.pct<50?'#e74c3c':(r.pct<80?'#e67e22':'#2ecc71')};">${r.pct.toFixed(1)}%</td>
        </tr>`).join('');
      card.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
          <div style="font-weight:700;color:#2c3e50;">All Areas Coverage Summary</div>
          <div style="display:flex;gap:8px;">
            <button id="allAreasPdf" class="icon-btn" title="Export PDF" style="background:none;border:none;color:#3498db;cursor:pointer;font-size:16px;"><i class="fas fa-file-pdf"></i></button>
            <button id="allAreasClose" class="icon-btn" title="Close" style="background:none;border:none;color:#666;cursor:pointer;font-size:18px;"><i class="fas fa-times"></i></button>
          </div>
        </div>
        <div style="font-size:12px;color:#666;margin-bottom:10px;">${companyName} — ${now.toLocaleString()}</div>
        <div style="border-top:1px solid #e4e6eb;margin:8px 0 12px;"></div>
        <div style="display:grid;grid-template-columns:200px 1fr;gap:8px 16px;margin-bottom:12px;">
          <div style="color:#2c3e50;font-weight:600;">Areas Count</div><div>${summary.count}</div>
          <div style="color:#2c3e50;font-weight:600;">Overall Surface Coverage</div><div>${summary.overallPct.toFixed(1)}%</div>
          <div style="color:#2c3e50;font-weight:600;">Total Surface Covered</div><div>${formatArea(summary.totalCovered)} of ${formatArea(summary.totalArea)}</div>
        </div>
        <div style="border-top:1px solid #e4e6eb;margin:8px 0 12px;"></div>
        <table style="width:100%;border-collapse:collapse;font-size:13px;">
          <thead>
            <tr>
              <th style="text-align:left;padding:6px 8px;border-bottom:1px solid #ddd;color:#2c3e50;">Area</th>
              <th style="text-align:left;padding:6px 8px;border-bottom:1px solid #ddd;color:#2c3e50;">Surface</th>
              <th style="text-align:right;padding:6px 8px;border-bottom:1px solid #ddd;color:#2c3e50;">% Covered</th>
            </tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
      overlay.appendChild(card);
      document.body.appendChild(overlay);
      const close = ()=>{ try{ document.body.removeChild(overlay); }catch(_){} };
      card.querySelector('#allAreasClose').onclick = close;
      overlay.addEventListener('click', (e)=>{ if(e.target===overlay) close(); });
      card.querySelector('#allAreasPdf').onclick = ()=> exportAllAreasSummaryPDF(summary);
    }

    function exportAllAreasSummaryPDF(summary){
      try{
        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) { alert('PDF library not loaded'); return; }
        const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const margin = 40; const lineHeight = 14; const maxY = pageH - margin; let y = margin;
        const hasSpace = (lines=1, extra=0)=> (y + (lines*lineHeight) + extra) <= maxY;
        const drawDivider = (padTop=6, padBottom=14)=>{ if(!hasSpace(1,padTop+padBottom)) return; y += padTop; pdf.setDrawColor(224,224,224); pdf.line(margin, y, pageW-margin, y); y += padBottom; };
        const companyName = (document.getElementById('headerCompanyName')?.textContent || 'Company').trim();
        const analysisDate = new Date();
        if (companyName) { pdf.setFont('helvetica','bold'); pdf.setFontSize(14); if (hasSpace()) { pdf.text(companyName, margin, y); y += 18; } }
        pdf.setFont('helvetica','bold'); pdf.setFontSize(18); if (hasSpace(2)) { pdf.text('All Areas Coverage Summary', margin, y); y += 24; }
        pdf.setFontSize(11); pdf.setFont('helvetica','normal'); drawDivider(6,14);
        const labelColX = margin; const valueColX = margin + 160; const usableWidth = pageW - valueColX - margin;
        const line = (label, value) => { if (value==null || !hasSpace()) return; const textLines = pdf.splitTextToSize(String(value), usableWidth); pdf.setTextColor(44,62,80); pdf.setFont('helvetica','bold'); pdf.text(String(label)+':', labelColX, y); pdf.setTextColor(51,51,51); pdf.setFont('helvetica','normal'); pdf.text(textLines, valueColX, y); y += lineHeight * textLines.length; };
        line('Report Date', analysisDate.toLocaleString());
        line('Areas Count', summary.count);
        line('Overall Surface Coverage', `${summary.overallPct.toFixed(1)}%`);
        line('Total Surface Covered', `${formatArea(summary.totalCovered)} of ${formatArea(summary.totalArea)}`);
        drawDivider(10,14);
        pdf.setFont('helvetica','bold'); pdf.setTextColor(44,62,80); pdf.setFontSize(13);
        if (hasSpace()) { pdf.text('Per-Area Summary', margin, y); y += 18; }
        pdf.setFontSize(11); pdf.setFont('helvetica','normal'); pdf.setTextColor(51,51,51);
        const col1 = margin; const col2 = margin + 220; const col3 = pageW - margin - 90;
        if (hasSpace()) { pdf.setFont('helvetica','bold'); pdf.text('Area', col1, y); pdf.text('Surface', col2, y); pdf.text('% Covered', col3, y); y += 14; pdf.setFont('helvetica','normal'); }
        for (const r of summary.items){ if (!hasSpace()) break; const nameLines = pdf.splitTextToSize(r.name || `Area ${r.id}`, col2 - col1 - 10); if (!hasSpace(Math.max(1, nameLines.length))) break; pdf.text(nameLines, col1, y); pdf.text(`${formatArea(r.covered)} of ${formatArea(r.total)}`, col2, y); pdf.text(`${r.pct.toFixed(1)}%`, col3, y); y += lineHeight * Math.max(1, nameLines.length); }
        pdf.save('all-areas-coverage-summary.pdf');
      }catch(e){ console.error('Export all areas PDF failed:', e); alert('Export failed: ' + (e?.message||e)); }
    }

    async function analyzeAllAreasAndExport(){
      try{
        if (!state.selections || state.selections.length === 0) {
          alert('No analysis areas found. Use "Draw Analysis Area" first.');
          return;
        }
        const areas = state.selections;
        const results = [];
        let totalAreaAll = 0;
        let totalCoveredAll = 0;
        for (const area of areas){
          const pseudoFence = { points: area.points, name: area.name };
          let areaCov = null;
          try { areaCov = calculateFenceAreaCoverage(pseudoFence); } catch(_){ areaCov=null; }
          const totalA = areaCov ? areaCov.totalArea : 0;
          const coveredA = areaCov ? areaCov.coveredArea : 0;
          const pct = (totalA>0) ? (coveredA/totalA*100) : 0;
          results.push({ id: area.id, name: area.name, total: totalA, covered: coveredA, pct });
          totalAreaAll += totalA; totalCoveredAll += coveredA;
        }

        // Prepare one-page PDF summary
        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) { alert('PDF library not loaded'); return; }
        const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const margin = 40;
        const lineHeight = 14;
        const maxY = pageH - margin;
        let y = margin;
        const hasSpace = (lines=1, extra=0)=> (y + (lines*lineHeight) + extra) <= maxY;
        const drawDivider = (padTop=8, padBottom=14)=>{ if(!hasSpace(1,padTop+padBottom)) return; y += padTop; pdf.setDrawColor(224,224,224); pdf.line(margin, y, pageW-margin, y); y += padBottom; };

        const companyName = (document.getElementById('headerCompanyName')?.textContent || 'Company').trim();
        const analysisDate = new Date();
        if (companyName) { pdf.setFont('helvetica','bold'); pdf.setFontSize(14); if (hasSpace()) { pdf.text(companyName, margin, y); y += 18; } }
        pdf.setFont('helvetica','bold'); pdf.setFontSize(18); if (hasSpace(2)) { pdf.text('All Areas Coverage Summary', margin, y); y += 24; }
        pdf.setFontSize(11); pdf.setFont('helvetica','normal'); drawDivider(6,14);

        // Overall summary
        const overallPct = totalAreaAll>0 ? (totalCoveredAll/totalAreaAll*100) : 0;
        const labelColX = margin; const valueColX = margin + 160; const usableWidth = pageW - valueColX - margin;
        const line = (label, value) => {
          if (value==null || !hasSpace()) return;
          const textLines = pdf.splitTextToSize(String(value), usableWidth);
          pdf.setTextColor(44,62,80); pdf.setFont('helvetica','bold'); pdf.text(String(label)+':', labelColX, y);
          pdf.setTextColor(51,51,51); pdf.setFont('helvetica','normal'); pdf.text(textLines, valueColX, y);
          y += lineHeight * textLines.length;
        };
        line('Report Date', analysisDate.toLocaleString());
        line('Areas Count', areas.length);
        line('Overall Surface Coverage', `${overallPct.toFixed(1)}%`);
        line('Total Surface Covered', `${formatArea(totalCoveredAll)} of ${formatArea(totalAreaAll)}`);

        drawDivider(10,14);
        // Per-area quick table
        pdf.setFont('helvetica','bold'); pdf.setTextColor(44,62,80); pdf.setFontSize(13);
        if (hasSpace()) { pdf.text('Per-Area Summary', margin, y); y += 18; }
        pdf.setFontSize(11); pdf.setFont('helvetica','normal'); pdf.setTextColor(51,51,51);

        const col1 = margin; const col2 = margin + 220; const col3 = pageW - margin - 90; // name, surface, %
        // Header row
        if (hasSpace()) { pdf.setFont('helvetica','bold'); pdf.text('Area', col1, y); pdf.text('Surface', col2, y); pdf.text('% Covered', col3, y); y += 14; pdf.setFont('helvetica','normal'); }
        for (const r of results){
          if (!hasSpace()) break;
          const nameLines = pdf.splitTextToSize(r.name || `Area ${r.id}`, col2 - col1 - 10);
          if (!hasSpace(Math.max(1, nameLines.length))) break;
          pdf.text(nameLines, col1, y);
          pdf.text(`${formatArea(r.covered)} of ${formatArea(r.total)}`, col2, y);
          pdf.text(`${r.pct.toFixed(1)}%`, col3, y);
          y += lineHeight * Math.max(1, nameLines.length);
        }

        pdf.save('all-areas-coverage-summary.pdf');
      } catch (e){
        console.error('Analyze all areas export failed:', e);
        alert('Export failed: ' + (e?.message || e));
      }
    }

    function undoLastAction(){
      if(undoStack.length===0){ alert('Nothing to undo'); return; }
      const action = undoStack.pop();
      switch(action.type){
        case 'create-fence': {
          const id = action.id;
          const idx = state.fences.findIndex(f=>f.id===id);
          if(idx!==-1){
            const f = state.fences[idx];
            if(f.polyline) layers.fences.removeLayer(f.polyline);
            state.fences.splice(idx,1);
          }
          break;
        }
        case 'delete-fence': {
          const f = action.fence;
          // Recreate on map and state
          state.fences.push(f);
          const polyline = L.polyline(f.points, { color:'#8e44ad', weight:4, opacity:0.8 }).addTo(layers.fences);
          const popupContent = `
            <div style="min-width: 200px;">
              <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🏗️ ${f.name}</h4>
              <div style="margin-bottom: 8px;"><strong>Length:</strong> ${calculateFenceLength(f.points).toFixed(1)}m</div>
              <div style="margin-bottom: 8px;"><strong>Points:</strong> ${f.points.length}</div>
              <div style="margin-bottom: 10px;"><strong>Created:</strong> ${new Date(f.created).toLocaleDateString()}</div>
              <button onclick="analyzeFenceCoverage(${f.id})" style="padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Analyze Coverage</button>
              <button onclick="deleteFence(${f.id})" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
            </div>`;
          polyline.bindPopup(popupContent);
          attachPlacementAwareClick(polyline);
          f.polyline = polyline;
          break;
        }
        case 'create-area': {
          const id = action.id;
          const idx = state.selections.findIndex(a=>a.id===id);
          if(idx!==-1){
            const a = state.selections[idx];
            if(a.polygon) layers.selections.removeLayer(a.polygon);
            state.selections.splice(idx,1);
          }
          break;
        }
        case 'delete-area': {
          const a = action.area;
          state.selections.push(a);
          const polygon = L.polygon(a.points, { color:'#e67e22', weight:3, opacity:0.9, fillOpacity:0.12 }).addTo(layers.selections);
          const popupContent = buildAreaPopupContent(a);
          polygon.bindPopup(popupContent);
          attachAreaTooltip(a);
          attachPlacementAwareClick(polygon);
          a.polygon = polygon;
          break;
        }
        case 'create-item': {
          const id = action.id;
          const idx = state.items.findIndex(item => item.id === id);
          if(idx !== -1){
            const item = state.items[idx];
            if(item.marker) layers[getLayerForType(item.type)].removeLayer(item.marker);
            // Also remove associated camera coverage if it's a camera
            if(item.type === 'camera'){
              const shapeIdx = state.shapes.findIndex(s => s.cameraId === id);
              if(shapeIdx !== -1){
                const shape = state.shapes[shapeIdx];
                if(shape.polygon) layers.cameras.removeLayer(shape.polygon);
                state.shapes.splice(shapeIdx, 1);
              }
            }
            state.items.splice(idx, 1);
          }
          break;
        }
        case 'delete-item': {
          const item = action.item;
          state.items.push(item);
          const marker = addMarker(item.type, {lat: item.lat, lng: item.lng}, item.data, item.id);
          // Restore camera coverage if it was a camera
          if(item.type === 'camera' && action.shape){
            const shape = action.shape;
            const coverage = addCameraCoverage(shape.center, shape, shape.id, shape.cameraId);
          }
          break;
        }
        case 'edit-item': {
          const id = action.id;
          const oldData = action.oldData;
          const oldPosition = action.oldPosition;
          const idx = state.items.findIndex(item => item.id === id);
          if(idx !== -1){
            const item = state.items[idx];
            // Restore old position and data
            item.lat = oldPosition.lat;
            item.lng = oldPosition.lng;
            item.data = { ...oldData };
            // Update marker position and popup
            if(item.marker){
              item.marker.setLatLng([oldPosition.lat, oldPosition.lng]);
              updateMarkerPopup(item.marker, item.type, oldPosition, item.data, item.id);
            }
            // Update associated camera coverage if it's a camera
            if(item.type === 'camera' && action.oldShape){
              const shapeIdx = state.shapes.findIndex(s => s.cameraId === id);
              if(shapeIdx !== -1){
                const shape = state.shapes[shapeIdx];
                if(shape.polygon) layers.cameras.removeLayer(shape.polygon);
                state.shapes[shapeIdx] = { ...action.oldShape };
                const coverage = addCameraCoverage(action.oldShape.center, action.oldShape, action.oldShape.id, action.oldShape.cameraId);
              }
            }
          }
          break;
        }
      }
    }
    
    function getLayerForType(type){
      switch(type){
        case 'agent-post': return 'posts';
        case 'camera': return 'cameras';
        case 'sensor': return 'sensors';
        case 'alarm': return 'alarms';
        case 'supervisor': return 'supervisors';
        default: return 'alarms';
      }
    }

    window.exportFenceReport = async function(fenceId) {
      try {
        const fence = state.fences.find(f => f.id === fenceId);
        const companyName = (document.getElementById('headerCompanyName')?.textContent || 'Company').trim();
        const analysisDate = new Date();
        
        // Compute stats for summary
        const cameras = getAllCameras();
        const lengthCoverage = fence ? calculateFenceCoverage(fence, cameras) : { percentage:0, coveredLength:0, totalLength:0, gaps:[], cameras:cameras.length };
        let areaCoverage = null; 
        try { if (fence) areaCoverage = calculateFenceAreaCoverage(fence); } catch(_){}
        const areaPct = areaCoverage && areaCoverage.totalArea>0 ? (areaCoverage.coveredArea/areaCoverage.totalArea*100) : null;

        // Prepare PDF
        const { jsPDF } = window.jspdf || {};
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        // Header
        pdf.setFont('helvetica','bold');
        pdf.setFontSize(14);
        pdf.text(companyName, 10, 15);
        pdf.setFontSize(12);
        pdf.text('Security Site Map — Coverage Analysis Report', 10, 23);
        pdf.setFont('helvetica','normal');
        pdf.setFontSize(10);
        pdf.text(`Report Date: ${analysisDate.toLocaleString()}`, 10, 30);
        if (fence) pdf.text(`Subject: ${fence.name}`, 10, 36);

        // Summary box
        let y = 44; const lineH = 6; const left = 12; const right = 110;
        pdf.setDrawColor(200); pdf.setFillColor(248,249,250); pdf.rect(8, 38, pageWidth-16, 28, 'FD');
        pdf.setFont('helvetica','bold'); pdf.text('Summary', 10, 44);
        pdf.setFont('helvetica','normal');
        pdf.text(`Surface Coverage: ${areaPct!=null? areaPct.toFixed(1)+'%':''}`, left, y+=lineH);
        if (areaCoverage) {
          pdf.text(`Covered: ${formatArea(areaCoverage.coveredArea)} of ${formatArea(areaCoverage.totalArea)}`, left, y+=lineH);
        } else {
          pdf.text('Covered: —', left, y+=lineH);
        }
        pdf.text(`Linear Coverage: ${lengthCoverage.percentage.toFixed(1)}%`, right, 44+lineH);
        pdf.text(`Length: ${lengthCoverage.coveredLength.toFixed(1)}m of ${lengthCoverage.totalLength.toFixed(1)}m`, right, 44+2*lineH);
        pdf.text(`Cameras: ${lengthCoverage.cameras || cameras.length}`, right, 44+3*lineH);
  // Removed Gaps from summary per request

        // Map snapshot
        try {
          const mapNode = document.getElementById('securityMap');
          if (mapNode) {
            const mapCanvas = await html2canvas(mapNode, { scale: 2, useCORS: true });
            const imgDataMap = mapCanvas.toDataURL('image/png');
            const mapImgWidth = pageWidth - 20;
            const mapImgHeight = mapCanvas.height * mapImgWidth / mapCanvas.width;
            let mapY = 70;
            if (mapImgHeight > pageHeight - mapY - 10) {
              // reduce width to fit height
              const maxH = pageHeight - mapY - 10;
              const w = mapCanvas.width * maxH / mapCanvas.height;
              const finalW = Math.min(mapImgWidth, w);
              const finalH = maxH;
              pdf.addImage(imgDataMap, 'PNG', 10, mapY, finalW, finalH);
            } else {
              pdf.addImage(imgDataMap, 'PNG', 10, mapY, mapImgWidth, mapImgHeight);
            }
          }
        } catch(_){}

        // Analysis pages (modal WYSIWYG)
        const modal = document.querySelector('.fence-modal');
        const exportNode = modal ? modal.firstElementChild : null;
        if (exportNode) {
          pdf.addPage();
          const scale = 2;
          const canvas = await html2canvas(exportNode, { scale, useCORS: true });
          const imgData = canvas.toDataURL('image/png');
          const imgWidth = pageWidth - 20;
          const imgHeight = canvas.height * imgWidth / canvas.width;

          if (imgHeight <= pageHeight - 20) {
            pdf.addImage(imgData, 'PNG', 10, 10, imgWidth, imgHeight);
          } else {
            // Paginate
            let heightLeft = imgHeight;
            let startY = 0;
            const pageCanvas = document.createElement('canvas');
            const pageCtx = pageCanvas.getContext('2d');
            const pxPerMm = canvas.width / imgWidth; // px per mm at target width
            const pagePixelHeight = (pageHeight - 20) * pxPerMm;
            pageCanvas.width = canvas.width;
            pageCanvas.height = pagePixelHeight;

            while (heightLeft > 0) {
              pageCtx.clearRect(0, 0, pageCanvas.width, pageCanvas.height);
              pageCtx.drawImage(canvas, 0, startY, canvas.width, pagePixelHeight, 0, 0, canvas.width, pagePixelHeight);
              const pageImg = pageCanvas.toDataURL('image/png');
              pdf.addImage(pageImg, 'PNG', 10, 10, imgWidth, pageHeight - 20);
              heightLeft -= (pageHeight - 20);
              startY += pagePixelHeight;
              if (heightLeft > 0) pdf.addPage();
            }
          }
        }

        const fileBase = (fence?.name || 'coverage').replace(/\s+/g, '-').toLowerCase();
        pdf.save(`${fileBase}-analysis.pdf`);
      } catch (err) {
        console.error('PDF export failed:', err);
        alert('Failed to export PDF: ' + (err?.message || err));
      }
    };

    // Global functions for popup buttons
    window.editSecurityElement = function(itemId) {
      const item = state.items.find(i => i.id === itemId);
      if (!item) return;
      
      editingItemId = itemId;
      
      // Populate modal with current values
      document.getElementById('itemType').value = item.type;
      document.getElementById('itemName').value = item.data.name || '';
      document.getElementById('itemLatitude').value = item.lat.toFixed(6);
      document.getElementById('itemLongitude').value = item.lng.toFixed(6);
      
      // If it's a camera, populate camera-specific fields
      if (item.type === 'camera') {
        // Prefer linking by cameraId; fallback to proximity match
        let shape = state.shapes.find(s => s.kind === 'cameraSector' && s.cameraId === itemId);
        if (!shape) {
          shape = state.shapes.find(s => s.kind === 'cameraSector' && 
            Math.abs((s.center?.[0]||0) - item.lat) < 0.000001 && 
            Math.abs((s.center?.[1]||0) - item.lng) < 0.000001);
        }
        if (shape) {
          document.getElementById('camType').value = shape.camType || 'fixed';
          document.getElementById('camHeight').value = shape.height || 3.5;
          document.getElementById('camResolution').value = shape.resolution || '1080p';
          document.getElementById('camEnvironmentalResistance').value = shape.environmentalResistance || 'ip65';
          document.getElementById('camPowerMode').value = shape.powerMode || 'poe';
          document.getElementById('camAudioOutput').value = shape.audioOutput || 'none';
          document.getElementById('camMinIllumination').value = shape.minIllumination || '0.1';
          document.getElementById('camZoom').value = shape.zoom || 'fixed';
          document.getElementById('camRadius').value = shape.radius;
          document.getElementById('camAngle').value = shape.angle;
          document.getElementById('camHeading').value = shape.heading;
          
          // Update the calculated radius display based on the loaded values
          if (typeof updateCalculatedRadius === 'function') {
            updateCalculatedRadius();
          }
        }
      }
      
      // Change modal title and button text
      document.getElementById('addItemTitle').textContent = 'Edit Security Element';
      document.getElementById('btnAddNow').innerHTML = '<i class="fas fa-save"></i> Update Element';
      document.getElementById('btnAddAtCoords').innerHTML = '<i class="fas fa-save"></i> Update at Coordinates';
      // For cameras, emphasize coordinate-only movement and disable place-on-map affordance via text
      if (item.type === 'camera') {
        const note = document.createElement('div');
        note.style.cssText = 'margin-top:8px;color:#e67e22;font-size:12px;';
        note.innerHTML = '<i class="fas fa-info-circle"></i> Move cameras by editing GPS coordinates only (drag disabled).';
        const formBody = document.querySelector('#addItemModal .modal-body');
        if (formBody) formBody.insertBefore(note, formBody.firstChild);
      }
      
      // Open modal
      document.getElementById('addItemModal').classList.add('show');
    };

    window.deleteSecurityElement = function(itemId) {
      if (!confirm('Are you sure you want to delete this security element?')) return;
      
      const item = state.items.find(i => i.id === itemId);
      if (!item) return;
      
      // Save item and associated camera shape for undo
      let associatedShape = null;
      if (item.type === 'camera') {
        associatedShape = state.shapes.find(s => s.kind === 'cameraSector' && s.cameraId === itemId);
      }
      
      // Add undo action before deletion
      pushUndo({ 
        type: 'delete-item', 
        item: JSON.parse(JSON.stringify(item)), 
        shape: associatedShape ? JSON.parse(JSON.stringify(associatedShape)) : null 
      });
      
      // Remove marker from map
      if (item.marker) {
        item.marker.remove();
      }
      
      // Remove associated camera coverage if it's a camera
      if (item.type === 'camera') {
        const shapes = state.shapes.filter(s => s.kind === 'cameraSector' && (s.cameraId === itemId || (
          Math.abs((s.center?.[0]||0) - item.lat) < 0.000001 && Math.abs((s.center?.[1]||0) - item.lng) < 0.000001
        )));
        shapes.forEach(shape => { if (shape.polygon) shape.polygon.remove(); });
        state.shapes = state.shapes.filter(s => !(s.kind === 'cameraSector' && s.cameraId === itemId));
      }
      
      // Remove from state
      const itemIndex = state.items.findIndex(i => i.id === itemId);
      if (itemIndex !== -1) {
        state.items.splice(itemIndex, 1);
      }
      
      map.closePopup();
    };

  function exportJson(){ 
    try {
      // Debug: Log current state before export
      console.log('Current state before export:', {
        items: state.items.length,
        shapes: state.shapes.length,
        fences: state.fences.length,
        selections: state.selections.length
      });
      
      // Create a clean copy of state without circular references
      const exportData = {
        items: state.items.map(item => ({
          id: item.id,
          type: item.type,
          lat: item.lat,
          lng: item.lng,
          data: item.data
          // Exclude 'marker' as it contains circular references
        })),
        shapes: state.shapes.map(shape => ({
          id: shape.id,
          kind: shape.kind,
          center: shape.center,
          radius: shape.radius,
          angle: shape.angle,
          heading: shape.heading,
          camType: shape.camType,
          height: shape.height,
          resolution: shape.resolution,
          environmentalResistance: shape.environmentalResistance,
          powerMode: shape.powerMode,
          audioOutput: shape.audioOutput,
          minIllumination: shape.minIllumination,
          zoom: shape.zoom,
          cameraId: shape.cameraId,
          specs: shape.specs
          // Exclude 'polygon' as it contains circular references
        })),
        fences: state.fences.map(f => ({ id: f.id, name: f.name, points: f.points, created: f.created })),
        selections: state.selections.map(a => ({ id: a.id, name: a.name, points: a.points, created: a.created })),
        nextId: state.nextId,
        exported: new Date().toISOString(),
        version: '1.0'
      };
      
      // Debug: Log export data structure
      console.log('Export data structure:', {
        items: exportData.items.length,
        shapes: exportData.shapes.length,
        fences: exportData.fences.length,
        selections: exportData.selections.length,
        nextId: exportData.nextId
      });
      
      const data = JSON.stringify(exportData, null, 2); 
      const blob = new Blob([data], {type: 'application/json'}); 
      const url = URL.createObjectURL(blob); 
      const a = document.createElement('a'); 
      a.href = url; 
      a.download = 'site-map.json'; 
      a.click(); 
      URL.revokeObjectURL(url);
      
      console.log('Export successful:', exportData);
    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed: ' + error.message);
    }
  }
    function importJson(file){ 
      const reader=new FileReader(); 
      reader.onload=()=>{ 
        try{ 
          const obj=JSON.parse(reader.result); 
          // Clear existing items
          Object.values(layers).forEach(l=>l.clearLayers()); 
          
          // Restore state (normalize any indexed objects)
          const itemsArr = Array.isArray(obj.items) ? obj.items : (obj.items ? Object.values(obj.items) : []);
          const shapesArr = Array.isArray(obj.shapes) ? obj.shapes : (obj.shapes ? Object.values(obj.shapes) : []);
          const fencesArr = Array.isArray(obj.fences) ? obj.fences : (obj.fences ? Object.values(obj.fences) : []);
          const selsArr = Array.isArray(obj.selections) ? obj.selections : (obj.selections ? Object.values(obj.selections) : []);
          state.items = itemsArr;
          state.shapes = shapesArr;
          state.fences = [];
          state.selections = [];
          state.nextId = Math.max(
            ...itemsArr.map(i => i.id || 0),
            ...(shapesArr.map(s => s.id || 0)),
            ...(fencesArr.map(f => f.id || 0)),
            ...(selsArr.map(a => a.id || 0)),
            0
          ) + 1;
          
          // Restore markers
          state.items.forEach(it=> {
            addMarker(it.type, {lat:it.lat,lng:it.lng}, it.data, it.id);
          }); 
          
          // Restore camera coverage and relink to markers
          state.shapes.filter(s=>s.kind==='cameraSector').forEach(s=> {
            const center = normalizeLatLngTuple(s.center);
            addCameraCoverage(center, s, s.id, s.cameraId || null);
          });
          linkExistingCameraShapesToMarkers();

          // Restore fences
          (fencesArr || []).forEach(f => {
            try{
              const fence = { id: f.id, name: f.name || `Fence ${f.id}`, points: f.points || [], created: f.created || Date.now(), polyline: null };
              state.fences.push(fence);
              fence.points = normalizeLatLngPoints(fence.points);
              const polyline = L.polyline(fence.points, { color:'#8e44ad', weight:4, opacity:0.8 }).addTo(layers.fences);
            const popupContent = `
              <div style="min-width: 200px;">
                <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🏗️ ${fence.name}</h4>
                <div style="margin-bottom: 8px;"><strong>Length:</strong> ${calculateFenceLength(fence.points).toFixed(1)}m</div>
                <div style="margin-bottom: 8px;"><strong>Points:</strong> ${fence.points.length}</div>
                <div style="margin-bottom: 10px;"><strong>Created:</strong> ${new Date(fence.created).toLocaleDateString()}</div>
                <button onclick="analyzeFenceCoverage(${fence.id})" style="padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Analyze Coverage</button>
                <button onclick="deleteFence(${fence.id})" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
              </div>`;
              polyline.bindPopup(popupContent);
              attachPlacementAwareClick(polyline);
              fence.polyline = polyline;
            }catch(err){ console.warn('Skipped fence due to error:', err, f); }
          });

          // Restore analysis areas
          (selsArr || []).forEach(a => {
            try{
              const area = { id: a.id, name: a.name || `Analysis Area ${a.id}`, points: a.points || [], created: a.created || Date.now(), polygon: null };
              state.selections.push(area);
              area.points = normalizeLatLngPoints(area.points);
              const polygon = L.polygon(area.points, { color:'#e67e22', weight:3, opacity:0.9, fillOpacity:0.12 }).addTo(layers.selections);
              const popupContent = buildAreaPopupContent(area);
              polygon.bindPopup(popupContent);
              attachPlacementAwareClick(polygon);
              area.polygon = polygon;
              attachAreaTooltip(area);
            }catch(err){ console.warn('Skipped area due to error:', err, a); }
          });
        } catch(err){
          console.error('Import JSON failed:', err);
          alert('Import failed: ' + (err?.message || err));
        }
      };
      reader.readAsText(file); 
    }

    function importExcel(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          
          // Get the first worksheet
          const sheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[sheetName];
          
          // Convert to JSON
          const jsonData = XLSX.utils.sheet_to_json(worksheet);
          
          if (jsonData.length === 0) {
            alert('Excel file appears to be empty or has no valid data.');
            return;
          }
          
          processExcelData(jsonData);
          
        } catch (error) {
          alert('Error reading Excel file: ' + error.message);
          console.error('Excel import error:', error);
        }
      };
      reader.readAsArrayBuffer(file);
    }

    function processExcelData(data) {
      // Get the selected import filter
      const importFilter = document.getElementById('importTypeFilter').value;
      
      // Clear existing items
      Object.values(layers).forEach(l => l.clearLayers());
      state.items = [];
      state.shapes = [];
      
      let successCount = 0;
      let errorCount = 0;
      let filteredCount = 0;
      const errors = [];
      
      console.log('Processing Excel data with filter:', importFilter, data);
      
      data.forEach((row, index) => {
        try {
          // Normalize column names (handle different case variations)
          const normalizedRow = {};
          Object.keys(row).forEach(key => {
            const normalizedKey = key.toLowerCase().trim();
            normalizedRow[normalizedKey] = row[key];
          });
          
          // Extract required fields with multiple possible column names
          const type = getFieldValue(normalizedRow, ['type', 'element_type', 'category', 'kind']);
          const name = getFieldValue(normalizedRow, ['name', 'title', 'label', 'description']);
          const lat = parseFloat(getFieldValue(normalizedRow, ['lat', 'latitude', 'y']));
          const lng = parseFloat(getFieldValue(normalizedRow, ['lng', 'longitude', 'lon', 'x']));
          
          // Validate required fields
          if (!type || isNaN(lat) || isNaN(lng)) {
            errors.push(`Row ${index + 2}: Missing or invalid required fields (type, latitude, longitude)`);
            errorCount++;
            return;
          }
          
          // Validate coordinates
          if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
            errors.push(`Row ${index + 2}: Invalid coordinates (lat: ${lat}, lng: ${lng})`);
            errorCount++;
            return;
          }
          
          // Normalize type to match our system
          const normalizedType = normalizeSecurityType(type);
          if (!normalizedType) {
            errors.push(`Row ${index + 2}: Unknown security element type: ${type}`);
            errorCount++;
            return;
          }
          
          // Apply type filter
          if (importFilter !== 'all' && normalizedType !== importFilter) {
            filteredCount++;
            return; // Skip this element due to filter
          }
          
          // Create marker data
          const elementData = {
            name: name || `${normalizedType.toUpperCase()}-${successCount + 1}`
          };
          
          // Add the marker
          const newMarker = addMarker(normalizedType, { lat, lng }, elementData);
          
          // Handle camera-specific data
          if (normalizedType === 'camera') {
            const camType = getFieldValue(normalizedRow, ['camera_type', 'cam_type', 'type_detail', 'subtype']) || 'fixed';
            const height = parseFloat(getFieldValue(normalizedRow, ['height', 'camera_height', 'mounting_height', 'elevation'])) || 3.5;
            const resolution = getFieldValue(normalizedRow, ['resolution', 'pixel_density', 'video_quality', 'quality']) || '1080p';
            const environmentalResistance = getFieldValue(normalizedRow, ['environmental_resistance', 'protection_rating', 'ip_rating', 'weather_resistance']) || 'ip65';
            const powerMode = getFieldValue(normalizedRow, ['power_mode', 'power_supply', 'power_type', 'energy_source']) || 'poe';
            const audioOutput = getFieldValue(normalizedRow, ['audio_output', 'audio_capability', 'sound_recording', 'audio_features']) || 'none';
            const minIllumination = getFieldValue(normalizedRow, ['min_illumination', 'minimum_light', 'low_light_capability', 'lux_rating']) || '0.1';
            const zoom = getFieldValue(normalizedRow, ['zoom', 'zoom_capability', 'magnification', 'optical_zoom']) || 'fixed';
            const radius = parseFloat(getFieldValue(normalizedRow, ['radius', 'coverage_radius', 'range'])) || 80;
            const angle = parseFloat(getFieldValue(normalizedRow, ['angle', 'coverage_angle', 'fov'])) || 70;
            const heading = parseFloat(getFieldValue(normalizedRow, ['heading', 'direction', 'bearing', 'orientation'])) || 0;
            
            addCameraCoverage([lat, lng], { camType, height, resolution, environmentalResistance, powerMode, audioOutput, minIllumination, zoom, radius, angle, heading }, null, newMarker && newMarker._itemId ? newMarker._itemId : null);
          }
          
          successCount++;
          
        } catch (error) {
          errors.push(`Row ${index + 2}: ${error.message}`);
          errorCount++;
        }
      });
      
      // Show results
      let message = `Excel import completed!\n\n`;
      
      if (importFilter !== 'all') {
        const filterName = importFilter === 'agent-post' ? 'Security Posts' : 
                          importFilter.charAt(0).toUpperCase() + importFilter.slice(1) + 's';
        message += `Filter: ${filterName} only\n`;
      }
      
      message += `Successfully imported: ${successCount} items`;
      
      if (filteredCount > 0) {
        message += `\nFiltered out: ${filteredCount} items (different type)`;
      }
      
      if (errorCount > 0) {
        message += `\nErrors: ${errorCount} items\n\nError details:\n${errors.slice(0, 10).join('\n')}`;
        if (errors.length > 10) {
          message += `\n... and ${errors.length - 10} more errors`;
        }
      }
      
      alert(message);
      
      // Log detailed results to console
      console.log('Excel import results:', {
        filter: importFilter,
        total: data.length,
        success: successCount,
        filtered: filteredCount,
        errors: errorCount,
        errorDetails: errors
      });
    }

    function getFieldValue(row, fieldNames) {
      for (const fieldName of fieldNames) {
        if (row[fieldName] !== undefined && row[fieldName] !== null && row[fieldName] !== '') {
          return row[fieldName];
        }
      }
      return null;
    }

    function normalizeSecurityType(type) {
      const typeStr = String(type).toLowerCase().trim();
      
      // Map various input types to our system types
      const typeMapping = {
        'camera': 'camera',
        'cam': 'camera',
        'cctv': 'camera',
        'surveillance': 'camera',
        'security camera': 'camera',
        
        'post': 'agent-post',
        'agent-post': 'agent-post',
        'agent post': 'agent-post',
        'guard post': 'agent-post',
        'security post': 'agent-post',
        'checkpoint': 'agent-post',
        'guard': 'agent-post',
        'security guard': 'agent-post',
        'guardpost': 'agent-post',
        'securitypost': 'agent-post',
        
        'sensor': 'sensor',
        'motion sensor': 'sensor',
        'detector': 'sensor',
        'proximity sensor': 'sensor',
        'motion': 'sensor',
        
        'alarm': 'alarm',
        'alert': 'alarm',
        'siren': 'alarm',
        'warning': 'alarm',
        'alarms': 'alarm',
        
        'supervisor': 'supervisor',
        'manager': 'supervisor',
        'chief': 'supervisor',
        'lead': 'supervisor',
        'supervisors': 'supervisor'
      };
      
      return typeMapping[typeStr] || null;
    }

    function showExcelHelp() {
      document.getElementById('excelHelpModal').classList.add('show');
    }

    function downloadExcelTemplate() {
      // Get the selected import filter
      const importFilter = document.getElementById('importTypeFilter').value;
      
      // Create template data based on filter
      let templateData = [];
      
      if (importFilter === 'all' || importFilter === 'camera') {
        templateData.push({
          'Type': 'camera',
          'Name': 'CAM-01',
          'Camera_Type': 'fixed',
          'Height': 3.5,
          'Resolution': '1080p',
          'Environmental_Resistance': 'ip65',
          'Power_Mode': 'poe',
          'Audio_Output': 'none',
          'Min_Illumination': '0.1',
          'Zoom': 'fixed',
          'Latitude': 25.2854,
          'Longitude': 51.5310,
          'Radius': 100,
          'Angle': 70,
          'Heading': 45
        });
      }
      
      if (importFilter === 'all' || importFilter === 'agent-post') {
        templateData.push({
          'Type': 'agent-post',
          'Name': 'POST-01',
          'Camera_Type': '',
          'Height': '',
          'Resolution': '',
          'Environmental_Resistance': '',
          'Power_Mode': '',
          'Audio_Output': '',
          'Min_Illumination': '',
          'Zoom': '',
          'Latitude': 25.2844,
          'Longitude': 51.5320,
          'Radius': '',
          'Angle': '',
          'Heading': ''
        });
      }
      
      if (importFilter === 'all' || importFilter === 'sensor') {
        templateData.push({
          'Type': 'sensor',
          'Name': 'SENS-01',
          'Camera_Type': '',
          'Height': '',
          'Resolution': '',
          'Environmental_Resistance': '',
          'Power_Mode': '',
          'Audio_Output': '',
          'Min_Illumination': '',
          'Zoom': '',
          'Latitude': 25.2864,
          'Longitude': 51.5300,
          'Radius': '',
          'Angle': '',
          'Heading': ''
        });
      }
      
      if (importFilter === 'all' || importFilter === 'alarm') {
        templateData.push({
          'Type': 'alarm',
          'Name': 'ALRM-01',
          'Camera_Type': '',
          'Height': '',
          'Resolution': '',
          'Environmental_Resistance': '',
          'Power_Mode': '',
          'Audio_Output': '',
          'Min_Illumination': '',
          'Zoom': '',
          'Latitude': 25.2834,
          'Longitude': 51.5340,
          'Radius': '',
          'Angle': '',
          'Heading': ''
        });
      }
      
      if (importFilter === 'all' || importFilter === 'supervisor') {
        templateData.push({
          'Type': 'supervisor',
          'Name': 'SUPV-01',
          'Camera_Type': '',
          'Height': '',
          'Resolution': '',
          'Environmental_Resistance': '',
          'Power_Mode': '',
          'Audio_Output': '',
          'Min_Illumination': '',
          'Zoom': '',
          'Latitude': 25.2874,
          'Longitude': 51.5290,
          'Radius': '',
          'Angle': '',
          'Heading': ''
        });
      }

      // Create workbook and worksheet
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.json_to_sheet(templateData);

      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(wb, ws, 'Security Elements');

      // Generate filename based on filter
      let filename = 'security_elements_template';
      if (importFilter !== 'all') {
        const filterName = importFilter === 'agent-post' ? 'posts' : importFilter + 's';
        filename += `_${filterName}`;
      }
      filename += '.xlsx';

      // Save file
      XLSX.writeFile(wb, filename);
    }

    function sanitizeKey(name){
      // Firebase RTDB keys cannot contain . $ # [ ] /
      return (name||'').trim().replace(/[.$#\[\]\/]/g,'-').replace(/\s+/g,'-').toLowerCase();
    }

    function defaultMapNameFor(user){
      try{
        const comp = (window.authManager && window.authManager.currentCompany?.companyName) || 'company';
        const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        return `${comp}-sitemap-${stamp}`.toLowerCase();
      }catch{ return `sitemap-${Date.now()}`; }
    }

    async function saveCompany(){ 
      try {
        const u = window.authManager && window.authManager.currentUser; 
        if (!u || !u.companyId) { 
          alert('No company context - please ensure you are logged in'); 
          return; 
        }
        const lsKey = `siteMap:lastName:${u.companyId}`;
        const prev = localStorage.getItem(lsKey) || defaultMapNameFor(u);
        let name = prompt('Name this site map (save slot):', prev || 'default');
        if (name === null) return; // cancelled
        name = sanitizeKey(name) || 'default';
        localStorage.setItem(lsKey, name);
        
  // Derive a friendly saved-by display (prefer full name)
  const display = (u.displayName || u.fullName || (u.profile && (u.profile.name || u.profile.fullName)) || '').trim();
  const savedByName = display || (u.email ? u.email.split('@')[0] : '') || u.uid || 'Unknown User';
  // Create a clean copy of state without circular references
  const saveData = {
          items: state.items.map(item => ({
            id: item.id,
            type: item.type,
            lat: item.lat,
            lng: item.lng,
            data: item.data
            // Exclude 'marker' as it contains circular references
          })),
          shapes: state.shapes.map(shape => ({
            id: shape.id,
            kind: shape.kind,
            center: shape.center,
            radius: shape.radius,
            angle: shape.angle,
            heading: shape.heading
            // Exclude 'polygon' as it contains circular references
          })),
          fences: state.fences.map(f => ({
            id: f.id,
            name: f.name,
            points: f.points,
            created: f.created
            // Exclude 'polyline' (Leaflet layer)
          })),
          selections: state.selections.map(a => ({
            id: a.id,
            name: a.name,
            points: a.points,
            created: a.created
            // Exclude 'polygon' (Leaflet layer)
          })),
          nextId: state.nextId,
          savedAt: new Date().toISOString(),
          savedBy: savedByName,
          savedByName: savedByName,
          savedById: u.uid || null
        };
        
        const ref = firebase.database().ref(`companies/${u.companyId}/siteMaps/${name}`);
        // Check if exists to confirm overwrite
        const existsSnap = await ref.child('savedAt').once('value');
        if (existsSnap.exists()){
          const overwrite = confirm(`A saved map named "${name}" already exists. Overwrite?`);
          if (!overwrite) { alert('Save cancelled.'); return; }
        }
        await ref.set(saveData); 
        alert(`Map saved as "${name}" successfully!`);
        console.log('Company save successful:', saveData);
      } catch (error) {
        console.error('Company save failed:', error);
        alert('Save failed: ' + error.message);
      }
    }
    async function loadCompany(mapName){ 
      try {
        const u = window.authManager && window.authManager.currentUser; 
        if (!u || !u.companyId) { 
          alert('No company context - please ensure you are logged in'); 
          return; 
        } 
        const key = sanitizeKey(mapName || 'default');
        const snap = await firebase.database().ref(`companies/${u.companyId}/siteMaps/${key}`).once('value'); 
        if (snap.exists()) { 
          const obj = snap.val(); 
          // Clear existing items
          Object.values(layers).forEach(l => l.clearLayers()); 
          
          // Restore state with defaults (normalize possible Firebase array-objects)
          state.items = Array.isArray(obj.items) ? obj.items : (obj.items ? Object.values(obj.items) : []);
          state.shapes = Array.isArray(obj.shapes) ? obj.shapes : (obj.shapes ? Object.values(obj.shapes) : []);
          state.fences = []; // will rebuild from obj.fences
          state.selections = []; // will rebuild from obj.selections
          const itemsArr = Array.isArray(obj.items) ? obj.items : (obj.items ? Object.values(obj.items) : []);
          const shapesArr = Array.isArray(obj.shapes) ? obj.shapes : (obj.shapes ? Object.values(obj.shapes) : []);
          const fencesArr = Array.isArray(obj.fences) ? obj.fences : (obj.fences ? Object.values(obj.fences) : []);
          const selsArr = Array.isArray(obj.selections) ? obj.selections : (obj.selections ? Object.values(obj.selections) : []);
          const maxItemId = Math.max(...itemsArr.map(i => i.id || 0), 0);
          const maxShapeId = Math.max(...shapesArr.map(s => s.id || 0), 0);
          const maxFenceId = Math.max(...fencesArr.map(f => f.id || 0), 0);
          const maxSelId = Math.max(...selsArr.map(a => a.id || 0), 0);
          state.nextId = obj.nextId || Math.max(maxItemId, maxShapeId, maxFenceId, maxSelId, 0) + 1;
          
          // Restore markers
          state.items.forEach(it => {
            addMarker(it.type, {lat: it.lat, lng: it.lng}, it.data, it.id);
          }); 
          
          // Restore camera coverage and relink to markers
          state.shapes.filter(s => s.kind === 'cameraSector').forEach(s => {
            const center = normalizeLatLngTuple(s.center);
            addCameraCoverage(center, s, s.id, s.cameraId || null);
          });
          linkExistingCameraShapesToMarkers();

          // Restore fences (polylines + popups)
          (fencesArr || []).forEach(f => {
            try{
              const fence = { id: f.id, name: f.name || `Fence ${f.id}`, points: f.points || [], created: f.created || Date.now(), polyline: null };
              state.fences.push(fence);
              fence.points = normalizeLatLngPoints(fence.points);
              const polyline = L.polyline(fence.points, { color:'#8e44ad', weight:4, opacity:0.8 }).addTo(layers.fences);
            const popupContent = `
              <div style="min-width: 200px;">
                <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🏗️ ${fence.name}</h4>
                <div style="margin-bottom: 8px;"><strong>Length:</strong> ${calculateFenceLength(fence.points).toFixed(1)}m</div>
                <div style="margin-bottom: 8px;"><strong>Points:</strong> ${fence.points.length}</div>
                <div style="margin-bottom: 10px;"><strong>Created:</strong> ${new Date(fence.created).toLocaleDateString()}</div>
                <button onclick="analyzeFenceCoverage(${fence.id})" style="padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Analyze Coverage</button>
                <button onclick="deleteFence(${fence.id})" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
              </div>`;
              polyline.bindPopup(popupContent);
              attachPlacementAwareClick(polyline);
              fence.polyline = polyline;
            }catch(err){ console.warn('Skipped fence (import) due to error:', err, f); }
          });

          // Restore analysis areas (polygons + popups)
          (selsArr || []).forEach(a => {
            try{
              const area = { id: a.id, name: a.name || `Analysis Area ${a.id}`, points: a.points || [], created: a.created || Date.now(), polygon: null };
              state.selections.push(area);
              area.points = normalizeLatLngPoints(area.points);
              const polygon = L.polygon(area.points, { color:'#e67e22', weight:3, opacity:0.9, fillOpacity:0.12 }).addTo(layers.selections);
              const popupContent = buildAreaPopupContent(area);
              polygon.bindPopup(popupContent);
              attachPlacementAwareClick(polygon);
              area.polygon = polygon;
              attachAreaTooltip(area);
            }catch(err){ console.warn('Skipped area (import) due to error:', err, a); }
          });
          
          let message = `Company map "${key}" loaded successfully!`;
          if (obj.savedAt) {
            const savedDate = new Date(obj.savedAt).toLocaleString();
            message += `\n\nLast saved: ${savedDate}`;
          }
          const savedByDisplay = obj.savedByName || obj.savedBy || '';
          if (savedByDisplay) {
            message += `\nSaved by: ${savedByDisplay}`;
          }
          alert(message);
          console.log('Company load successful:', obj);
        } else { 
          alert(`No saved map found for name "${key}"`); 
        }
      } catch (error) {
        console.error('Company load failed:', error);
        alert('Load failed: ' + error.message);
      }
    }

    async function openLoadCompanyPicker(){
      try{
        const u = window.authManager && window.authManager.currentUser; 
        if (!u || !u.companyId) { 
          alert('No company context - please ensure you are logged in'); 
          return; 
        }
        const listSnap = await firebase.database().ref(`companies/${u.companyId}/siteMaps`).once('value');
        const maps = listSnap.exists() ? Object.entries(listSnap.val()) : [];
        if (!maps.length){ alert('No saved site maps found. Save one first.'); return; }

        // Build lightweight picker modal
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;z-index:10000;';
        const card = document.createElement('div');
        card.style.cssText = 'background:#fff;border-radius:8px;min-width:320px;max-width:520px;padding:16px 16px 14px;box-shadow:0 10px 28px rgba(0,0,0,.25);font-family:Inter,system-ui,-apple-system,sans-serif;';
        card.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
            <div style="font-weight:600;color:#2c3e50;">Load Saved Site Map</div>
            <button title="Close" style="background:none;border:none;font-size:18px;color:#666;cursor:pointer">×</button>
          </div>
          <div style="margin:6px 0 10px;color:#555;font-size:13px;">Choose a saved map to load from your company storage.</div>
          <select id="mapPick" style="width:100%;padding:8px 10px;border:1px solid #e1e5ea;border-radius:6px;font-size:13px;color:#333;margin-bottom:12px;"></select>
          <div style="display:flex;justify-content:flex-end;gap:8px;">
            <button id="pickCancel" style="background:#f3f4f6;border:1px solid #e5e7eb;color:#374151;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:13px;">Cancel</button>
            <button id="pickLoad" style="background:#3498db;border:1px solid #3498db;color:#fff;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:13px;">Load</button>
          </div>`;
        overlay.appendChild(card);
        document.body.appendChild(overlay);

        const close = ()=>{ try{ document.body.removeChild(overlay); }catch(_){} };
        card.querySelector('button[title="Close"]').onclick = close;
        card.querySelector('#pickCancel').onclick = close;
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) close(); });

        const sel = card.querySelector('#mapPick');
        // Sort by savedAt desc if available
        maps.sort((a,b)=>{
          const sa = a[1]?.savedAt || ''; const sb = b[1]?.savedAt || '';
          return (sb>sa) ? 1 : (sb<sa ? -1 : 0);
        });
        maps.forEach(([key,val])=>{
          const opt = document.createElement('option');
          const author = val?.savedByName || val?.savedBy || '';
          const by = author ? ` — by ${author}` : '';
          const at = val?.savedAt ? ` — ${new Date(val.savedAt).toLocaleString()}` : '';
          opt.value = key; opt.textContent = `${key}${at}${by}`;
          sel.appendChild(opt);
        });

        card.querySelector('#pickLoad').onclick = async ()=>{
          const chosen = sel.value;
          close();
          await loadCompany(chosen);
        };
      }catch(err){
        console.error('Picker failed:', err);
        alert('Could not open picker: ' + (err?.message||err));
      }
    }

    // ========== MAP UTILITIES: ERASE ALL & FIND CENTER ==========
    function eraseEverything(){
      const ok = confirm('This will remove all markers, camera coverages, fences, and areas from the map. Proceed?');
      if(!ok) return;
      try{
        // Stop any drawing modes
        try{ isDrawingFence = false; }catch(_){}
        try{ isDrawingArea = false; }catch(_){}
        if (typeof currentFencePolyline !== 'undefined' && currentFencePolyline) { try{ currentFencePolyline.remove(); }catch(_){} currentFencePolyline = null; }
        if (typeof currentAreaPolygon !== 'undefined' && currentAreaPolygon) { try{ currentAreaPolygon.remove(); }catch(_){} currentAreaPolygon = null; }
        if (typeof currentFencePoints !== 'undefined') currentFencePoints = [];
        if (typeof currentAreaPoints !== 'undefined') currentAreaPoints = [];

        // Remove all layer groups
        if (typeof layers === 'object' && layers) {
          try{ layers.posts.clearLayers(); }catch(_){}
          try{ layers.cameras.clearLayers(); }catch(_){}
          try{ layers.sensors.clearLayers(); }catch(_){}
          try{ layers.alarms.clearLayers(); }catch(_){}
          try{ layers.supervisors.clearLayers(); }catch(_){}
          try{ layers.fences.clearLayers(); }catch(_){}
          try{ layers.selections.clearLayers(); }catch(_){}
        }

        // Remove any direct layer refs on items and shapes
        try{
          (state.items||[]).forEach(it=>{ if(it.marker){ try{ it.marker.remove(); }catch(_){} it.marker = null; } });
          (state.shapes||[]).forEach(s=>{
            if(s.polygon){ try{ s.polygon.remove(); }catch(_){} s.polygon = null; }
            if(s.circle){ try{ s.circle.remove(); }catch(_){} s.circle = null; }
          });
        }catch(_){}

        // Reset state
        if (typeof state === 'object' && state) {
          state.items = [];
          state.shapes = [];
          state.fences = [];
          state.selections = [];
          state.nextId = 1;
        }
        try{ undoStack.length = 0; }catch(_){}
        try{ editingItemId = null; }catch(_){}
        alert('Map cleared.');
      }catch(err){
        console.error('Erase all failed:', err);
        alert('Failed to erase map: ' + (err?.message||err));
      }
    }

    let findCenterActive = false;
    let findCenterKeyHandler = null;
    function startFindCenterMode(){
      if(!window.map) { alert('Map not initialized'); return; }
      if(findCenterActive) { stopFindCenterMode(); return; }
      findCenterActive = true;
      alert('Find Center: Click near any element to center on it. Press ESC to cancel.');
      const onClick = (e)=>{ try{ handleFindCenterClick(e.latlng); }finally{ stopFindCenterMode(); } };
      // one-time map click
      map.once('click', onClick);
      // ESC to cancel
      findCenterKeyHandler = (ev)=>{ if(ev.key === 'Escape'){ stopFindCenterMode(); } };
      document.addEventListener('keydown', findCenterKeyHandler);
    }
    function stopFindCenterMode(){
      findCenterActive = false;
      try{ if(findCenterKeyHandler) document.removeEventListener('keydown', findCenterKeyHandler); }catch(_){}
      findCenterKeyHandler = null;
    }
    function handleFindCenterClick(latlng){
      const center = getNearestElementCenter(latlng);
      if(!center){ alert('No elements to center on.'); return; }
      try { map.flyTo(center, Math.max(map.getZoom(), 17), { duration: 0.6 }); } catch(_) { try{ map.setView(center, map.getZoom()); }catch(_){} }
      try{
        const pulse = L.circleMarker(center, { radius: 8, color:'#2c3e50', weight:2, fillColor:'#ffd54f', fillOpacity:0.8 });
        pulse.addTo(map);
        setTimeout(()=>{ try{ map.removeLayer(pulse); }catch(_){} }, 1200);
      }catch(_){}
    }
    function getNearestElementCenter(latlng){
      try{
        const candidates = [];
        // Items (markers)
        (state.items||[]).forEach(it=>{
          if(it && it.marker && typeof it.marker.getLatLng === 'function'){
            const c = it.marker.getLatLng();
            candidates.push(L.latLng(c.lat, c.lng));
          } else if (typeof it.lat === 'number' && typeof it.lng === 'number'){
            candidates.push(L.latLng(it.lat, it.lng));
          }
        });
        // Fences
        (state.fences||[]).forEach(f=>{
          if(f && f.polyline && typeof f.polyline.getBounds === 'function'){
            const b = f.polyline.getBounds();
            candidates.push(b.getCenter());
          } else if (Array.isArray(f?.points) && f.points.length){
            try{ const b = L.polyline(f.points).getBounds(); candidates.push(b.getCenter()); }catch(_){}
          }
        });
        // Areas
        (state.selections||[]).forEach(a=>{
          if(a && a.polygon && typeof a.polygon.getBounds === 'function'){
            const b = a.polygon.getBounds();
            candidates.push(b.getCenter());
          } else if (Array.isArray(a?.points) && a.points.length){
            try{ const b = L.polygon(a.points).getBounds(); candidates.push(b.getCenter()); }catch(_){}
          }
        });
        // Camera shapes
        (state.shapes||[]).forEach(s=>{
          if(s && s.kind === 'cameraSector'){
            if(s.polygon && typeof s.polygon.getBounds === 'function'){
              candidates.push(s.polygon.getBounds().getCenter());
            } else if (s.circle && typeof s.circle.getLatLng === 'function'){
              candidates.push(s.circle.getLatLng());
            } else if (Array.isArray(s.center) && s.center.length===2){
              candidates.push(L.latLng(s.center[0], s.center[1]));
            }
          }
        });
        if(!candidates.length) return null;
        let best = candidates[0]; let bestD = Infinity;
        candidates.forEach(c=>{ try{ const d = map.distance(latlng, c); if(d < bestD){ bestD = d; best = c; } }catch(_){} });
        return best;
      }catch(err){ console.warn('getNearestElementCenter failed', err); return null; }
    }
    // ========== END MAP UTILITIES ==========

    document.addEventListener('DOMContentLoaded', ()=>{
      initializeMenuAuthorization();
      initMap();
      const btnExport=document.getElementById('btnExportJson');
      const btnImport=document.getElementById('btnImportJson');
      const btnImportExcel=document.getElementById('btnImportExcel');
      const btnSave=document.getElementById('btnSaveCompany');
      const btnLoad=document.getElementById('btnLoadCompany');
  const btnShot=document.getElementById('btnScreenshot');
  const addBtn=document.getElementById('btnAddItem');
  const modal=document.getElementById('addItemModal');
  const modalClose=document.getElementById('addItemClose');
  const itemType=document.getElementById('itemType');
  const itemName=document.getElementById('itemName');
  const camType=document.getElementById('camType');
  const camHeight=document.getElementById('camHeight');
  const camRadius=document.getElementById('camRadius');
  const camAngle=document.getElementById('camAngle');
  const camHeading=document.getElementById('camHeading');
  const itemLatitude=document.getElementById('itemLatitude');
  const itemLongitude=document.getElementById('itemLongitude');
  const btnPlace=document.getElementById('btnPlaceOnMap');
  const btnAddNow=document.getElementById('btnAddNow');
  const btnAddAtCoords=document.getElementById('btnAddAtCoords');
      const sidebarToggle=document.getElementById('sidebarToggle');
      if(sidebarToggle){ sidebarToggle.addEventListener('click', ()=>{ const sidebar=document.getElementById('sidebar'); const main=document.getElementById('mainContent'); if(sidebar.classList.contains('open')){ sidebar.classList.remove('open'); sidebar.classList.add('collapsed'); main.classList.add('sidebar-collapsed'); } else { sidebar.classList.add('open'); sidebar.classList.remove('collapsed'); main.classList.remove('sidebar-collapsed'); } }); }

      // Function to calculate and update the radius display based on height and angle
      function updateCalculatedRadius() {
        const height = parseFloat(camHeight.value || '3.5');
        const angle = parseInt(camAngle.value || '70', 10);
        const camTypeValue = camType.value || 'fixed';
        const zoom = document.getElementById('camZoom').value || 'fixed';
        
        // Use the same calculation as in calculateEffectiveRadius
        const angleInRadians = (angle * Math.PI) / 180;
        const theoreticalRange = height / Math.tan(angleInRadians / 2);
        
        // Apply camera type multipliers
        let multiplier = 1.0;
        switch(camTypeValue) {
          case 'ptz': multiplier = 1.8; break;
          case 'thermal': multiplier = 2.2; break;
          case '360': multiplier = 0.7; break;
          case 'dome': multiplier = 0.95; break;
          case 'bullet': multiplier = 1.2; break;
          case 'fixed':
          default: multiplier = 1.0; break;
        }
        
        // Zoom capability multiplier
        const zoomMultiplier = {
          'fixed': 1.0, '3x': 1.3, '5x': 1.5, '10x': 2.0, '20x': 2.5, '30x': 3.0, 'digital': 1.1
        }[zoom] || 1.0;
        
        const environmentalFactor = 0.85;
        const calculatedRadius = theoreticalRange * multiplier * zoomMultiplier * environmentalFactor;
        
        // Ensure minimum and maximum ranges
        const minRange = height * 2;
        const maxRange = height * 50;
        const finalRadius = Math.round(Math.max(minRange, Math.min(maxRange, calculatedRadius)));
        
        // Update the radius display
        camRadius.value = finalRadius;
      }

      // Add event listeners to update radius when height, angle, camera type, or zoom changes
      if(camHeight) camHeight.addEventListener('input', updateCalculatedRadius);
      if(camAngle) camAngle.addEventListener('input', updateCalculatedRadius);
      if(camType) camType.addEventListener('change', updateCalculatedRadius);
      const camZoomElement = document.getElementById('camZoom');
      if(camZoomElement) camZoomElement.addEventListener('change', updateCalculatedRadius);
      
      // Initial calculation
      updateCalculatedRadius();
  let fileInput=document.getElementById('import-json-input');
      if(!fileInput){ fileInput=document.createElement('input'); fileInput.type='file'; fileInput.accept='application/json,.json'; fileInput.id='import-json-input'; fileInput.style.display='none'; document.body.appendChild(fileInput); }
      fileInput.addEventListener('change', (e)=>{ const f=e.target.files[0]; if(f) importJson(f); fileInput.value=''; });
      
      let excelFileInput=document.getElementById('import-excel-input');
      if(!excelFileInput){ excelFileInput=document.createElement('input'); excelFileInput.type='file'; excelFileInput.accept='.xlsx,.xls,.csv'; excelFileInput.id='import-excel-input'; excelFileInput.style.display='none'; document.body.appendChild(excelFileInput); }
      excelFileInput.addEventListener('change', (e)=>{ const f=e.target.files[0]; if(f) importExcel(f); excelFileInput.value=''; });
      
      if(btnExport) btnExport.addEventListener('click', exportJson);
      if(btnImport) btnImport.addEventListener('click', ()=> fileInput.click());
      if(btnImportExcel) btnImportExcel.addEventListener('click', showExcelHelp);
  if(btnSave) btnSave.addEventListener('click', saveCompany);
  if(btnLoad) btnLoad.addEventListener('click', openLoadCompanyPicker);
      if(btnShot) btnShot.addEventListener('click', async ()=>{ const node=document.getElementById('securityMap'); const canvas=await html2canvas(node); const url=canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='site-map.png'; a.click(); });
      
      // Add fence drawing button event listener
      const btnDrawFence = document.getElementById('btnDrawFence');
      if(btnDrawFence) btnDrawFence.addEventListener('click', toggleFenceDrawing);
  const btnDrawArea = document.getElementById('btnDrawArea');
  if(btnDrawArea) btnDrawArea.addEventListener('click', toggleAreaDrawing);
  const btnAnalyzeAll = document.getElementById('btnAnalyzeAll');
  if (btnAnalyzeAll) btnAnalyzeAll.addEventListener('click', openAnalyzeAllModal);
  const btnUndo = document.getElementById('btnUndo');
  if(btnUndo) btnUndo.addEventListener('click', undoLastAction);
  const btnEraseAll = document.getElementById('btnEraseAll');
  if(btnEraseAll) btnEraseAll.addEventListener('click', eraseEverything);
  const btnFindCenter = document.getElementById('btnFindCenter');
  if(btnFindCenter) btnFindCenter.addEventListener('click', startFindCenterMode);

      const showCameraFields = () => {
        document.querySelectorAll('.camera-only').forEach(el=>{
          el.style.display = (itemType.value === 'camera') ? '' : 'none';
        });
      };
      showCameraFields();
      itemType.addEventListener('change', showCameraFields);

      const openModal = () => { 
        // Reset modal to add mode
        editingItemId = null;
        document.getElementById('addItemTitle').textContent = 'Add Security Element';
        document.getElementById('btnAddNow').innerHTML = '<i class="fas fa-plus"></i> Add Here (center)';
        document.getElementById('btnAddAtCoords').innerHTML = '<i class="fas fa-crosshairs"></i> Add at Coordinates';
        
        // Clear form fields
        document.getElementById('itemType').value = 'camera';
        document.getElementById('itemName').value = '';
        document.getElementById('camType').value = 'fixed';
        document.getElementById('camHeight').value = '3.5';
        document.getElementById('camResolution').value = '1080p';
        document.getElementById('camEnvironmentalResistance').value = 'ip65';
        document.getElementById('camPowerMode').value = 'poe';
        document.getElementById('camAudioOutput').value = 'none';
        document.getElementById('camMinIllumination').value = '0.1';
        document.getElementById('camZoom').value = 'fixed';
        document.getElementById('camRadius').value = '80';
        document.getElementById('camAngle').value = '70';
        document.getElementById('camHeading').value = '45';
        
        modal.classList.add('show'); 
        // Pre-populate coordinates with current map center
        const center = map.getCenter();
        if (itemLatitude) itemLatitude.value = center.lat.toFixed(6);
        if (itemLongitude) itemLongitude.value = center.lng.toFixed(6);
        
        showCameraFields();
        
        // Update calculated radius for new cameras
        if (typeof updateCalculatedRadius === 'function') {
          updateCalculatedRadius();
        }
      };
      
      const closeModal = () => { 
        modal.classList.remove('show'); 
        editingItemId = null;
      };
      if(addBtn) addBtn.addEventListener('click', openModal);
      if(modalClose) modalClose.addEventListener('click', closeModal);
      modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });

      // Excel help modal handlers
      const excelHelpModal = document.getElementById('excelHelpModal');
      const excelHelpClose = document.getElementById('excelHelpClose');
      const excelHelpOk = document.getElementById('excelHelpOk');
      const downloadTemplate = document.getElementById('downloadTemplate');
      const doExcelImport = document.getElementById('doExcelImport');
      
      if(excelHelpClose) excelHelpClose.addEventListener('click', () => excelHelpModal.classList.remove('show'));
      if(excelHelpOk) excelHelpOk.addEventListener('click', () => excelHelpModal.classList.remove('show'));
      if(downloadTemplate) downloadTemplate.addEventListener('click', downloadExcelTemplate);
      if(doExcelImport) doExcelImport.addEventListener('click', () => {
        excelHelpModal.classList.remove('show');
        excelFileInput.click();
      });
      excelHelpModal.addEventListener('click', (e) => { if(e.target === excelHelpModal) excelHelpModal.classList.remove('show'); });

      let placingMode = false;
      if(btnPlace) btnPlace.addEventListener('click', ()=>{ 
        // Disallow place-on-map for camera edits; enforce GPS coordinate updates
        const t = itemType.value;
        if (editingItemId && t === 'camera') {
          alert('Move cameras by editing GPS coordinates only.');
          return;
        }
        console.log('Place on Map clicked'); 
        placingMode = true; 
        closeModal(); 
        console.log('Placing mode set to:', placingMode);
      });
      if(btnAddNow) btnAddNow.addEventListener('click', ()=>{
        const center = map.getCenter();
        const type = itemType.value;
        const name = itemName.value || defaultNameFor(type);
        
        if (editingItemId) {
          // Edit mode - update existing item without changing position
          const item = state.items.find(i => i.id === editingItemId);
          if (item) {
            const oldType = item.type;
            const oldPosition = { lat: item.lat, lng: item.lng };
            item.data.name = name;
            
            // Handle type change: move marker to appropriate layer and manage coverage
            if (type !== oldType) {
              // Remove old marker
              if (item.marker) item.marker.remove();
              
              // Remove old coverage if converting from camera
              if (oldType === 'camera') {
                const existingShapes = state.shapes.filter(s => s.kind === 'cameraSector' && s.cameraId === editingItemId);
                existingShapes.forEach(shape => { if (shape.polygon) layers.cameras.removeLayer(shape.polygon); });
                state.shapes = state.shapes.filter(s => !(s.kind === 'cameraSector' && s.cameraId === editingItemId));
              }
              
              // Add new marker of the new type at same coordinates
              const newMarker = addMarker(type, oldPosition, { name }, editingItemId);
              item.marker = newMarker;
              item.type = type;
              
              // If converting to camera, create coverage from current form specs
              if (type === 'camera') {
                const cameraOptions = {
                  camType: camType.value || 'fixed',
                  height: parseFloat(camHeight.value || '3.5'),
                  resolution: document.getElementById('camResolution').value || '1080p',
                  environmentalResistance: document.getElementById('camEnvironmentalResistance').value || 'ip65',
                  powerMode: document.getElementById('camPowerMode').value || 'poe',
                  audioOutput: document.getElementById('camAudioOutput').value || 'none',
                  minIllumination: document.getElementById('camMinIllumination').value || '0.1',
                  zoom: document.getElementById('camZoom').value || 'fixed',
                  radius: parseInt(camRadius.value || '80', 10),
                  angle: parseInt(camAngle.value || '70', 10),
                  heading: parseInt(camHeading.value || '45', 10)
                };
                addCameraCoverage([oldPosition.lat, oldPosition.lng], cameraOptions, editingItemId, editingItemId);
              }
            } else {
              // Same type: refresh marker popup and, if camera, rebuild coverage with new specs
              if (item.marker) {
                updateMarkerPopup(item.marker, type, oldPosition, item.data, editingItemId);
              }
              if (type === 'camera') {
                const cameraOptions = {
                  camType: camType.value || 'fixed',
                  height: parseFloat(camHeight.value || '3.5'),
                  resolution: document.getElementById('camResolution').value || '1080p',
                  environmentalResistance: document.getElementById('camEnvironmentalResistance').value || 'ip65',
                  powerMode: document.getElementById('camPowerMode').value || 'poe',
                  audioOutput: document.getElementById('camAudioOutput').value || 'none',
                  minIllumination: document.getElementById('camMinIllumination').value || '0.1',
                  zoom: document.getElementById('camZoom').value || 'fixed',
                  radius: parseInt(camRadius.value || '80', 10),
                  angle: parseInt(camAngle.value || '70', 10),
                  heading: parseInt(camHeading.value || '45', 10)
                };
                
                // Complete cleanup and replacement approach to prevent duplication
                
                // Find and remove ALL existing coverage shapes for this camera
                const existingShapes = state.shapes.filter(s => 
                  (s.kind === 'cameraSector' || s.kind === 'camera') && 
                  (s.cameraId === editingItemId || s.id === editingItemId)
                );
                
                // Remove from map layers
                existingShapes.forEach(shape => {
                  if (shape.polygon) layers.cameras.removeLayer(shape.polygon);
                  if (shape.circle) layers.cameras.removeLayer(shape.circle);
                  if (shape.sector) layers.cameras.removeLayer(shape.sector);
                });
                
                // Remove from state completely
                state.shapes = state.shapes.filter(s => 
                  !((s.kind === 'cameraSector' || s.kind === 'camera') && 
                    (s.cameraId === editingItemId || s.id === editingItemId))
                );
                
                // Create completely new coverage with new ID to avoid any ID conflicts
                addCameraCoverage([oldPosition.lat, oldPosition.lng], cameraOptions, null, editingItemId);
              }
            }
            console.log(`Updated ${type} ${editingItemId} at ${oldPosition.lat},${oldPosition.lng}`);
          }
        } else {
          // Add mode - create new item
          const newMarker = addMarker(type, center, { name });
          if(type==='camera'){
            addCameraCoverage([center.lat, center.lng], { 
              camType: camType.value||'fixed',
              height: parseFloat(camHeight.value||'3.5'),
              resolution: document.getElementById('camResolution').value||'1080p',
              environmentalResistance: document.getElementById('camEnvironmentalResistance').value||'ip65',
              powerMode: document.getElementById('camPowerMode').value||'poe',
              audioOutput: document.getElementById('camAudioOutput').value||'none',
              minIllumination: document.getElementById('camMinIllumination').value||'0.1',
              zoom: document.getElementById('camZoom').value||'fixed',
              radius: parseInt(camRadius.value||'80',10), 
              angle: parseInt(camAngle.value||'70',10), 
              heading: parseInt(camHeading.value||'45',10) 
            }, null, newMarker && newMarker._itemId ? newMarker._itemId : null);
          }
        }
        closeModal();
      });

      if(btnAddAtCoords) btnAddAtCoords.addEventListener('click', ()=>{
        const lat = parseFloat(itemLatitude.value);
        const lng = parseFloat(itemLongitude.value);
        
        // Validate coordinates
        if (isNaN(lat) || isNaN(lng)) {
          alert('Please enter valid latitude and longitude coordinates.');
          return;
        }
        
        if (lat < -90 || lat > 90) {
          alert('Latitude must be between -90 and 90 degrees.');
          return;
        }
        
        if (lng < -180 || lng > 180) {
          alert('Longitude must be between -180 and 180 degrees.');
          return;
        }
        
        const type = itemType.value;
        const name = itemName.value || defaultNameFor(type);
        const latlng = { lat, lng };
        
        if (editingItemId) {
          // Edit mode - update existing item
          const item = state.items.find(i => i.id === editingItemId);
          if (item) {
            const oldPosition = { lat: item.lat, lng: item.lng };
            const newPosition = { lat, lng };
            
            // Remove old marker
            if (item.marker) item.marker.remove();
            
            // Update item coordinates
            item.lat = lat;
            item.lng = lng;
            item.data.name = name;
            
            // Add updated marker at new position
            const newMarker = addMarker(type, latlng, { name }, editingItemId);
            item.marker = newMarker;
            
            // For cameras, update all coverage and specifications
            if (type === 'camera') {
              // Update camera coverage using the comprehensive update function
              updateCameraCoverage(editingItemId, newPosition);
              
              // Also update with any new specifications from the modal
              const cameraOptions = {
                camType: camType.value || 'fixed',
                height: parseFloat(camHeight.value || '3.5'),
                resolution: document.getElementById('camResolution').value || '1080p',
                environmentalResistance: document.getElementById('camEnvironmentalResistance').value || 'ip65',
                powerMode: document.getElementById('camPowerMode').value || 'poe',
                audioOutput: document.getElementById('camAudioOutput').value || 'none',
                minIllumination: document.getElementById('camMinIllumination').value || '0.1',
                zoom: document.getElementById('camZoom').value || 'fixed',
                radius: parseInt(camRadius.value || '80', 10),
                angle: parseInt(camAngle.value || '70', 10),
                heading: parseInt(camHeading.value || '45', 10)
              };
              
              // If position changed significantly or specs changed, recreate coverage completely
              const positionChanged = Math.abs(oldPosition.lat - newPosition.lat) > 0.00001 || 
                                    Math.abs(oldPosition.lng - newPosition.lng) > 0.00001;
              
              if (positionChanged) {
                console.log('Position changed significantly, recreating camera coverage');
                // Remove any existing coverage first
                const existingShapes = state.shapes.filter(s => 
                  (s.kind === 'cameraSector' || s.kind === 'camera') && 
                  (s.cameraId === editingItemId || s.id === editingItemId)
                );
                
                let existingShapeId = null;
                existingShapes.forEach(shape => {
                  if (!existingShapeId) existingShapeId = shape.id; // Use first shape's ID for replacement
                  if (shape.polygon) layers.cameras.removeLayer(shape.polygon);
                  if (shape.circle) layers.cameras.removeLayer(shape.circle);
                  if (shape.sector) layers.cameras.removeLayer(shape.sector);
                });
                
                // Remove from state
                state.shapes = state.shapes.filter(s => 
                  !((s.kind === 'cameraSector' || s.kind === 'camera') && 
                    (s.cameraId === editingItemId || s.id === editingItemId))
                );
                
                // Create new coverage with updated specs, reusing existing shape ID if available
                addCameraCoverage(newPosition, cameraOptions, existingShapeId, editingItemId);
              }
            }
            
            console.log(`Updated ${type} ${editingItemId} from ${oldPosition.lat},${oldPosition.lng} to map center ${newPosition.lat},${newPosition.lng}`);
          }
        } else {
          // Add mode - create new item
          const newMarker = addMarker(type, { lat, lng }, { name });
          if(type==='camera'){
            addCameraCoverage([lat, lng], { 
              camType: camType.value||'fixed',
              height: parseFloat(camHeight.value||'3.5'),
              resolution: document.getElementById('camResolution').value||'1080p',
              environmentalResistance: document.getElementById('camEnvironmentalResistance').value||'ip65',
              powerMode: document.getElementById('camPowerMode').value||'poe',
              audioOutput: document.getElementById('camAudioOutput').value||'none',
              minIllumination: document.getElementById('camMinIllumination').value||'0.1',
              zoom: document.getElementById('camZoom').value||'fixed',
              radius: parseInt(camRadius.value||'80',10), 
              angle: parseInt(camAngle.value||'70',10), 
              heading: parseInt(camHeading.value||'45',10) 
            }, null, newMarker && newMarker._itemId ? newMarker._itemId : null);
          }
        }
        
        // Pan map to the location
        map.setView([lat, lng], map.getZoom());
        
        closeModal();
      });

      function defaultNameFor(type){
        const prefix = type==='camera'?'CAM': type==='agent-post'?'POST': type==='sensor'?'SENS': type==='alarm'?'ALRM':'SUPV';
        return prefix + (state.items.length+1);
      }

      function placeItemAtLatLng(latlng){
        const type = itemType.value;
        const name = itemName.value || defaultNameFor(type);
        if (editingItemId) {
          const item = state.items.find(i => i.id === editingItemId);
          if (item) {
            if (item.marker) item.marker.remove();
            if (item.type === 'camera') {
              const shapes = state.shapes.filter(s => s.kind === 'cameraSector' && (s.cameraId === editingItemId || (
                Math.abs((s.center?.[0]||0) - item.lat) < 0.000001 && Math.abs((s.center?.[1]||0) - item.lng) < 0.000001
              )));
              shapes.forEach(s => { if (s.polygon) s.polygon.remove(); });
              state.shapes = state.shapes.filter(s => !(s.kind === 'cameraSector' && s.cameraId === editingItemId));
            }
            addMarker(type, latlng, { name }, editingItemId);
            if(type==='camera'){
              addCameraCoverage([latlng.lat, latlng.lng], { 
                camType: camType.value||'fixed',
                height: parseFloat(camHeight.value||'3.5'),
                resolution: document.getElementById('camResolution').value||'1080p',
                environmentalResistance: document.getElementById('camEnvironmentalResistance').value||'ip65',
                powerMode: document.getElementById('camPowerMode').value||'poe',
                audioOutput: document.getElementById('camAudioOutput').value||'none',
                minIllumination: document.getElementById('camMinIllumination').value||'0.1',
                zoom: document.getElementById('camZoom').value||'fixed',
                radius: parseInt(camRadius.value||'80',10), 
                angle: parseInt(camAngle.value||'70',10), 
                heading: parseInt(camHeading.value||'45',10) 
              }, null, editingItemId);
            }
          }
        } else {
          const newMarker = addMarker(type, latlng, { name });
          if(type==='camera'){
            addCameraCoverage([latlng.lat, latlng.lng], { 
              camType: camType.value||'fixed',
              height: parseFloat(camHeight.value||'3.5'),
              resolution: document.getElementById('camResolution').value||'1080p',
              environmentalResistance: document.getElementById('camEnvironmentalResistance').value||'ip65',
              powerMode: document.getElementById('camPowerMode').value||'poe',
              audioOutput: document.getElementById('camAudioOutput').value||'none',
              minIllumination: document.getElementById('camMinIllumination').value||'0.1',
              zoom: document.getElementById('camZoom').value||'fixed',
              radius: parseInt(camRadius.value||'80',10), 
              angle: parseInt(camAngle.value||'70',10), 
              heading: parseInt(camHeading.value||'45',10) 
            }, null, newMarker && newMarker._itemId ? newMarker._itemId : null);
          }
        }
      }

      function attachPlacementAwareClick(layer){
        if(!layer || typeof layer.on !== 'function') return;
        layer.on('click', (ev)=>{
          if(!placingMode) return; // allow normal behavior when not placing
          if (ev && ev.originalEvent) {
            try { if (window.L && L.DomEvent && typeof L.DomEvent.stop === 'function') { L.DomEvent.stop(ev.originalEvent); } } catch(_) {}
            try { ev.originalEvent.stopPropagation && ev.originalEvent.stopPropagation(); } catch(_) {}
            try { ev.originalEvent.preventDefault && ev.originalEvent.preventDefault(); } catch(_) {}
          }
          placingMode = false;
          placeItemAtLatLng(ev.latlng);
          // Ensure popups don't open during placement
          if(layer.closePopup) try{ layer.closePopup(); }catch(_){ }
        });
      }

      map.on('click', (e)=>{
        console.log('Map clicked. Fence mode:', isDrawingFence, 'Area mode:', isDrawingArea, 'Placing mode:', placingMode);
        
        // Handle area drawing first
        if (isDrawingArea) {
          onAreaClick(e);
          return;
        }
        
        // Then handle fence drawing
        if(isDrawingFence) {
          onFenceClick(e);
          return;
        }
        
        // Handle camera/security element placement
        if(!placingMode) return;
        console.log('Processing camera placement');
        placingMode = false;
        const type = itemType.value;
        const name = itemName.value || defaultNameFor(type);
        
        if (editingItemId) {
          // Edit mode - update existing item
          const item = state.items.find(i => i.id === editingItemId);
          if (item) {
            // Remove old marker and camera coverage
            if (item.marker) item.marker.remove();
            if (item.type === 'camera') {
              const shapes = state.shapes.filter(s => s.kind === 'cameraSector' && (s.cameraId === editingItemId || (
                Math.abs((s.center?.[0]||0) - item.lat) < 0.000001 && Math.abs((s.center?.[1]||0) - item.lng) < 0.000001
              )));
              shapes.forEach(s => { if (s.polygon) s.polygon.remove(); });
              state.shapes = state.shapes.filter(s => !(s.kind === 'cameraSector' && s.cameraId === editingItemId));
            }
            
            // Add updated marker
            addMarker(type, e.latlng, { name }, editingItemId);
            if(type==='camera'){
              addCameraCoverage([e.latlng.lat, e.latlng.lng], { 
                camType: camType.value||'fixed',
                height: parseFloat(camHeight.value||'3.5'),
                resolution: document.getElementById('camResolution').value||'1080p',
                environmentalResistance: document.getElementById('camEnvironmentalResistance').value||'ip65',
                powerMode: document.getElementById('camPowerMode').value||'poe',
                audioOutput: document.getElementById('camAudioOutput').value||'none',
                minIllumination: document.getElementById('camMinIllumination').value||'0.1',
                zoom: document.getElementById('camZoom').value||'fixed',
                radius: parseInt(camRadius.value||'80',10), 
                angle: parseInt(camAngle.value||'70',10), 
                heading: parseInt(camHeading.value||'45',10) 
              }, null, editingItemId);
            }
          }
        } else {
          // Add mode - create new item
          const newMarker = addMarker(type, e.latlng, { name });
          if(type==='camera'){
            addCameraCoverage([e.latlng.lat, e.latlng.lng], { 
              camType: camType.value||'fixed',
              height: parseFloat(camHeight.value||'3.5'),
              resolution: document.getElementById('camResolution').value||'1080p',
              environmentalResistance: document.getElementById('camEnvironmentalResistance').value||'ip65',
              powerMode: document.getElementById('camPowerMode').value||'poe',
              audioOutput: document.getElementById('camAudioOutput').value||'none',
              minIllumination: document.getElementById('camMinIllumination').value||'0.1',
              zoom: document.getElementById('camZoom').value||'fixed',
              radius: parseInt(camRadius.value||'80',10), 
              angle: parseInt(camAngle.value||'70',10), 
              heading: parseInt(camHeading.value||'45',10) 
            }, null, newMarker && newMarker._itemId ? newMarker._itemId : null);
          }
        }
      });

      // Right-click to get coordinates
      map.on('contextmenu', (e)=>{
        const lat = e.latlng.lat.toFixed(6);
        const lng = e.latlng.lng.toFixed(6);
        
        // Show coordinates in a popup
        const popup = L.popup()
          .setLatLng(e.latlng)
          .setContent(`
            <div style="text-align: center;">
              <strong>Coordinates</strong><br>
              Lat: ${lat}<br>
              Lng: ${lng}<br>
              <button onclick="copyToClipboard('${lat}, ${lng}')" style="margin-top: 5px; padding: 3px 8px; font-size: 12px;">Copy</button>
              <button onclick="fillModalCoords(${lat}, ${lng})" style="margin-top: 5px; padding: 3px 8px; font-size: 12px;">Use in Form</button>
            </div>
          `)
          .openOn(map);
      });

      // Helper functions for coordinate popup
      window.copyToClipboard = function(text) {
        navigator.clipboard.writeText(text).then(() => {
          console.log('Coordinates copied to clipboard');
        });
      };

      window.fillModalCoords = function(lat, lng) {
        if (itemLatitude) itemLatitude.value = lat;
        if (itemLongitude) itemLongitude.value = lng;
        map.closePopup();
        if (!modal.classList.contains('show')) {
          openModal();
        }
      };
    });
  </script>
</body>
</html>
