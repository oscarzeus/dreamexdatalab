<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>NFC Card Reader - Dreamex Datalab</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
<!-- Firebase v8 Scripts for Centralized Authentication -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    
<style>
:root { --primary-color:#2c3e50; --secondary-color:#34495e; --accent-color:#e74c3c; --success-color:#27ae60; --warning-color:#f39c12; --info-color:#3498db; --light-color:#ecf0f1; --dark-color:#2c3e50; --sidebar-width:250px; --transition-speed:.25s; --blue: #3498db; --green: #2ecc71; --purple: #9b59b6; --orange: #e67e22; --red: #e74c3c; --text-secondary: #666666; --border-color: #e0e0e0; }
* { box-sizing:border-box; margin:0; padding:0; }
body { font-family: 'Segoe UI', Arial, sans-serif; background:#f5f7fa; color:#222; }
.app-container { display:flex; min-height:100vh; }
.sidebar { width:var(--sidebar-width); background:var(--primary-color); color:#fff; padding:1rem; position:fixed; top:0; left:0; bottom:0; overflow-y:auto; transition:transform .3s ease; z-index:1000; }
.sidebar.collapsed { transform:translateX(-100%); }
.main-content { flex:1; margin-left:var(--sidebar-width); padding:0.3rem; padding-top:3.2rem; transition:margin-left .3s ease; }
.main-content.sidebar-collapsed { margin-left:0; }
.main-content.sidebar-collapsed .top-nav { left:0.5rem; }
.logo h2 { text-align:center; padding:1rem 0; border-bottom:1px solid rgba(255,255,255,0.1); font-size:1.05rem; letter-spacing:.5px; }
.menu { list-style:none; margin-top:2rem; }
.menu li { margin-bottom:0.45rem; }
.menu a { display:flex; align-items:center; gap:10px; color:#fff; text-decoration:none; padding:0.6rem 0.75rem; border-radius:6px; font-size:0.82rem; font-weight:500; transition:background .25s; }
.menu a:hover, .menu a.active { background:rgba(255,255,255,0.12); }
.submenu { list-style:none; margin-left:0.75rem; display:none; margin-top:0.25rem; }
.menu-dropdown:hover .submenu { display:block; }
.submenu a { font-size:0.75rem; padding:0.45rem 0.65rem; }
[data-feature]:not(.menu-visible) { display:none !important; }
.menu-dropdown:not(.menu-visible) { display:none !important; }

/* Hide ALL menu items by default during loading */
.sidebar.menu-loading .menu-item,
.sidebar.menu-loading .menu-dropdown,
.sidebar.menu-loading li[data-feature],
.sidebar.menu-loading [data-feature] {
    display: none !important;
}

/* Allow menu-visible items to show even during loading */
.sidebar.menu-loading .menu-visible,
.sidebar.menu-loading li.menu-visible,
.sidebar.menu-loading [data-feature].menu-visible {
    display: block !important;
}

.menu-loading [data-feature] {
    display: none !important;
}

.menu-loading .menu-dropdown {
    display: none !important;
}

/* Ensure menu-visible items are always shown */
.menu-visible {
    display: block !important;
}

li.menu-visible,
[data-feature].menu-visible {
    display: block !important;
}
.top-nav { display:flex; justify-content:space-between; align-items:center; padding:0.5rem 0.75rem; background-color:#fff; box-shadow:0 2px 5px rgba(0,0,0,0.1); margin-bottom:0.3rem; position:fixed; top:0.25rem; right:0.5rem; left:calc(var(--sidebar-width) + 0.5rem); height:50px; min-height:50px; z-index:100; transition:left 0.3s ease; }
.sidebar-toggle-btn { background:none; border:none; cursor:pointer; font-size:1.1rem; padding:0.4rem; color:#555; }
.top-nav-left { display:flex; align-items:center; gap:0.75rem; }
.company-branding { display:flex; align-items:center; gap:0.5rem; }
#headerCompanyLogo { width:32px; height:32px; object-fit:contain; display:none; }
#headerCompanyName { font-weight:600; font-size:0.85rem; }
.header-company-logo { height:32px; width:auto; border-radius:6px; box-shadow:0 2px 4px rgba(0,0,0,0.1); }
.company-name-header { font-weight:700; color:var(--dark-color); font-size:1rem; letter-spacing:0.5px; white-space:nowrap; }
.top-nav-right { display:flex; align-items:center; gap:1rem; }
.notifications { position:relative; display:flex; align-items:center; }
.notification-btn { background:none; border:none; cursor:pointer; position:relative; font-size:1.2rem; padding:0.5rem; display:flex; align-items:center; justify-content:center; }
.notification-badge { position:absolute; top:-5px; right:-5px; background-color:var(--accent-color); color:white; border-radius:50%; padding:0.2rem 0.5rem; font-size:0.7rem; display:none; }
.notification-dropdown { display:none; position:absolute; right:0; top:100%; width:320px; background:#fff; border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.15); z-index:1000; border:1px solid #e9ecef; max-height:400px; overflow:hidden; }
.notification-dropdown.show { display:block; animation: slideDown 0.2s ease-out; }
@keyframes slideDown { from { opacity:0; transform:translateY(-10px);} to { opacity:1; transform:translateY(0);} }
.notification-header { padding:12px 16px; border-bottom:1px solid #e9ecef; background:linear-gradient(135deg,#f8f9fa 0%, #e9ecef 100%); display:flex; justify-content:space-between; align-items:center; }
.notification-header h3 { margin:0; color:#333; font-size:14px; font-weight:600; }
.mark-all-read { background:none; border:none; color:#3498db; cursor:pointer; font-size:12px; padding:4px 8px; border-radius:4px; transition:all .2s ease; }
.mark-all-read:hover { background:#e3f2fd; color:#1976d2; }
.notification-list { max-height:320px; overflow-y:auto; padding:0; }
.notification-item { padding:12px 16px; border-bottom:1px solid #f1f1f1; cursor:pointer; transition:background-color .2s ease; position:relative; }
.notification-item:hover { background:#f8f9fa; }
.notification-item.unread { background:#e8f4fd; border-left:3px solid #3498db; }
.notification-empty { padding:40px 20px; text-align:center; color:#999; display:none; }
.notification-empty i { font-size:32px; margin-bottom:12px; color:#ddd; }
.user-profile { position:relative; }
.profile-btn { background:none; border:none; border-radius:50%; overflow:hidden; width:38px; height:38px; cursor:pointer; }
.profile-btn img { width:100%; height:100%; object-fit:cover; }
.profile-dropdown { display:none; position:absolute; right:0; top:110%; background:#fff; border-radius:8px; min-width:200px; box-shadow:0 6px 18px rgba(0,0,0,0.12); overflow:hidden; }
.profile-dropdown.show { display:block; }
.profile-dropdown ul { list-style:none; }
.profile-dropdown li a { display:block; padding:0.65rem 0.85rem; font-size:0.72rem; text-decoration:none; color:#1e293b; font-weight:500; }
.profile-dropdown li a:hover { background:#f1f5f9; }
.page-header { 
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); 
    color: #fff; 
    padding: 0.55rem 0.75rem; 
    margin: 0.35rem 0 0.5rem 0; 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
    box-shadow: 0 10px 28px rgba(0,0,0,0.18), 0 6px 16px rgba(0,0,0,0.14); 
    font-size: 0.9rem; 
}
.page-header h1 { 
    color: #fff; 
    font-size: 0.9rem; 
    display: flex; 
    align-items: center; 
    gap: 0.5rem; 
    letter-spacing: 0.5px; 
    margin: 0; 
    font-weight: 600; 
}
.page-header i { 
    font-size: 1rem; 
}

@media (max-width: 900px) { 
    .main-content { 
        margin-left: 0; 
    } 
    .sidebar { 
        transform: translateX(-100%); 
    } 
    .sidebar.open { 
        transform: translateX(0); 
    } 
    .top-nav { 
        left: 0.5rem; 
    }
}

        /* NFC Reader Section */
        .nfc-container {
            width: 100%;
            max-width: 100%;
        }

        .nfc-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
        }

        .nfc-card h2 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Scanner Section */
        .scanner-section {
            text-align: center;
        }

        .nfc-icon-container {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 2rem auto;
        }

        .nfc-icon {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5rem;
            color: white;
            position: relative;
            z-index: 2;
        }

        .nfc-icon.scanning {
            animation: pulse 1.5s infinite;
        }

        .pulse-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid var(--secondary-color);
            opacity: 0;
        }

        .scanning .pulse-ring {
            animation: pulse-ring 1.5s infinite;
        }

        .pulse-ring:nth-child(2) {
            animation-delay: 0.5s;
        }

        .pulse-ring:nth-child(3) {
            animation-delay: 1s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes pulse-ring {
            0% {
                width: 100%;
                height: 100%;
                opacity: 1;
            }
            100% {
                width: 200%;
                height: 200%;
                opacity: 0;
            }
        }

        .scan-status {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin: 1.5rem 0;
        }

        .scan-status.active {
            color: var(--green);
            font-weight: 600;
        }

        .scan-status.error {
            color: var(--red);
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background: var(--red);
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        /* NFC Tool Cards */
        .nfc-tool-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .nfc-tool-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
        }

        .nfc-tool-card:active {
            transform: translateY(0);
        }

        /* Data Display Section */
        .data-section h2 {
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.75rem;
        }

        .no-data {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .no-data i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .nfc-data-list {
            margin-top: 1rem;
        }

        .data-item {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            border-left: 4px solid var(--secondary-color);
        }

        .data-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .data-item-type {
            background: var(--secondary-color);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .data-item-label {
            font-weight: 600;
            color: var(--primary-color);
        }

        .data-item-content {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            font-family: monospace;
            word-break: break-all;
            margin-top: 0.5rem;
        }

        .data-item-content a {
            color: var(--secondary-color);
            text-decoration: none;
        }

        .data-item-content a:hover {
            text-decoration: underline;
        }

        /* Raw Data Section */
        .raw-data {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
        }

        .raw-data pre {
            margin: 0;
            white-space: pre-wrap;
        }

        /* Serial Number Display */
        .serial-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .serial-number h3 {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 0.5rem;
        }

        .serial-number .serial-value {
            font-size: 1.5rem;
            font-family: monospace;
            letter-spacing: 2px;
            font-weight: bold;
        }

        /* Browser Support Warning */
        .browser-warning {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            color: #333;
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
        }

        .browser-warning h3 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .browser-warning ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .browser-warning li {
            margin-bottom: 0.25rem;
        }

        /* History Section */
        .history-section {
            margin-top: 2rem;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .history-item:hover {
            background: #e8f4fc;
            transform: translateX(5px);
        }

        .history-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }

            .main-content {
                margin-left: 0;
                width: 100%;
                padding: 1rem;
            }

            .nfc-icon-container {
                width: 150px;
                height: 150px;
            }

            .nfc-icon {
                font-size: 3.5rem;
            }
        }

        /* Copy Button */
        .copy-btn {
            background: none;
            border: none;
            color: var(--secondary-color);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 0.9rem;
        }

        .copy-btn:hover {
            color: var(--primary-color);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .tab-btn {
            padding: 0.5rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            border-radius: 5px 5px 0 0;
            transition: all 0.2s ease;
        }

        .tab-btn.active {
            color: var(--secondary-color);
            background: rgba(52, 152, 219, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Main Tab Navigation (accessboard style) */
        .main-tab-nav {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 1.5rem;
            background: var(--bg-primary);
            padding: 0 1rem;
        }

        .main-tab-btn {
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6b7280;
            background: transparent;
            border: none;
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .main-tab-btn:hover {
            color: #111827;
        }

        .main-tab-btn.active {
            color: var(--primary-color);
            font-weight: 600;
        }

        .main-tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--primary-color);
        }

        .main-tab-content {
            display: none;
        }

        .main-tab-content.active {
            display: block;
        }

        /* Record History Table */
        .record-table-container {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .record-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .record-table th {
            background: var(--bg-secondary);
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border-color);
        }

        .record-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .record-table tr:hover {
            background: var(--bg-secondary);
        }

        .record-table .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .record-table .badge-success {
            background: rgba(46, 204, 113, 0.15);
            color: #27ae60;
        }

        .record-table .badge-info {
            background: rgba(52, 152, 219, 0.15);
            color: #3498db;
        }

        .record-table .badge-warning {
            background: rgba(241, 196, 15, 0.15);
            color: #f39c12;
        }

        .record-empty {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .record-empty i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Write Section Styles */
        .write-section {
            margin-top: 2rem;
        }

        .mode-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            background: var(--bg-secondary);
            padding: 0.5rem;
            border-radius: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            border-radius: 8px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .mode-btn.active {
            background: white;
            color: var(--secondary-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.5);
        }

        .write-form {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 10px;
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--secondary-color);
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-group small {
            display: block;
            margin-top: 0.25rem;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .record-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .record-type-btn {
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            background: white;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .record-type-btn:hover {
            border-color: var(--secondary-color);
        }

        .record-type-btn.active {
            border-color: var(--secondary-color);
            background: rgba(52, 152, 219, 0.1);
            color: var(--secondary-color);
        }

        .record-type-btn i {
            display: block;
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .record-type-btn span {
            font-size: 0.8rem;
            font-weight: 600;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--green), #27ae60);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .btn-success:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .write-status {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            display: none;
        }

        .write-status.success {
            display: block;
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid var(--green);
            color: var(--green);
        }

        .write-status.error {
            display: block;
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid var(--red);
            color: var(--red);
        }

        .write-status.writing {
            display: block;
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid var(--secondary-color);
            color: var(--secondary-color);
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            background: var(--bg-secondary);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: var(--danger-color);
        }

        /* Multiple Records */
        .records-container {
            margin-top: 1rem;
        }

        .record-item {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            position: relative;
        }

        .record-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .record-item-title {
            font-weight: 600;
            color: var(--primary-color);
        }

        .remove-record-btn {
            background: none;
            border: none;
            color: var(--red);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
        }

        .remove-record-btn:hover {
            color: #c0392b;
        }

        .add-record-btn {
            width: 100%;
            padding: 1rem;
            border: 2px dashed var(--border-color);
            background: none;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .add-record-btn:hover {
            border-color: var(--secondary-color);
            color: var(--secondary-color);
        }

        /* Write Icon Animation */
        .nfc-icon.writing {
            background: linear-gradient(135deg, var(--green), #27ae60);
            animation: pulse 1s infinite;
        }

        .writing .pulse-ring {
            border-color: var(--green);
            animation: pulse-ring 1.5s infinite;
        }
    </style>
</head>
<body>
<div class="app-container">
	<nav class="sidebar menu-loading" id="sidebar">
		<div class="logo"><h2>Dreamex Datalab</h2></div>
        <ul class="menu" id="roleBasedMenu">
            <li class="menu-item" data-feature="home_view"><a href="index.html"><i class="fas fa-home"></i> Home</a></li>
            <li class="menu-dropdown" data-feature="health_view">
				<a href="#"><i class="fas fa-medkit"></i> Health</a>
				<ul class="submenu">
					<li data-feature="health_assessment_view" data-requires-permission="health_assessment_view"><a href="health-assessment.html">Assessment</a></li>
					<li data-feature="health_consultation_view" data-requires-permission="health_consultation_view"><a href="health-consultation.html">Consultation</a></li>
					<li data-feature="medical_folder_view" data-requires-permission="medical_folder_view"><a href="medical-folder.html">Medical Folder</a></li>
				</ul>
			</li>
            <!-- Risk Management (separate section) -->
            <li class="menu-dropdown" data-feature="risk_view" data-requires-permission="risk_view">
                <a href="#"><i class="fas fa-exclamation-triangle"></i> Risk Management</a>
            <ul class="submenu">
                <li data-feature="risk_view" data-requires-permission="risk_view"><a href="riskboard.html">Risk Management</a></li>
                <li data-feature="risk_view" data-requires-permission="risk_register_view"><a href="riskreg.html">Risk Register</a></li>
            </ul>
            </li>
            <li class="menu-dropdown" data-feature="safety_view" data-requires-permission="safety_view">
				<a href="#"><i class="fas fa-shield-alt"></i> Safety</a>
				<ul class="submenu">
					<li data-feature="training_view" data-requires-permission="training_view"><a href="trainingboard.html">Training</a></li>
					<li data-feature="jsa_view" data-requires-permission="jsa_view"><a href="jsaboard.html">Job Safety Analysis</a></li>
					<li data-feature="ptw_view" data-requires-permission="ptw_view"><a href="ptwboard.html">Permit to Work</a></li>
					<li data-feature="incident_view" data-requires-permission="incident_view"><a href="incidentboard.html">Incident Reports</a></li>
					<li data-feature="inspection_view" data-requires-permission="inspection_view"><a href="inspectionboard.html">Inspection</a></li>
					<li data-feature="audit_view" data-requires-permission="audit_view"><a href="auditboard.html">Audit</a></li>
				</ul>
			</li>
            <li class="menu-dropdown" data-feature="investigation_view" data-requires-permission="investigation_view">
				<a href="#"><i class="fas fa-search-plus"></i> Investigation</a>
				<ul class="submenu">
					<li data-feature="investigation_dashboard_view" data-requires-permission="investigation_dashboard_view"><a href="investigation-dashboard.html">Investigation Dashboard</a></li>
					<li data-feature="investigation_list_view" data-requires-permission="investigation_list_view"><a href="investigation-list.html">Investigation List</a></li>
					<li data-feature="create_investigation_view" data-requires-permission="create_investigation_view"><a href="investigation-create.html">Create Investigation</a></li>
				</ul>
			</li>
            <li class="menu-dropdown" data-feature="fuel_management" data-requires-permission="fuel_management">
				<a href="#"><i class="fas fa-gas-pump"></i> Fuel Management</a>
				<ul class="submenu">
                    <li data-feature="vessel_offloading" data-requires-permission="vessel_offloading"><a href="vessel-offloading.html">Vessel Offloading</a></li>
                    <li data-feature="fuel_storage" data-requires-permission="fuel_storage"><a href="fuelstor.html">Fuel Storage Status</a></li>
                    <li data-feature="tank_transfer" data-requires-permission="tank_transfer"><a href="fueltrans.html">Tank-to-Tank Transfer</a></li>
                    <li data-feature="truck_loading" data-requires-permission="truck_loading"><a href="fuel-truck-loading.html">Fuel Truck Loading</a></li>
                    <li data-feature="quality_analysis" data-requires-permission="quality_analysis"><a href="fuel-quality-analysis.html">Fuel Quality Analysis</a></li>
                    <li data-feature="fuel_distribution" data-requires-permission="fuel_distribution"><a href="fueldist.html">Fuel Distribution</a></li>
                    <li data-feature="fuel_consumption_analysis" data-requires-permission="fuel_consumption_analysis"><a href="fuelanalys.html">Consumption Analysis</a></li>
                    <li data-feature="fuel_daily_report" data-requires-permission="fuel_daily_report"><a href="fueldaily.html">Daily Fuel Report</a></li>
				</ul>
			</li>
            <li class="menu-dropdown" data-feature="environment_view">
				<a href="#"><i class="fas fa-leaf"></i> Environment</a>
				<ul class="submenu">
                    <li data-feature="water_view" data-requires-permission="water_view"><a href="waterboard.html">Water Quality</a></li>
				</ul>
			</li>
            <li class="menu-dropdown" data-feature="security_view" data-requires-permission="security_view">
				<a href="#"><i class="fas fa-lock"></i> Security</a>
				<ul class="submenu">
                    <li data-feature="access_view" data-requires-permission="access_view"><a href="accessboard.html">Access Request</a></li>
                    <li data-feature="access_daily_view" data-requires-permission="access_daily_view"><a href="accessdaily.html">Daily Access Control</a></li>
                    <li data-feature="removal_view" data-requires-permission="removal_view"><a href="removalboard.html">Property Removal</a></li>
                <li data-feature="security_site_map_view" data-requires-permission="security_site_map_view"><a href="sitemap.html">Security Site Map</a></li>
						<li data-feature="security_level_evaluation_view" data-requires-permission="security_level_evaluation_view"><a href="seclevel.html">Security Level Evaluation</a></li>
						<li data-feature="nfc_view" data-requires-permission="nfc_view"><a href="nfc.html">NFC Card Management</a></li>
				</ul>
			</li>
			<li class="menu-dropdown" data-feature="logistics_view" data-requires-permission="logistics_view">
				<a href="#"><i class="fas fa-truck"></i> Logistics</a>
				<ul class="submenu">
                    <li data-feature="fleet_view" data-requires-permission="fleet_view"><a href="fleet.html">Fleet Management</a></li>
                    <li data-feature="travel_view" data-requires-permission="travel_view"><a href="travel.html">Travel Requests</a></li>
				</ul>
			</li>
			<li class="menu-dropdown" data-feature="accommodation_view" data-requires-permission="accommodation_view">
				<a href="#"><i class="fas fa-bed"></i> Accommodation</a>
				<ul class="submenu">
					<li data-feature="camp_view" data-requires-permission="camp_view"><a href="camp.html">Camp Management</a></li>
                    <li data-feature="camp_settings_view" data-requires-permission="camp_settings_view"><a href="campset.html">Camp Settings</a></li>
				</ul>
			</li>
			<li class="menu-dropdown" data-feature="hr_view" data-requires-permission="hr_view">
				<a href="#"><i class="fas fa-users"></i> HR</a>
				<ul class="submenu">
					<li data-feature="human_hr_view" data-requires-permission="human_hr_view"><a href="human-hr.html"><i class="fas fa-user-tie"></i> Human HR</a></li>
					<li data-feature="staff_management_view" data-requires-permission="staff_management_view"><a href="staff.html">Staffing</a></li>
					<li data-feature="authority_to_recruit_view" data-requires-permission="authority_to_recruit_view"><a href="recruit.html">Authority to Recruit</a></li>
					<li data-feature="job_advertising_view" data-requires-permission="job_advertising_view"><a href="jobpost.html">Job Advertising</a></li>
					<li data-feature="screening_view" data-requires-permission="screening_view"><a href="jobscreen.html">Screening</a></li>
					<li data-feature="interview_view" data-requires-permission="interview_view"><a href="interview.html">Interview</a></li>
					<li data-feature="offer_view" data-requires-permission="offer_view"><a href="offer.html">Offer Management</a></li>
					<li data-feature="contract_view" data-requires-permission="contract_view"><a href="contract.html">Contract Management</a></li>
                    <li data-feature="salary_management_view" data-requires-permission="salary_management_view"><a href="salary.html">Salary Management</a></li>
					<li data-feature="onboarding_view" data-requires-permission="onboarding_view"><a href="onboard.html">Onboarding</a></li>
					<li data-feature="chart_view" data-requires-permission="chart_view"><a href="chart.html">Chart Setup</a></li>
					<li data-feature="chartboard_view" data-requires-permission="chartboard_view"><a href="chartboard.html">Org Chart</a></li>
                    <li data-feature="kpi_dashboard_view" data-requires-permission="kpi_dashboard_view"><a href="kpi.html">KPI</a></li>
                    <li data-feature="payroll_view" data-requires-permission="payroll_view"><a href="payroll.html">Payroll</a></li>
				</ul>
			</li>
            <!-- Project Management as section button with submenu -->
            <li class="menu-dropdown" data-feature="project_management_section">
                <a href="#"><i class="fas fa-project-diagram"></i> Project Management</a>
                <ul class="submenu">
                    <li data-feature="project_dashboard_view" data-requires-permission="project_dashboard_view"><a href="project-dashboard.html"><i class="fas fa-tachometer-alt"></i> Project Dashboard</a></li>
                    <li data-feature="project_create_view" data-requires-permission="project_create_view"><a href="project-create.html"><i class="fas fa-plus-circle"></i> Create Project</a></li>
                    <li data-feature="project_list_view" data-requires-permission="project_list_view"><a href="project-list.html"><i class="fas fa-list"></i> Project List</a></li>
                    <li data-feature="project_reports_view" data-requires-permission="project_reports_view"><a href="project-reports.html"><i class="fas fa-chart-bar"></i> Project Reports</a></li>
                </ul>
            </li>
            <!-- Inventory Management as section button with submenu -->
            <li class="menu-dropdown" data-feature="inventory_view" data-requires-permission="inventory_view">
                <a href="#"><i class="fas fa-boxes"></i> Inventory Management</a>
                <ul class="submenu">
                    <li data-feature="inventory_dashboard_view" data-requires-permission="inventory_dashboard_view"><a href="inventory-dashboard.html"><i class="fas fa-tachometer-alt"></i> Inventory Dashboard</a></li>
                    <li data-feature="inventory_items_view" data-requires-permission="inventory_items_view"><a href="inventory-items.html"><i class="fas fa-cubes"></i> Items Management</a></li>
                    <li data-feature="inventory_warehouses_view" data-requires-permission="inventory_warehouses_view"><a href="inventory-warehouses.html"><i class="fas fa-warehouse"></i> Warehouses</a></li>
                    <li data-feature="inventory_reservations_view" data-requires-permission="inventory_reservations_view"><a href="inventory-reservations.html"><i class="fas fa-bookmark"></i> Material Reservations</a></li>
                    <li data-feature="inventory_approvals_view" data-requires-permission="inventory_approvals_view"><a href="inventory-approvals.html"><i class="fas fa-check-circle"></i> Approvals</a></li>
                    <li data-feature="inventory_issue_view" data-requires-permission="inventory_issue_view"><a href="inventory-issue.html"><i class="fas fa-shipping-fast"></i> Material Issue</a></li>
                </ul>
            </li>
            <!-- Workspaces: Catering -->
            <li class="menu-dropdown" data-feature="catering_view" data-requires-permission="catering_view">
                <a href="#"><i class="fas fa-utensils"></i> Workspaces â€” Catering</a>
                <ul class="submenu">
                    <li data-feature="catering_manage_types" data-requires-permission="catering_manage_types"><a href="catering-meal-types.html"><i class="fas fa-list"></i> Meal Types</a></li>
                    <li data-feature="catering_assign" data-requires-permission="catering_assign"><a href="catering-eligibility.html"><i class="fas fa-user-check"></i> Eligibility & Assign</a></li>
                    <li data-feature="catering_consumption_manual" data-requires-permission="catering_consumption_manual"><a href="catering-consumption.html"><i class="fas fa-keyboard"></i> Consumption (Manual)</a></li>
                    <li data-feature="catering_consumption_nfc" data-requires-permission="catering_consumption_nfc"><a href="catering-consumption.html#nfc"><i class="fas fa-id-card"></i> Consumption (NFC)</a></li>
                    <li data-feature="catering_reports" data-requires-permission="catering_reports"><a href="catering-reports.html"><i class="fas fa-chart-line"></i> Reports</a></li>
                </ul>
            </li>
            <li data-feature="requests_view" data-requires-permission="requests_view"><a href="tickboard.html"><i class="fas fa-ticket-alt"></i> Requests</a></li>
            <li data-feature="communication_view"><a href="info.html"><i class="fas fa-comments"></i> Communication</a></li>
            <li class="menu-dropdown" data-feature="settings_view">
				<a href="#"><i class="fas fa-cog"></i> Settings</a>
				<ul class="submenu">
                    <li data-feature="account_settings_view" data-requires-permission="account_settings_view"><a href="account.html">Account Settings</a></li>
                    <li data-feature="company_management_view" data-requires-permission="company_management_view"><a href="companymanagement.html">Company Management</a></li>
                    <li data-feature="approval_settings_view" data-requires-permission="approval_settings_view"><a href="approval-settings.html">Approval Flow Settings</a></li>
                    <li data-feature="field_setup_view" data-requires-permission="field_setup_view"><a href="fieldsetup.html">Field Setup</a></li>
                    <li data-feature="preferences_view" data-requires-permission="preferences_view"><a href="preferences.html">Preferences</a></li>
                    <li data-feature="notification_settings_view" data-requires-permission="notification_settings_view"><a href="notification-settings.html">Notification Settings</a></li>
                    <li data-feature="audit_log_view" data-requires-permission="audit_log_view"><a href="auditlog.html"><i class="fas fa-history"></i> Audit Log</a></li>
                    <li data-feature="user_management_view" data-requires-permission="user_management_view"><a href="users.html">User & Role Management</a></li>
                    <li data-feature="role_permissions_view" data-requires-permission="role_permissions_view"><a href="roles.html">Role Permissions</a></li>
				</ul>
			</li>
		</ul>
	</nav>
    <main class="main-content" id="mainContent">
        <nav class="top-nav">
            <div class="top-nav-left">
                <button id="sidebarToggle" class="sidebar-toggle-btn" title="Toggle Menu"><i class="fas fa-bars"></i></button>
                <div class="company-branding">
                    <img id="headerCompanyLogo" alt="Company Logo" />
                    <span id="headerCompanyName"></span>
                </div>
            </div>
            <div class="top-nav-right">
                <div class="notifications">
                    <button id="notificationBtn" class="notification-btn">
                        <i class="fas fa-bell"></i>
                        <span class="notification-badge">0</span>
                    </button>
                    <div class="notification-dropdown">
                        <div class="notification-header">
                            <h3>Notifications</h3>
                            <button class="mark-all-read">Mark all as read</button>
                        </div>
                        <div class="notification-list">
                            <!-- Notifications will be dynamically added here -->
                        </div>
                        <div class="notification-empty">
                            <i class="fas fa-inbox"></i>
                            <div class="notification-empty-title">No notifications</div>
                            <div class="notification-empty-message">You're all caught up</div>
                        </div>
                    </div>
                </div>
                <div class="user-profile" style="position:relative;">
                    <button id="userProfileBtn" class="profile-btn"><img src="" alt="User Avatar" /></button>
                    <div class="profile-dropdown"><ul></ul></div>
                </div>
            </div>
        </nav>
		<div class="page-header">
			<h1><i class="fas fa-wifi"></i> NFC Card Reader & Writer</h1>
		</div>

            <!-- Main Tab Navigation -->
            <div class="main-tab-nav">
                <button class="main-tab-btn active" data-tab="nfcTab" onclick="switchMainTab('nfcTab')">
                    <i class="fas fa-wifi"></i> NFC
                </button>
                <button class="main-tab-btn" data-tab="recordTab" onclick="switchMainTab('recordTab')">
                    <i class="fas fa-history"></i> Record
                </button>
                <button class="main-tab-btn" data-tab="settingsTab" onclick="switchMainTab('settingsTab')">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </div>

            <!-- NFC Tab Content -->
            <div class="main-tab-content active" id="nfcTab">
            <div class="nfc-container">
                <!-- Scanner/Writer Section -->
                <div class="nfc-card scanner-section" style="display: flex; gap: 1.5rem; align-items: flex-start;">
                    <!-- Left Side: NFC Tools Buttons -->
                    <div class="nfc-tools-sidebar" style="flex-shrink: 0; border-right: 1px solid var(--border-color); padding-right: 1rem;">
                        <div class="mode-toggle" id="nfcToolsToggle" style="flex-direction: column; gap: 0;">
                            <button class="main-tab-btn active" id="readModeBtn" data-tool="read" onclick="switchMode('read')" title="Read Tag" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-wifi"></i>
                            </button>
                            <button class="main-tab-btn" id="writeModeBtn" data-tool="write" onclick="switchMode('write')" title="Write Tag" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-pen"></i>
                            </button>
                            <button class="main-tab-btn" id="eraseModeBtn" data-tool="erase" onclick="launchNFCTool('erase')" title="Erase Tag" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-eraser"></i>
                            </button>
                            <button class="main-tab-btn" id="formatModeBtn" data-tool="format" onclick="launchNFCTool('format')" title="Format Tag" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="main-tab-btn" id="lockModeBtn" data-tool="lock" onclick="launchNFCTool('lock')" title="Lock Tag" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-lock"></i>
                            </button>
                            <button class="main-tab-btn" id="setPasswordModeBtn" data-tool="setPassword" onclick="launchNFCTool('setPassword')" title="Set Password" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-key"></i>
                            </button>
                            <button class="main-tab-btn" id="removePasswordModeBtn" data-tool="removePassword" onclick="launchNFCTool('removePassword')" title="Remove Password" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-unlock"></i>
                            </button>
                            <button class="main-tab-btn" id="copyModeBtn" data-tool="copy" onclick="launchNFCTool('copy')" title="Copy Tag" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-copy"></i>
                            </button>
                            <button class="main-tab-btn" id="infoModeBtn" data-tool="info" onclick="launchNFCTool('info')" title="Tag Info" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <button class="main-tab-btn" id="externalAppBtn" data-tool="externalApp" onclick="selectNFCToolBtn('externalApp'); openExternalNFCApp()" title="NFC Tools App" style="padding: 0.75rem; justify-content: center;">
                                <i class="fas fa-external-link-alt"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Right Side: Content Area -->
                    <div class="nfc-content-area" style="flex: 1; min-width: 0;">
                        <!-- NFC Tool Status -->
                        <div id="nfcToolStatus" class="write-status" style="display: none; margin-bottom: 1rem;"></div>
                        
                        <!-- NFC Tool Result Panel -->
                        <div id="nfcToolResultPanel" style="display: none; background: var(--bg-secondary); border-radius: 10px; padding: 1.25rem; margin-bottom: 1rem;">
                            <h3 style="margin: 0 0 1rem 0; color: var(--primary-color);"><i class="fas fa-clipboard-check"></i> Tool Result</h3>
                            <div id="nfcToolResult"></div>
                        </div>

                        <!-- Read Mode Section -->
                        <div id="readModeSection">
                            <h2><i class="fas fa-broadcast-tower"></i> Scanner</h2>
                            
                            <div class="nfc-icon-container" id="nfcIconContainer">
                                <div class="pulse-ring"></div>
                                <div class="pulse-ring"></div>
                                <div class="pulse-ring"></div>
                                <div class="nfc-icon" id="nfcIcon">
                                    <i class="fas fa-wifi"></i>
                                </div>
                            </div>

                            <p class="scan-status" id="scanStatus">Ready to scan</p>

                            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                                <button class="btn btn-primary" id="startScanBtn" onclick="startNFCScan()">
                                    <i class="fas fa-play"></i> Start Scanning
                                </button>
                                <button class="btn btn-danger" id="stopScanBtn" onclick="stopNFCScan()" style="display: none;">
                                    <i class="fas fa-stop"></i> Stop Scanning
                                </button>
                            </div>

                            <!-- Scan History -->
                            <div class="history-section" id="historySection" style="display: none;">
                                <h3 style="margin-bottom: 1rem; color: var(--primary-color);">
                                    <i class="fas fa-history"></i> Scan History
                                </h3>
                                <div id="historyList"></div>
                            </div>
                        </div>

                        <!-- Write Mode Section -->
                        <div id="writeModeSection" style="display: none;">
                            <h2><i class="fas fa-edit"></i> Write to NFC Card</h2>
                            
                            <div class="write-form">
                                <!-- Record Type Selection -->
                                <div class="form-group">
                                    <label>Select Data Type</label>
                                    <div class="record-type-selector">
                                        <button type="button" class="record-type-btn active" onclick="selectWriteType('text')" data-type="text">
                                            <i class="fas fa-font"></i>
                                            <span>Text</span>
                                        </button>
                                        <button type="button" class="record-type-btn" onclick="selectWriteType('url')" data-type="url">
                                            <i class="fas fa-link"></i>
                                            <span>URL</span>
                                        </button>
                                        <button type="button" class="record-type-btn" onclick="selectWriteType('json')" data-type="json">
                                            <i class="fas fa-code"></i>
                                            <span>JSON</span>
                                        </button>
                                        <button type="button" class="record-type-btn" onclick="selectWriteType('vcard')" data-type="vcard">
                                            <i class="fas fa-address-card"></i>
                                            <span>vCard</span>
                                        </button>
                                    </div>
                                </div>

                                <!-- Text Input -->
                                <div class="form-group" id="textInputGroup">
                                    <label for="writeText">Text Content</label>
                                    <textarea id="writeText" placeholder="Enter text to write to the NFC card..."></textarea>
                                <small>Plain text that will be stored on the card</small>
                            </div>

                            <!-- URL Input -->
                            <div class="form-group" id="urlInputGroup" style="display: none;">
                                <label for="writeUrl">URL</label>
                                <input type="url" id="writeUrl" placeholder="https://example.com">
                                <small>Web address that will open when the card is scanned</small>
                            </div>

                            <!-- JSON Input -->
                            <div class="form-group" id="jsonInputGroup" style="display: none;">
                                <label for="writeJson">JSON Data</label>
                                <textarea id="writeJson" placeholder='{"name": "John", "id": "12345"}'></textarea>
                                <small>Valid JSON data structure</small>
                            </div>

                            <!-- vCard Input -->
                            <div id="vcardInputGroup" style="display: none;">
                                <div class="form-group">
                                    <label for="vcardOrg">Organization</label>
                                    <select id="vcardOrg" onchange="onOrganizationChange()">
                                        <option value="">-- Select Organization --</option>
                                        <option value="loading" disabled>Loading companies...</option>
                                    </select>
                                    <small>Select a company from the list</small>
                                </div>
                                <div class="form-group">
                                    <label for="vcardName">Full Name</label>
                                    <select id="vcardName" onchange="onEmployeeChange()">
                                        <option value="">-- Select Organization First --</option>
                                    </select>
                                    <small>Select an employee from the organization</small>
                                </div>
                                <div class="form-group">
                                    <label for="vcardPhone">Phone Number</label>
                                    <input type="tel" id="vcardPhone" placeholder="+1234567890">
                                </div>
                                <div class="form-group">
                                    <label for="vcardEmail">Email</label>
                                    <input type="email" id="vcardEmail" placeholder="john@example.com">
                                </div>
                                <div class="form-group">
                                    <label for="vcardTitle">Job Title</label>
                                    <input type="text" id="vcardTitle" placeholder="Software Engineer">
                                </div>
                                <small style="color: var(--text-secondary);">Contact card that can be saved to phone contacts</small>
                            </div>

                            <!-- Data Encryption -->
                            <div class="form-group" style="padding: 1rem; background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), rgba(39, 174, 96, 0.1)); border-radius: 8px; border: 1px solid var(--success-color);">
                                <div style="display: flex; align-items: center; gap: 0.75rem;">
                                    <input type="checkbox" id="enableEncryption" checked style="width: 18px; height: 18px; cursor: pointer;">
                                    <label for="enableEncryption" style="margin: 0; cursor: pointer; font-weight: 500;">
                                        <i class="fas fa-shield-alt" style="margin-right: 0.5rem; color: var(--success-color);"></i>
                                        Encrypt Card Data
                                    </label>
                                </div>
                                <small style="color: var(--success-color); display: block; margin-top: 0.5rem; margin-left: 2rem;">
                                    <i class="fas fa-info-circle"></i> Only your site can read encrypted data. Other apps see gibberish.
                                </small>
                            </div>

                            <!-- Write Button -->
                            <div style="margin-top: 1.5rem; text-align: center;">
                                <button class="btn btn-success" id="writeNfcBtn" onclick="startNFCWrite()">
                                    <i class="fas fa-pen"></i> Write to Card
                                </button>
                                <button class="btn btn-danger" id="cancelWriteBtn" onclick="cancelNFCWrite()" style="display: none;">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            </div>

                            <!-- Write Status -->
                            <div class="write-status" id="writeStatus"></div>

                        </div>

                        <!-- Card Information Section -->
                        <div style="margin-top: 1.5rem;">
                            <h3 style="color: var(--primary-color); margin-bottom: 0.75rem;">
                                <i class="fas fa-database"></i> Card Information
                            </h3>

                            <div class="no-data" id="noDataMessage" style="padding: 1.5rem; background: var(--bg-tertiary); border-radius: 8px; text-align: center;">
                                <i class="fas fa-credit-card" style="font-size: 2rem; color: var(--text-secondary); margin-bottom: 0.5rem;"></i>
                                <p>No card scanned yet</p>
                                <p style="font-size: 0.9rem; color: var(--text-secondary);">Tap an NFC card to your device to read its data</p>
                            </div>

                            <div id="cardDataContainer" style="display: none;">
                                <!-- Serial Number -->
                                <div class="serial-number" id="serialNumberSection" style="display: none;">
                                    <h4><i class="fas fa-fingerprint"></i> Card Serial Number</h4>
                                    <div class="serial-value" id="serialNumber"></div>
                                </div>

                                <!-- Assigned Employee Profile -->
                                <div id="assignedEmployeeSection" style="display: none; margin: 1rem 0; padding: 1rem; background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%); border-radius: 12px; border: 1px solid var(--border-color);">
                                    <h4 style="margin: 0 0 0.75rem 0; color: var(--primary-color); font-size: 0.9rem;">
                                        <i class="fas fa-user-circle"></i> Assigned Employee
                                    </h4>
                                    <div style="display: flex; align-items: center; gap: 1rem;">
                                        <div id="assignedEmployeeAvatar" style="width: 80px; height: 80px; border-radius: 50%; overflow: hidden; border: 3px solid var(--primary-color); box-shadow: 0 4px 12px rgba(0,0,0,0.15); flex-shrink: 0;">
                                            <!-- Avatar will be inserted here -->
                                        </div>
                                        <div id="assignedEmployeeInfo" style="flex: 1;">
                                            <div id="assignedEmployeeName" style="font-weight: 600; font-size: 1.1rem; color: var(--text-primary); margin-bottom: 0.25rem;"></div>
                                            <div id="assignedEmployeeOrg" style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.25rem;"></div>
                                            <div id="assignedEmployeeStatus" style="display: inline-block; padding: 2px 10px; border-radius: 12px; font-size: 0.75rem; font-weight: 500; background: var(--success-color); color: white;">Assigned</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Tabs for different data views -->
                                <div class="tabs">
                                    <button class="tab-btn active" onclick="switchTab('parsed')">
                                        <i class="fas fa-list"></i> Parsed Data
                                    </button>
                                    <button class="tab-btn" onclick="switchTab('raw')">
                                        <i class="fas fa-code"></i> Raw Data
                                    </button>
                                </div>

                                <!-- Parsed Data Tab -->
                                <div class="tab-content active" id="parsedTab">
                                    <div class="nfc-data-list" id="nfcDataList"></div>
                                </div>

                                <!-- Raw Data Tab -->
                                <div class="tab-content" id="rawTab">
                                    <div class="raw-data">
                                        <pre id="rawDataContent"></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    </div> <!-- End nfc-content-area -->
                </div>
            </div>
            </div>
            <!-- End of NFC Tab Content -->

            <!-- Record Tab Content -->
            <div class="main-tab-content" id="recordTab">
                <div class="record-table-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h2 style="margin: 0; color: var(--primary-color);">
                            <i class="fas fa-history"></i> NFC Write History
                        </h2>
                        <button class="btn btn-danger" onclick="clearWriteHistory()" style="font-size: 0.85rem;">
                            <i class="fas fa-trash"></i> Clear History
                        </button>
                    </div>
                    
                    <div id="recordTableContent">
                        <table class="record-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Date & Time</th>
                                    <th>Type</th>
                                    <th>Name</th>
                                    <th>Organization</th>
                                    <th>Serial Number</th>
                                    <th>Card ID</th>
                                    <th>Written By</th>
                                    <th>Security</th>
                                </tr>
                            </thead>
                            <tbody id="recordTableBody">
                                <tr>
                                    <td colspan="10" class="record-empty">
                                        <i class="fas fa-inbox"></i>
                                        <p>No write records yet</p>
                                        <p style="font-size: 0.85rem;">Records will appear here after you write to NFC cards</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <!-- End of Record Tab Content -->

            <!-- Settings Tab Content -->
            <div class="main-tab-content" id="settingsTab">
                <!-- NFC App Settings -->
                <div class="record-table-container" style="margin-bottom: 1.5rem;">
                    <h2 style="margin: 0 0 1.5rem 0; color: var(--primary-color);">
                        <i class="fas fa-mobile-alt"></i> NFC App Settings
                    </h2>
                    
                    <!-- Settings Grid -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
                        
                        <!-- App Selection Card -->
                        <div style="background: var(--bg-secondary); border-radius: 12px; padding: 1.25rem; border: 1px solid var(--border-color);">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--text-primary); display: flex; align-items: center; gap: 0.5rem;">
                                <i class="fas fa-th-large" style="color: var(--primary-color);"></i> External App
                            </h3>
                            <div class="form-group" style="margin-bottom: 1rem;">
                                <label style="font-size: 0.85rem; margin-bottom: 0.5rem; display: block;">Preferred NFC App</label>
                                <select id="preferredNFCApp" onchange="saveNFCAppPreference()" style="width: 100%;">
                                    <option value="builtin">Built-in (This App)</option>
                                    <option value="nfctools">NFC Tools (wakdev)</option>
                                    <option value="nfctaginfo">NFC TagInfo by NXP</option>
                                    <option value="nfcreactor">NFC ReaderWriter</option>
                                    <option value="custom">Custom App</option>
                                </select>
                            </div>
                            <div class="form-group" id="customAppGroup" style="display: none; margin-bottom: 0;">
                                <label style="font-size: 0.85rem; margin-bottom: 0.5rem; display: block;">Custom Package Name</label>
                                <input type="text" id="customAppPackage" placeholder="com.example.nfcapp" onchange="saveNFCAppPreference()" style="width: 100%;">
                            </div>
                        </div>
                        
                        <!-- Feedback Settings Card -->
                        <div style="background: var(--bg-secondary); border-radius: 12px; padding: 1.25rem; border: 1px solid var(--border-color);">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--text-primary); display: flex; align-items: center; gap: 0.5rem;">
                                <i class="fas fa-bell" style="color: var(--success-color);"></i> Feedback
                            </h3>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.5rem; border-radius: 8px; transition: background 0.2s;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='transparent'">
                                    <input type="checkbox" id="enableNFCSound" checked onchange="saveNFCAppPreference()" style="width: 18px; height: 18px;">
                                    <span style="display: flex; align-items: center; gap: 0.5rem;">
                                        <i class="fas fa-volume-up" style="color: var(--text-secondary); width: 20px;"></i>
                                        Play sound on scan
                                    </span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.5rem; border-radius: 8px; transition: background 0.2s;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='transparent'">
                                    <input type="checkbox" id="enableNFCVibration" checked onchange="saveNFCAppPreference()" style="width: 18px; height: 18px;">
                                    <span style="display: flex; align-items: center; gap: 0.5rem;">
                                        <i class="fas fa-mobile-alt" style="color: var(--text-secondary); width: 20px;"></i>
                                        Vibrate on scan
                                    </span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Behavior Settings Card -->
                        <div style="background: var(--bg-secondary); border-radius: 12px; padding: 1.25rem; border: 1px solid var(--border-color);">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--text-primary); display: flex; align-items: center; gap: 0.5rem;">
                                <i class="fas fa-cog" style="color: var(--warning-color);"></i> Behavior
                            </h3>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.5rem; border-radius: 8px; transition: background 0.2s;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='transparent'">
                                    <input type="checkbox" id="autoLaunchNFCApp" onchange="saveNFCAppPreference()" style="width: 18px; height: 18px;">
                                    <span style="display: flex; flex-direction: column; gap: 0.15rem;">
                                        <span style="display: flex; align-items: center; gap: 0.5rem;">
                                            <i class="fas fa-external-link-alt" style="color: var(--text-secondary); width: 20px;"></i>
                                            Auto-launch external app
                                        </span>
                                        <small style="color: var(--text-secondary); margin-left: 25px;">For unsupported operations</small>
                                    </span>
                                </label>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                <!-- Card Assignment Section -->
                <div class="record-table-container">
                    <h2 style="margin: 0 0 1rem 0; color: var(--primary-color);">
                        <i class="fas fa-id-card"></i> Assign Card to Employee
                    </h2>

                    <div class="write-form" style="margin-bottom: 1.25rem;">
                        <div class="form-group">
                            <label for="assignOrg">Organization</label>
                            <select id="assignOrg" onchange="onAssignOrganizationChange()">
                                <option value="">-- Select Organization --</option>
                            </select>
                            <small style="color: var(--text-secondary);">Select a company from the list</small>
                        </div>
                        <div class="form-group">
                            <label for="assignEmployee">Employee</label>
                            <select id="assignEmployee" onchange="onAssignEmployeeChange()">
                                <option value="">-- Select Organization First --</option>
                            </select>
                            <small style="color: var(--text-secondary);">Select an employee from the organization</small>
                        </div>
                        <div class="form-group">
                            <label>Card ID</label>
                            <select id="assignCardId">
                                <option value="">-- Select Card --</option>
                            </select>
                        </div>
                        <div style="display:flex; gap:.5rem;">
                            <button class="btn btn-primary" type="button" onclick="scanCardForAssignment()"><i class="fas fa-wifi"></i> Scan Card</button>
                            <button class="btn btn-success" type="button" onclick="assignCardToEmployee()"><i class="fas fa-check"></i> Assign Card</button>
                        </div>
                        <div class="write-status" id="assignStatus"></div>
                    </div>

                    <h3 style="color: var(--primary-color); margin-bottom: .75rem;"><i class="fas fa-list"></i> Current Assignments</h3>
                    <div id="assignmentsTableContent">
                        <table class="record-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Assigned At</th>
                                    <th>Card ID</th>
                                    <th>Serial</th>
                                    <th>Employee</th>
                                    <th>Organization</th>
                                    <th>Assigned By</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="assignmentsTableBody">
                                <tr>
                                    <td colspan="8" class="record-empty">
                                        <i class="fas fa-inbox"></i>
                                        <p>No assignments yet</p>
                                        <p style="font-size: 0.85rem;">Scan and assign a card to an employee</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <!-- End of Settings Tab Content -->

        </main>
    </div>

    <script>
        // Global variables
        let nfcReader = null;
        let abortController = null;
        let scanHistory = [];
        let isScanning = false;
        let isWriting = false;
        let currentMode = 'read';
        let selectedWriteType = 'text';
        let writeAbortController = null;
        let writeHistory = [];

        // Main Tab Switching Function
        function switchMainTab(tabId) {
            // Update tab buttons
            document.querySelectorAll('.main-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabId) {
                    btn.classList.add('active');
                }
            });

            // Update tab content
            document.querySelectorAll('.main-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');

            // Load write history when switching to Record tab
            if (tabId === 'recordTab') {
                loadWriteHistory();
            }
            if (tabId === 'settingsTab') {
                loadAssignments();
                loadNFCAppPreferences();
            }
        }

        // =============================================
        // NFC Tools Functions
        // =============================================
        
        // NFC App package names for Android intents
        const NFC_APP_PACKAGES = {
            nfctools: 'com.wakdev.wdnfc',
            nfctaginfo: 'com.nxp.taginfolite',
            nfcreactor: 'com.gonext.nfcreader'
        };
        
        // Current tool operation state
        let currentNFCTool = null;
        let toolAbortController = null;
        let copiedTagData = null;
        
        // Load NFC app preferences from localStorage
        function loadNFCAppPreferences() {
            try {
                const prefs = JSON.parse(localStorage.getItem('nfcAppPreferences') || '{}');
                
                if (prefs.preferredApp) {
                    document.getElementById('preferredNFCApp').value = prefs.preferredApp;
                    toggleCustomAppField(prefs.preferredApp);
                }
                if (prefs.customPackage) {
                    document.getElementById('customAppPackage').value = prefs.customPackage;
                }
                if (prefs.autoLaunch !== undefined) {
                    document.getElementById('autoLaunchNFCApp').checked = prefs.autoLaunch;
                }
                if (prefs.enableSound !== undefined) {
                    document.getElementById('enableNFCSound').checked = prefs.enableSound;
                }
                if (prefs.enableVibration !== undefined) {
                    document.getElementById('enableNFCVibration').checked = prefs.enableVibration;
                }
            } catch (e) {
                console.error('Error loading NFC preferences:', e);
            }
        }
        
        // Save NFC app preferences to localStorage
        function saveNFCAppPreference() {
            try {
                const preferredApp = document.getElementById('preferredNFCApp').value;
                toggleCustomAppField(preferredApp);
                
                const prefs = {
                    preferredApp: preferredApp,
                    customPackage: document.getElementById('customAppPackage').value,
                    autoLaunch: document.getElementById('autoLaunchNFCApp').checked,
                    enableSound: document.getElementById('enableNFCSound').checked,
                    enableVibration: document.getElementById('enableNFCVibration').checked
                };
                
                localStorage.setItem('nfcAppPreferences', JSON.stringify(prefs));
                showNFCToolStatus('âœ… Settings saved', 'success');
            } catch (e) {
                console.error('Error saving NFC preferences:', e);
            }
        }
        
        // Toggle custom app package field visibility
        function toggleCustomAppField(preferredApp) {
            const customGroup = document.getElementById('customAppGroup');
            if (customGroup) {
                customGroup.style.display = preferredApp === 'custom' ? 'block' : 'none';
            }
        }
        
        // Show NFC tool status message
        function showNFCToolStatus(message, type) {
            const statusEl = document.getElementById('nfcToolStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = 'write-status ' + (type || '');
                statusEl.style.display = 'block';
                
                // Auto-hide after 3 seconds for success messages
                if (type === 'success') {
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 3000);
                }
            }
        }
        
        // Show NFC tool result
        function showNFCToolResult(title, content, type) {
            const panel = document.getElementById('nfcToolResultPanel');
            const resultEl = document.getElementById('nfcToolResult');
            
            if (panel && resultEl) {
                let icon = 'clipboard-check';
                let color = 'var(--primary-color)';
                
                if (type === 'success') {
                    icon = 'check-circle';
                    color = 'var(--success-color)';
                } else if (type === 'error') {
                    icon = 'times-circle';
                    color = 'var(--accent-color)';
                } else if (type === 'info') {
                    icon = 'info-circle';
                    color = 'var(--info-color)';
                }
                
                resultEl.innerHTML = `
                    <div style="display: flex; align-items: flex-start; gap: 1rem;">
                        <i class="fas fa-${icon}" style="font-size: 1.5rem; color: ${color};"></i>
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 0.5rem 0; color: ${color};">${title}</h4>
                            <div style="font-size: 0.9rem;">${content}</div>
                        </div>
                    </div>
                `;
                panel.style.display = 'block';
            }
        }
        
        // Hide NFC tool result panel
        function hideNFCToolResult() {
            const panel = document.getElementById('nfcToolResultPanel');
            if (panel) {
                panel.style.display = 'none';
            }
        }
        
        // Launch NFC tool operation
        async function launchNFCTool(tool) {
            console.log('Launching NFC tool:', tool);
            currentNFCTool = tool;
            hideNFCToolResult();
            
            // Highlight the selected tool button
            selectNFCToolBtn(tool);
            
            // Hide both read and write sections for non-read/write tools
            if (tool !== 'read' && tool !== 'write') {
                document.getElementById('readModeSection').style.display = 'none';
                document.getElementById('writeModeSection').style.display = 'none';
            }
            
            // Check if we should use external app
            const prefs = JSON.parse(localStorage.getItem('nfcAppPreferences') || '{}');
            if (prefs.preferredApp && prefs.preferredApp !== 'builtin') {
                // For operations not supported by web, use external app
                const unsupportedInWeb = ['erase', 'format', 'lock', 'copy'];
                if (unsupportedInWeb.includes(tool) || prefs.autoLaunch) {
                    openExternalNFCApp(tool);
                    return;
                }
            }
            
            switch (tool) {
                case 'read':
                    // Show read section
                    document.getElementById('readModeSection').style.display = 'block';
                    document.getElementById('writeModeSection').style.display = 'none';
                    await performNFCRead();
                    break;
                case 'write':
                    // Show write section
                    document.getElementById('readModeSection').style.display = 'none';
                    document.getElementById('writeModeSection').style.display = 'block';
                    break;
                case 'erase':
                    await performNFCErase();
                    break;
                case 'format':
                    await performNFCFormat();
                    break;
                case 'lock':
                    await performNFCLock();
                    break;
                case 'setPassword':
                    openSetPasswordModal();
                    break;
                case 'removePassword':
                    openRemovePasswordModal();
                    break;
                case 'copy':
                    await performNFCCopy();
                    break;
                case 'info':
                    await performNFCInfo();
                    break;
                default:
                    showNFCToolStatus('Unknown tool: ' + tool, 'error');
            }
        }
        
        // Perform NFC Read operation
        async function performNFCRead() {
            showNFCToolStatus('ðŸ“± Hold NFC tag near device to read...', 'writing');
            
            try {
                // Try native bridge first
                if (isWebViewApp || nativeNFCAvailable) {
                    if (requestNativeNFCScan()) {
                        // Native will call handleNativeNFC
                        return;
                    }
                }
                
                // Web NFC
                if ('NDEFReader' in window) {
                    const ndef = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    ndef.addEventListener('reading', ({ serialNumber, message }) => {
                        toolAbortController?.abort();
                        showNFCToolStatus('âœ… Tag read successfully!', 'success');
                        
                        // Display result
                        let recordsHtml = '';
                        for (const record of message.records) {
                            const decoder = new TextDecoder();
                            let data = '';
                            try {
                                data = decoder.decode(record.data);
                            } catch (e) {
                                data = '[Binary data]';
                            }
                            recordsHtml += `<div style="background: white; padding: 0.5rem; border-radius: 4px; margin-bottom: 0.5rem;">
                                <strong>${record.recordType}</strong>: ${escapeHtml(data.substring(0, 200))}${data.length > 200 ? '...' : ''}
                            </div>`;
                        }
                        
                        showNFCToolResult('Tag Contents', `
                            <p><strong>Serial:</strong> ${serialNumber || 'Unknown'}</p>
                            <p><strong>Records:</strong> ${message.records.length}</p>
                            ${recordsHtml}
                        `, 'success');
                    });
                    
                    await ndef.scan({ signal: toolAbortController.signal });
                } else {
                    showNFCToolStatus('âš ï¸ Web NFC not supported. Opening external app...', 'writing');
                    setTimeout(() => openExternalNFCApp('read'), 1000);
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('NFC Read error:', error);
                    if (isWebViewApp) {
                        showNFCToolStatus('ðŸ“± Waiting for NFC tag...', 'writing');
                    } else {
                        showNFCToolStatus('âŒ ' + error.message, 'error');
                    }
                }
            }
        }
        
        // Perform NFC Erase operation
        async function performNFCErase() {
            showNFCToolStatus('ðŸ“± Hold NFC tag near device to erase...', 'writing');
            
            try {
                // Try native bridge first
                if (isWebViewApp || nativeNFCAvailable) {
                    if (typeof window.AndroidNFC?.erase === 'function') {
                        window.AndroidNFC.erase();
                        return;
                    }
                    if (typeof window.Android?.eraseNFC === 'function') {
                        window.Android.eraseNFC();
                        return;
                    }
                }
                
                // Web NFC - write empty NDEF message
                if ('NDEFReader' in window) {
                    const ndef = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    // Write an empty text record (effectively clearing the tag)
                    await ndef.write({ records: [{ recordType: 'empty' }] }, { signal: toolAbortController.signal });
                    
                    playNFCFeedback();
                    showNFCToolStatus('âœ… Tag erased successfully!', 'success');
                    showNFCToolResult('Erase Complete', 'The NFC tag has been erased. All NDEF data has been removed.', 'success');
                } else {
                    showNFCToolStatus('âš ï¸ Opening NFC Tools app for erase...', 'writing');
                    openExternalNFCApp('erase');
                }
            } catch (error) {
                console.error('NFC Erase error:', error);
                if (isWebViewApp) {
                    showNFCToolStatus('ðŸ“± Hold tag near device to erase...', 'writing');
                } else {
                    showNFCToolStatus('âŒ ' + error.message, 'error');
                }
            }
        }
        
        // Perform NFC Format operation
        async function performNFCFormat() {
            showNFCToolStatus('ðŸ“± Hold NFC tag near device to format...', 'writing');
            
            try {
                // Try native bridge
                if (isWebViewApp || nativeNFCAvailable) {
                    if (typeof window.AndroidNFC?.format === 'function') {
                        window.AndroidNFC.format();
                        return;
                    }
                    if (typeof window.Android?.formatNFC === 'function') {
                        window.Android.formatNFC();
                        return;
                    }
                }
                
                // Web NFC cannot format - need external app
                showNFCToolStatus('âš ï¸ Format requires native app. Opening NFC Tools...', 'writing');
                setTimeout(() => openExternalNFCApp('format'), 1000);
            } catch (error) {
                console.error('NFC Format error:', error);
                showNFCToolStatus('âŒ ' + error.message, 'error');
            }
        }
        
        // Perform NFC Lock operation
        async function performNFCLock() {
            // Confirm before locking (permanent operation)
            if (!confirm('âš ï¸ WARNING: Locking an NFC tag is PERMANENT and cannot be undone. The tag will become read-only forever. Are you sure you want to continue?')) {
                return;
            }
            
            showNFCToolStatus('ðŸ“± Hold NFC tag near device to lock...', 'writing');
            
            try {
                // Try native bridge
                if (isWebViewApp || nativeNFCAvailable) {
                    if (typeof window.AndroidNFC?.lock === 'function') {
                        window.AndroidNFC.lock();
                        return;
                    }
                    if (typeof window.Android?.lockNFC === 'function') {
                        window.Android.lockNFC();
                        return;
                    }
                }
                
                // Web NFC - use makeReadOnly
                if ('NDEFReader' in window) {
                    const ndef = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    await ndef.makeReadOnly({ signal: toolAbortController.signal });
                    
                    playNFCFeedback();
                    showNFCToolStatus('âœ… Tag locked successfully!', 'success');
                    showNFCToolResult('Lock Complete', 'The NFC tag is now permanently read-only. This cannot be undone.', 'success');
                } else {
                    showNFCToolStatus('âš ï¸ Lock requires native app. Opening NFC Tools...', 'writing');
                    setTimeout(() => openExternalNFCApp('lock'), 1000);
                }
            } catch (error) {
                console.error('NFC Lock error:', error);
                if (isWebViewApp) {
                    showNFCToolStatus('ðŸ“± Hold tag near device to lock...', 'writing');
                } else {
                    showNFCToolStatus('âŒ ' + error.message, 'error');
                }
            }
        }
        
        // Perform NFC Copy operation
        async function performNFCCopy() {
            if (!copiedTagData) {
                // Step 1: Read source tag
                showNFCToolStatus('ðŸ“± Step 1: Hold SOURCE tag near device to copy FROM...', 'writing');
                
                try {
                    if ('NDEFReader' in window) {
                        const ndef = new NDEFReader();
                        toolAbortController = new AbortController();
                        
                        ndef.addEventListener('reading', ({ serialNumber, message }) => {
                            toolAbortController?.abort();
                            
                            // Store the read data
                            copiedTagData = {
                                serialNumber: serialNumber,
                                records: []
                            };
                            
                            for (const record of message.records) {
                                copiedTagData.records.push({
                                    recordType: record.recordType,
                                    mediaType: record.mediaType,
                                    data: record.data,
                                    encoding: record.encoding,
                                    lang: record.lang
                                });
                            }
                            
                            showNFCToolStatus('âœ… Tag copied! Now tap "Copy Tag" again and hold DESTINATION tag...', 'success');
                            showNFCToolResult('Source Tag Copied', `
                                <p><strong>Serial:</strong> ${serialNumber || 'Unknown'}</p>
                                <p><strong>Records:</strong> ${message.records.length}</p>
                                <p style="color: var(--warning-color);">Now tap "Copy Tag" again and hold the DESTINATION tag near the device.</p>
                            `, 'info');
                        });
                        
                        await ndef.scan({ signal: toolAbortController.signal });
                    } else {
                        showNFCToolStatus('âš ï¸ Copy requires native app. Opening NFC Tools...', 'writing');
                        openExternalNFCApp('copy');
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('NFC Copy read error:', error);
                        showNFCToolStatus('âŒ ' + error.message, 'error');
                    }
                }
            } else {
                // Step 2: Write to destination tag
                showNFCToolStatus('ðŸ“± Step 2: Hold DESTINATION tag near device to write TO...', 'writing');
                
                try {
                    if ('NDEFReader' in window) {
                        const ndef = new NDEFReader();
                        toolAbortController = new AbortController();
                        
                        // Build NDEF message from copied data
                        const records = copiedTagData.records.map(r => ({
                            recordType: r.recordType,
                            mediaType: r.mediaType,
                            data: r.data,
                            encoding: r.encoding,
                            lang: r.lang
                        }));
                        
                        await ndef.write({ records }, { signal: toolAbortController.signal });
                        
                        playNFCFeedback();
                        showNFCToolStatus('âœ… Tag cloned successfully!', 'success');
                        showNFCToolResult('Clone Complete', `
                            <p>Data from tag ${copiedTagData.serialNumber || 'Unknown'} has been copied to the destination tag.</p>
                            <p><strong>Records copied:</strong> ${copiedTagData.records.length}</p>
                        `, 'success');
                        
                        // Clear copied data
                        copiedTagData = null;
                    }
                } catch (error) {
                    console.error('NFC Copy write error:', error);
                    showNFCToolStatus('âŒ ' + error.message, 'error');
                }
            }
        }
        
        // Perform NFC Info operation
        async function performNFCInfo() {
            showNFCToolStatus('ðŸ“± Hold NFC tag near device to read info...', 'writing');
            
            try {
                // Try native bridge
                if (isWebViewApp || nativeNFCAvailable) {
                    if (typeof window.AndroidNFC?.getInfo === 'function') {
                        window.AndroidNFC.getInfo();
                        return;
                    }
                }
                
                // Web NFC
                if ('NDEFReader' in window) {
                    const ndef = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    ndef.addEventListener('reading', ({ serialNumber, message }) => {
                        toolAbortController?.abort();
                        showNFCToolStatus('âœ… Tag info retrieved!', 'success');
                        
                        // Calculate approximate data size
                        let totalSize = 0;
                        for (const record of message.records) {
                            if (record.data) {
                                totalSize += record.data.byteLength;
                            }
                        }
                        
                        showNFCToolResult('Tag Information', `
                            <table style="width: 100%; font-size: 0.9rem;">
                                <tr><td style="padding: 0.25rem 0;"><strong>Serial Number:</strong></td><td>${serialNumber || 'Unknown'}</td></tr>
                                <tr><td style="padding: 0.25rem 0;"><strong>NDEF Records:</strong></td><td>${message.records.length}</td></tr>
                                <tr><td style="padding: 0.25rem 0;"><strong>Data Size:</strong></td><td>${totalSize} bytes</td></tr>
                                <tr><td style="padding: 0.25rem 0;"><strong>Record Types:</strong></td><td>${[...new Set(message.records.map(r => r.recordType))].join(', ') || 'None'}</td></tr>
                            </table>
                            <p style="margin-top: 1rem; font-size: 0.8rem; color: var(--text-secondary);">
                                Note: For detailed tag specifications (type, memory, lock status), use the NFC Tools app.
                            </p>
                        `, 'info');
                    });
                    
                    await ndef.scan({ signal: toolAbortController.signal });
                } else {
                    showNFCToolStatus('âš ï¸ Opening NFC Tools for detailed info...', 'writing');
                    openExternalNFCApp('info');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('NFC Info error:', error);
                    if (isWebViewApp) {
                        showNFCToolStatus('ðŸ“± Waiting for NFC tag...', 'writing');
                    } else {
                        showNFCToolStatus('âŒ ' + error.message, 'error');
                    }
                }
            }
        }
        
        // Open external NFC app
        function openExternalNFCApp(action) {
            const prefs = JSON.parse(localStorage.getItem('nfcAppPreferences') || '{}');
            let packageName = '';
            
            // Determine which app to open
            if (prefs.preferredApp && prefs.preferredApp !== 'builtin') {
                if (prefs.preferredApp === 'custom' && prefs.customPackage) {
                    packageName = prefs.customPackage;
                } else {
                    packageName = NFC_APP_PACKAGES[prefs.preferredApp] || NFC_APP_PACKAGES.nfctools;
                }
            } else {
                packageName = NFC_APP_PACKAGES.nfctools; // Default to NFC Tools
            }
            
            console.log('Opening external NFC app:', packageName, 'action:', action);
            
            // Try various methods to open the app
            
            // Method 1: Android Intent URL
            const intentUrl = `intent://#Intent;package=${packageName};end`;
            
            // Method 2: Native bridge
            if (typeof window.Android?.openApp === 'function') {
                window.Android.openApp(packageName);
                showNFCToolStatus(`ðŸ“± Opening ${packageName}...`, 'writing');
                return;
            }
            
            if (typeof window.AndroidNFC?.openApp === 'function') {
                window.AndroidNFC.openApp(packageName);
                showNFCToolStatus(`ðŸ“± Opening ${packageName}...`, 'writing');
                return;
            }
            
            // Method 3: Try to open via intent URL
            try {
                window.location.href = intentUrl;
                showNFCToolStatus(`ðŸ“± Opening NFC app...`, 'writing');
            } catch (e) {
                // Method 4: Fallback - open Play Store
                const playStoreUrl = `https://play.google.com/store/apps/details?id=${packageName}`;
                showNFCToolResult('External App Required', `
                    <p>This operation requires an external NFC app.</p>
                    <p style="margin: 1rem 0;">
                        <a href="${playStoreUrl}" target="_blank" class="btn btn-primary" style="display: inline-flex; align-items: center; gap: 0.5rem; text-decoration: none;">
                            <i class="fab fa-google-play"></i> Install from Play Store
                        </a>
                    </p>
                    <p style="font-size: 0.85rem; color: var(--text-secondary);">
                        If the app is already installed, open it manually and use the "${action}" feature.
                    </p>
                `, 'info');
            }
        }
        
        // Play NFC feedback (sound and/or vibration)
        function playNFCFeedback() {
            const prefs = JSON.parse(localStorage.getItem('nfcAppPreferences') || '{}');
            
            // Vibration
            if ((prefs.enableVibration !== false) && 'vibrate' in navigator) {
                navigator.vibrate([100, 50, 100]);
            }
            
            // Sound (using Web Audio API)
            if (prefs.enableSound !== false) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.1;
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                } catch (e) {
                    console.log('Could not play sound:', e);
                }
            }
        }
        
        // Handler for native NFC tool results
        window.onNativeNFCToolResult = function(tool, success, data) {
            console.log('Native NFC tool result:', { tool, success, data });
            
            if (success) {
                playNFCFeedback();
                showNFCToolStatus(`âœ… ${tool} completed successfully!`, 'success');
                
                if (typeof data === 'string') {
                    try {
                        data = JSON.parse(data);
                    } catch (e) {}
                }
                
                if (data) {
                    showNFCToolResult(`${tool} Result`, `<pre style="white-space: pre-wrap;">${JSON.stringify(data, null, 2)}</pre>`, 'success');
                }
            } else {
                showNFCToolStatus(`âŒ ${tool} failed: ${data || 'Unknown error'}`, 'error');
            }
        };
        
        // =============================================
        // Password Management Functions
        // =============================================
        
        let setPasswordTagData = null;
        let removePasswordTagHash = null;
        let removePasswordTagData = null;
        
        // Open Set Password Modal
        function openSetPasswordModal() {
            document.getElementById('setPasswordModal').style.display = 'flex';
            document.getElementById('newTagPassword').value = '';
            document.getElementById('confirmTagPassword').value = '';
            document.getElementById('preserveTagData').checked = true;
            document.getElementById('setPasswordError').style.display = 'none';
            document.getElementById('setPasswordStatus').style.display = 'none';
            document.getElementById('setPasswordBtn').disabled = false;
            document.getElementById('newTagPassword').focus();
            setPasswordTagData = null;
        }
        
        // Close Set Password Modal
        function closeSetPasswordModal() {
            document.getElementById('setPasswordModal').style.display = 'none';
            setPasswordTagData = null;
            if (toolAbortController) {
                toolAbortController.abort();
                toolAbortController = null;
            }
        }
        
        // Toggle new password visibility
        function toggleNewPasswordVisibility() {
            const input = document.getElementById('newTagPassword');
            const icon = document.getElementById('newPasswordToggleIcon');
            if (input.type === 'password') {
                input.type = 'text';
                icon.className = 'fas fa-eye-slash';
            } else {
                input.type = 'password';
                icon.className = 'fas fa-eye';
            }
        }
        
        // Execute set password
        async function executeSetPassword() {
            const newPassword = document.getElementById('newTagPassword').value;
            const confirmPassword = document.getElementById('confirmTagPassword').value;
            const preserveData = document.getElementById('preserveTagData').checked;
            const errorEl = document.getElementById('setPasswordError');
            const statusEl = document.getElementById('setPasswordStatus');
            const setBtn = document.getElementById('setPasswordBtn');
            
            // Validate
            if (!newPassword || newPassword.length < 4) {
                errorEl.textContent = 'Password must be at least 4 characters.';
                errorEl.style.display = 'block';
                return;
            }
            
            if (newPassword !== confirmPassword) {
                errorEl.textContent = 'Passwords do not match.';
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            statusEl.textContent = 'ðŸ“± Hold NFC tag near device...';
            statusEl.className = 'write-status writing';
            statusEl.style.display = 'block';
            setBtn.disabled = true;
            
            try {
                // Try native bridge first
                if (isWebViewApp || nativeNFCAvailable) {
                    if (typeof window.AndroidNFC?.setPassword === 'function') {
                        window.AndroidNFC.setPassword(newPassword, preserveData);
                        return;
                    }
                    if (typeof window.Android?.setNFCPassword === 'function') {
                        window.Android.setNFCPassword(newPassword, preserveData);
                        return;
                    }
                }
                
                // Web NFC implementation
                if ('NDEFReader' in window) {
                    const ndef = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    if (preserveData) {
                        // First read existing data
                        statusEl.textContent = 'ðŸ“± Reading existing tag data...';
                        
                        await new Promise((resolve, reject) => {
                            ndef.addEventListener('reading', async ({ serialNumber, message }) => {
                                try {
                                    toolAbortController?.abort();
                                    
                                    // Store existing records (excluding any password records)
                                    setPasswordTagData = [];
                                    for (const record of message.records) {
                                        if (record.mediaType !== 'application/x-nfc-password' && 
                                            !(record.mediaType === 'application/octet-stream' && 
                                              new TextDecoder().decode(record.data).startsWith('DXP:'))) {
                                            setPasswordTagData.push({
                                                recordType: record.recordType,
                                                mediaType: record.mediaType,
                                                data: record.data,
                                                encoding: record.encoding,
                                                lang: record.lang
                                            });
                                        }
                                    }
                                    
                                    resolve();
                                } catch (e) {
                                    reject(e);
                                }
                            }, { once: true });
                            
                            ndef.scan({ signal: toolAbortController.signal }).catch(reject);
                            
                            setTimeout(() => reject(new Error('Timeout waiting for tag')), 30000);
                        });
                    }
                    
                    // Now write with password
                    statusEl.textContent = 'ðŸ“± Writing password to tag...';
                    
                    const ndef2 = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    // Build records array
                    const records = [];
                    
                    // Add password record
                    const passwordHash = await hashPassword(newPassword);
                    records.push({
                        recordType: 'mime',
                        mediaType: 'application/x-nfc-password',
                        data: new TextEncoder().encode(passwordHash)
                    });
                    
                    // Add preserved data if any
                    if (setPasswordTagData && setPasswordTagData.length > 0) {
                        for (const record of setPasswordTagData) {
                            records.push(record);
                        }
                    }
                    
                    await ndef2.write({ records }, { signal: toolAbortController.signal });
                    
                    playNFCFeedback();
                    statusEl.textContent = 'âœ… Password set successfully!';
                    statusEl.className = 'write-status success';
                    
                    showNFCToolResult('Password Set', `
                        <p>The NFC tag is now password protected.</p>
                        <p style="margin-top: 0.5rem;"><strong>Important:</strong> Remember your password! You'll need it to modify or remove protection.</p>
                        ${setPasswordTagData && setPasswordTagData.length > 0 ? 
                            `<p style="margin-top: 0.5rem;">Preserved ${setPasswordTagData.length} existing record(s).</p>` : ''}
                    `, 'success');
                    
                    setTimeout(() => closeSetPasswordModal(), 2000);
                    
                } else {
                    statusEl.textContent = 'âš ï¸ Opening NFC Tools app...';
                    statusEl.className = 'write-status writing';
                    openExternalNFCApp('setPassword');
                }
                
            } catch (error) {
                console.error('Set password error:', error);
                if (error.name === 'AbortError') {
                    statusEl.style.display = 'none';
                } else if (isWebViewApp) {
                    statusEl.textContent = 'ðŸ“± Hold tag near device...';
                    statusEl.className = 'write-status writing';
                } else {
                    errorEl.textContent = error.message || 'Failed to set password';
                    errorEl.style.display = 'block';
                    statusEl.style.display = 'none';
                }
            } finally {
                setBtn.disabled = false;
            }
        }
        
        // Open Remove Password Modal
        function openRemovePasswordModal() {
            document.getElementById('removePasswordModal').style.display = 'flex';
            document.getElementById('currentTagPassword').value = '';
            document.getElementById('preserveTagDataOnRemove').checked = true;
            document.getElementById('removePasswordError').style.display = 'none';
            document.getElementById('removePasswordStatus').style.display = 'none';
            document.getElementById('removePasswordBtn').disabled = false;
            document.getElementById('currentTagPassword').focus();
            removePasswordTagHash = null;
            removePasswordTagData = null;
        }
        
        // Close Remove Password Modal
        function closeRemovePasswordModal() {
            document.getElementById('removePasswordModal').style.display = 'none';
            removePasswordTagHash = null;
            removePasswordTagData = null;
            if (toolAbortController) {
                toolAbortController.abort();
                toolAbortController = null;
            }
        }
        
        // Toggle current password visibility
        function toggleCurrentPasswordVisibility() {
            const input = document.getElementById('currentTagPassword');
            const icon = document.getElementById('currentPasswordToggleIcon');
            if (input.type === 'password') {
                input.type = 'text';
                icon.className = 'fas fa-eye-slash';
            } else {
                input.type = 'password';
                icon.className = 'fas fa-eye';
            }
        }
        
        // Execute remove password
        async function executeRemovePassword() {
            const currentPassword = document.getElementById('currentTagPassword').value;
            const preserveData = document.getElementById('preserveTagDataOnRemove').checked;
            const errorEl = document.getElementById('removePasswordError');
            const statusEl = document.getElementById('removePasswordStatus');
            const removeBtn = document.getElementById('removePasswordBtn');
            
            if (!currentPassword) {
                errorEl.textContent = 'Please enter the current password.';
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            statusEl.textContent = 'ðŸ“± Hold NFC tag near device...';
            statusEl.className = 'write-status writing';
            statusEl.style.display = 'block';
            removeBtn.disabled = true;
            
            try {
                // Try native bridge first
                if (isWebViewApp || nativeNFCAvailable) {
                    if (typeof window.AndroidNFC?.removePassword === 'function') {
                        window.AndroidNFC.removePassword(currentPassword, preserveData);
                        return;
                    }
                    if (typeof window.Android?.removeNFCPassword === 'function') {
                        window.Android.removeNFCPassword(currentPassword, preserveData);
                        return;
                    }
                }
                
                // Web NFC implementation
                if ('NDEFReader' in window) {
                    const ndef = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    // First read the tag to verify password and get data
                    statusEl.textContent = 'ðŸ“± Reading tag to verify password...';
                    
                    await new Promise((resolve, reject) => {
                        ndef.addEventListener('reading', async ({ serialNumber, message }) => {
                            try {
                                toolAbortController?.abort();
                                
                                // Find password record and verify
                                let foundPassword = false;
                                removePasswordTagData = [];
                                
                                for (const record of message.records) {
                                    const decoder = new TextDecoder();
                                    let recordData = '';
                                    try {
                                        recordData = decoder.decode(record.data);
                                    } catch (e) {}
                                    
                                    // Check for password record
                                    if (record.mediaType === 'application/x-nfc-password') {
                                        removePasswordTagHash = recordData;
                                        foundPassword = true;
                                    } else if (record.mediaType === 'application/octet-stream' && recordData.startsWith('DXP:')) {
                                        removePasswordTagHash = recordData.substring(4);
                                        foundPassword = true;
                                    } else if (preserveData) {
                                        // Store non-password records
                                        removePasswordTagData.push({
                                            recordType: record.recordType,
                                            mediaType: record.mediaType,
                                            data: record.data,
                                            encoding: record.encoding,
                                            lang: record.lang
                                        });
                                    }
                                }
                                
                                if (!foundPassword) {
                                    reject(new Error('This tag is not password protected.'));
                                    return;
                                }
                                
                                // Verify password
                                const enteredHash = await hashPassword(currentPassword);
                                if (enteredHash !== removePasswordTagHash) {
                                    reject(new Error('Incorrect password.'));
                                    return;
                                }
                                
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        }, { once: true });
                        
                        ndef.scan({ signal: toolAbortController.signal }).catch(reject);
                        
                        setTimeout(() => reject(new Error('Timeout waiting for tag')), 30000);
                    });
                    
                    // Password verified - now write without password
                    statusEl.textContent = 'ðŸ“± Removing password...';
                    
                    const ndef2 = new NDEFReader();
                    toolAbortController = new AbortController();
                    
                    // Build records array (without password)
                    let records = [];
                    
                    if (preserveData && removePasswordTagData && removePasswordTagData.length > 0) {
                        records = removePasswordTagData;
                    } else {
                        // Write empty record if no data to preserve
                        records = [{ recordType: 'text', data: '' }];
                    }
                    
                    await ndef2.write({ records }, { signal: toolAbortController.signal });
                    
                    playNFCFeedback();
                    statusEl.textContent = 'âœ… Password removed successfully!';
                    statusEl.className = 'write-status success';
                    
                    showNFCToolResult('Password Removed', `
                        <p>The password protection has been removed from this NFC tag.</p>
                        ${preserveData && removePasswordTagData && removePasswordTagData.length > 0 ? 
                            `<p style="margin-top: 0.5rem;">Preserved ${removePasswordTagData.length} existing record(s).</p>` : 
                            '<p style="margin-top: 0.5rem;">Tag data was cleared.</p>'}
                    `, 'success');
                    
                    setTimeout(() => closeRemovePasswordModal(), 2000);
                    
                } else {
                    statusEl.textContent = 'âš ï¸ Opening NFC Tools app...';
                    statusEl.className = 'write-status writing';
                    openExternalNFCApp('removePassword');
                }
                
            } catch (error) {
                console.error('Remove password error:', error);
                if (error.name === 'AbortError') {
                    statusEl.style.display = 'none';
                } else if (error.message === 'Incorrect password.') {
                    errorEl.textContent = 'Incorrect password. Please try again.';
                    errorEl.style.display = 'block';
                    statusEl.style.display = 'none';
                    document.getElementById('currentTagPassword').value = '';
                    document.getElementById('currentTagPassword').focus();
                } else if (error.message === 'This tag is not password protected.') {
                    errorEl.textContent = 'This tag is not password protected.';
                    errorEl.style.display = 'block';
                    statusEl.style.display = 'none';
                } else if (isWebViewApp) {
                    statusEl.textContent = 'ðŸ“± Hold tag near device...';
                    statusEl.className = 'write-status writing';
                } else {
                    errorEl.textContent = error.message || 'Failed to remove password';
                    errorEl.style.display = 'block';
                    statusEl.style.display = 'none';
                }
            } finally {
                removeBtn.disabled = false;
            }
        }
        
        // Native callback for password operations
        window.onNativePasswordResult = function(operation, success, message) {
            console.log('Native password result:', { operation, success, message });
            
            if (operation === 'setPassword') {
                const statusEl = document.getElementById('setPasswordStatus');
                const errorEl = document.getElementById('setPasswordError');
                
                if (success) {
                    playNFCFeedback();
                    statusEl.textContent = 'âœ… Password set successfully!';
                    statusEl.className = 'write-status success';
                    showNFCToolResult('Password Set', 'The NFC tag is now password protected.', 'success');
                    setTimeout(() => closeSetPasswordModal(), 2000);
                } else {
                    errorEl.textContent = message || 'Failed to set password';
                    errorEl.style.display = 'block';
                    statusEl.style.display = 'none';
                }
                document.getElementById('setPasswordBtn').disabled = false;
                
            } else if (operation === 'removePassword') {
                const statusEl = document.getElementById('removePasswordStatus');
                const errorEl = document.getElementById('removePasswordError');
                
                if (success) {
                    playNFCFeedback();
                    statusEl.textContent = 'âœ… Password removed successfully!';
                    statusEl.className = 'write-status success';
                    showNFCToolResult('Password Removed', 'The password protection has been removed.', 'success');
                    setTimeout(() => closeRemovePasswordModal(), 2000);
                } else {
                    errorEl.textContent = message || 'Failed to remove password';
                    errorEl.style.display = 'block';
                    statusEl.style.display = 'none';
                }
                document.getElementById('removePasswordBtn').disabled = false;
            }
        };

        // Write History Management - Firebase Storage
        async function loadWriteHistory() {
            const tbody = document.getElementById('recordTableBody');
            tbody.innerHTML = `
                <tr>
                    <td colspan="7" class="record-empty">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Loading records...</p>
                    </td>
                </tr>
            `;
            
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    renderWriteHistory();
                    return;
                }
                
                const snapshot = await db.ref(`companies/${currentUser.companyId}/nfcRecords`).orderByChild('timestamp').once('value');
                writeHistory = [];
                
                if (snapshot.exists()) {
                    snapshot.forEach(child => {
                        writeHistory.push({
                            id: child.key,
                            ...child.val()
                        });
                    });
                    // Sort by timestamp descending (newest first)
                    writeHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                }
                
                renderWriteHistory();
            } catch (error) {
                console.error('Error loading write history:', error);
                renderWriteHistory();
            }
        }

        async function addWriteRecord(record) {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    console.warn('No user or company ID - cannot save record');
                    return;
                }
                
                const newRecord = {
                    timestamp: new Date().toISOString(),
                    type: record.type || 'unknown',
                    name: record.name || '-',
                    organization: record.organization || '-',
                    status: 'success',
                    encrypted: record.encrypted || false,
                    passwordProtected: record.passwordProtected || false,
                    writtenBy: currentUser.uid || 'unknown',
                    writerName: currentUser.displayName || currentUser.email || 'Unknown User'
                };
                
                // Save to Firebase
                await db.ref(`companies/${currentUser.companyId}/nfcRecords`).push(newRecord);
                
                // Add to local array for immediate display
                writeHistory.unshift({ id: Date.now().toString(), ...newRecord });
                renderWriteHistory();
                
                console.log('âœ… NFC record saved to Firebase');
            } catch (error) {
                console.error('Error saving write record:', error);
            }
        }

        async function clearWriteHistory() {
            if (!confirm('Are you sure you want to clear all write history? This cannot be undone.')) {
                return;
            }
            
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    return;
                }
                
                // Clear from Firebase
                await db.ref(`companies/${currentUser.companyId}/nfcRecords`).remove();
                
                writeHistory = [];
                renderWriteHistory();
                
                console.log('âœ… NFC records cleared from Firebase');
            } catch (error) {
                console.error('Error clearing write history:', error);
                alert('Error clearing records. Please try again.');
            }
        }

        function renderWriteHistory() {
            const tbody = document.getElementById('recordTableBody');
            
            if (!tbody) return;
            
            if (writeHistory.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" class="record-empty">
                            <i class="fas fa-inbox"></i>
                            <p>No write records yet</p>
                            <p style="font-size: 0.85rem;">Records will appear here after you write to NFC cards</p>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = writeHistory.map((record, index) => {
                const date = new Date(record.timestamp);
                const formattedDate = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                const typeBadge = {
                    'text': '<span class="badge badge-info">Text</span>',
                    'url': '<span class="badge badge-info">URL</span>',
                    'json': '<span class="badge badge-warning">JSON</span>',
                    'vcard': '<span class="badge badge-success">vCard</span>'
                }[record.type] || '<span class="badge badge-info">Unknown</span>';

                const securityBadges = [];
                if (record.encrypted) securityBadges.push('<span class="badge badge-success">ðŸ” Encrypted</span>');
                if (record.passwordProtected) securityBadges.push('<span class="badge badge-warning">ðŸ”’ Password</span>');
                const securityHtml = securityBadges.length > 0 ? securityBadges.join(' ') : '<span style="color: var(--text-secondary);">-</span>';

                const performer = record.writerName || record.scannerName || '-';
                return `
                    <tr>
                        <td>${writeHistory.length - index}</td>
                        <td>${formattedDate}</td>
                        <td>${typeBadge}</td>
                        <td>${escapeHtml(record.name || '-')}</td>
                        <td>${escapeHtml(record.organization || '-')}</td>
                        <td><code style="font-size: 0.85em; background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px;">${escapeHtml(record.serialNumber || '-')}</code></td>
                        <td>${escapeHtml(record.cardId || '-')}</td>
                        <td>${escapeHtml(performer)}</td>
                        <td>${securityHtml}</td>
                    </tr>
                `;
            }).join('');
        }

        // Extract summary (name, organization, type) from parsed card data
        function summarizeCardData(cardData) {
            let name = '-';
            let organization = '-';
            let type = 'unknown';

            for (const r of (cardData.records || [])) {
                // Get display data - handle various formats from native and web
                const displayData = r.displayData || r.data || '';
                const data = (typeof displayData === 'string') ? displayData : '';
                
                // Prefer vCard
                if ((r.mediaType === 'text/vcard') || (/BEGIN:VCARD/i.test(data))) {
                    type = 'vcard';
                    const fnMatch = data.match(/\nFN:(.*)/i) || data.match(/FN:(.*)/i) || data.match(/\nN:(.*)/i);
                    if (fnMatch && fnMatch[1]) {
                        name = fnMatch[1].trim();
                    } else if (name === '-' && data.length) {
                        name = data.substring(0, 50);
                    }
                    const orgMatch = data.match(/\nORG:(.*)/i) || data.match(/ORG:(.*)/i);
                    if (orgMatch && orgMatch[1]) {
                        organization = orgMatch[1].trim();
                    }
                    break;
                }
                // URL
                if (r.isUrl || r.type === 'url' || data.startsWith('http://') || data.startsWith('https://')) {
                    type = 'url';
                    name = data ? data.substring(0, 50) : 'URL';
                }
                // Text
                if ((r.type === 'text' && !r.isUrl && type === 'unknown') || type === 'unknown') {
                    type = 'text';
                    name = data ? data.substring(0, 50) : '-';
                }
                // JSON
                if ((r.mediaType === 'application/json') && type === 'unknown') {
                    type = 'json';
                    name = 'JSON Data';
                }
            }

            // Encryption / password flags
            const encrypted = (cardData.records || []).some(r => r.encrypted === true);
            const passwordProtected = (cardData.records || []).some(r => r.isPasswordRecord === true);

            return { name, organization, type, encrypted, passwordProtected };
        }

        // Generate a deterministic 12-digit numeric Card ID from serial + company salt
        async function generateCardId(serialNumber) {
            try {
                const companyId = window.authManager?.currentUser?.companyId || 'default';
                const encoder = new TextEncoder();
                const data = encoder.encode(`${serialNumber}|${companyId}|dx_card_uid_v1`);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const bytes = new Uint8Array(hashBuffer).slice(0, 6); // 48-bit
                let num = 0;
                for (let i = 0; i < bytes.length; i++) {
                    num = (num << 8) + bytes[i];
                }
                const idNum = num % 1000000000000; // 12 digits
                return String(idNum).padStart(12, '0');
            } catch (e) {
                console.error('generateCardId error:', e);
                return '000000000000';
            }
        }

        // --- Settings: Assign Card to Employee ---
        let assignmentScanController = null;
        let cardIdSerialMap = {};
        function showAssignStatus(message, type) {
            const status = document.getElementById('assignStatus');
            if (!status) return;
            status.textContent = message;
            status.className = 'write-status ' + (type || 'writing');
        }

        async function populateCardIdDropdown() {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser?.companyId) return;
                const select = document.getElementById('assignCardId');
                if (!select) return;
                select.innerHTML = '<option value="">-- Select Card --</option>';
                cardIdSerialMap = {};
                const snap = await db.ref(`companies/${currentUser.companyId}/nfcRecords`).orderByChild('timestamp').once('value');
                const latestByCardId = {};
                if (snap.exists()) {
                    snap.forEach(child => {
                        const val = child.val();
                        const cid = val.cardId || null;
                        if (!cid) return;
                        const ts = new Date(val.timestamp || 0).getTime();
                        if (!latestByCardId[cid] || ts > latestByCardId[cid].ts) {
                            latestByCardId[cid] = { ts, serialNumber: val.serialNumber || '-' };
                        }
                    });
                }
                const options = Object.keys(latestByCardId).sort().map(cid => {
                    const serial = latestByCardId[cid].serialNumber || '-';
                    cardIdSerialMap[cid] = serial;
                    const label = `${cid} ${serial !== '-' ? `(Serial: ${serial})` : ''}`;
                    return `<option value="${cid}">${label}</option>`;
                }).join('');
                select.innerHTML += options || '';
            } catch (e) {
                console.error('populateCardIdDropdown error', e);
            }
        }

        async function scanCardForAssignment() {
            try {
                const ndef = new NDEFReader();
                assignmentScanController = new AbortController();
                showAssignStatus('Scanning... hold a card near the device', 'writing');
                
                ndef.addEventListener('reading', async ({ serialNumber }) => {
                    try {
                        if (assignmentScanController) assignmentScanController.abort();
                    } catch {}
                    const serial = serialNumber || 'Unknown';
                    document.getElementById('assignSerial').value = serial;
                    const cardId = await generateCardId(serial);
                    document.getElementById('assignCardId').value = cardId;
                    if ('vibrate' in navigator) navigator.vibrate(200);
                    showAssignStatus('Card scanned. Ready to assign.', 'success');
                }, { once: true });
                
                await ndef.scan({ signal: assignmentScanController.signal });
            } catch (err) {
                console.error('scanCardForAssignment error', err);
                showAssignStatus(err.message || 'Error scanning card', 'error');
            }
        }

        async function assignCardToEmployee() {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    showAssignStatus('Not authenticated or no company context.', 'error');
                    return;
                }
                const org = document.getElementById('assignOrg').value;
                const empSelect = document.getElementById('assignEmployee');
                const employeeId = empSelect.value;
                const employeeName = empSelect.selectedOptions[0]?.text || '';
                const cardId = document.getElementById('assignCardId').value;
                
                if (!org) { showAssignStatus('Select an organization.', 'error'); return; }
                if (!employeeId) { showAssignStatus('Select an employee.', 'error'); return; }
                if (!cardId) { showAssignStatus('Select a card ID.', 'error'); return; }
                const serial = cardIdSerialMap[cardId] || '-';
                
                const assignment = {
                    cardId,
                    serialNumber: serial,
                    organization: org,
                    employeeId,
                    employeeName,
                    assignedAt: new Date().toISOString(),
                    assignedBy: currentUser.uid,
                    assignedByName: currentUser.displayName || currentUser.email || 'Unknown User'
                };
                
                await db.ref(`companies/${currentUser.companyId}/cardAssignments/${cardId}`).set(assignment);
                showAssignStatus('âœ… Card assigned successfully.', 'success');
                // Realtime listener will automatically update the table
            } catch (e) {
                console.error('assignCardToEmployee error', e);
                showAssignStatus('Error assigning card.', 'error');
            }
        }

        function renderAssignmentsTableRowPrepend(a) {
            const tbody = document.getElementById('assignmentsTableBody');
            if (!tbody) return;
            // remove empty state if any
            if (tbody.querySelector('.record-empty')) tbody.innerHTML = '';
            const date = new Date(a.assignedAt);
            const formattedDate = date.toLocaleString('en-US', { year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>â€”</td>
                <td>${formattedDate}</td>
                <td>${a.cardId}</td>
                <td>${a.serialNumber}</td>
                <td>${escapeHtml(a.employeeName || '-')}</td>
                <td>${escapeHtml(a.organization || '-')}</td>
                <td>${escapeHtml(a.assignedByName || '-')}</td>
                <td>
                    <button class="btn btn-danger" style="padding:.25rem .5rem;font-size:.8rem" onclick="unassignCard('${a.cardId}')"><i class="fas fa-times"></i> Unassign</button>
                </td>`;
            tbody.prepend(row);
        }

        function renderAssignmentsTable(list) {
            const tbody = document.getElementById('assignmentsTableBody');
            if (!tbody) return;
            if (!list || list.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" class="record-empty">
                            <i class="fas fa-inbox"></i>
                            <p>No assignments yet</p>
                            <p style="font-size: 0.85rem;">Scan and assign a card to an employee</p>
                        </td>
                    </tr>`;
                return;
            }
            tbody.innerHTML = list.map((a, idx) => {
                const date = new Date(a.assignedAt || a.timestamp || Date.now());
                const formattedDate = date.toLocaleString('en-US', { year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
                return `
                    <tr>
                        <td>${list.length - idx}</td>
                        <td>${formattedDate}</td>
                        <td>${a.cardId || '-'}</td>
                        <td>${a.serialNumber || '-'}</td>
                        <td>${escapeHtml(a.employeeName || '-')}</td>
                        <td>${escapeHtml(a.organization || '-')}</td>
                        <td>${escapeHtml(a.assignedByName || '-')}</td>
                        <td>
                            <button class="btn btn-danger" style="padding:.25rem .5rem;font-size:.8rem" onclick="unassignCard('${a.cardId}')"><i class="fas fa-times"></i> Unassign</button>
                        </td>
                    </tr>`;
            }).join('');
        }

        async function loadAssignments() {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser?.companyId) return;
                // Populate organizations each time Settings tab opens
                populateAssignOrganizations();
                // Populate card ID dropdown from records
                await populateCardIdDropdown();
                const snap = await db.ref(`companies/${currentUser.companyId}/cardAssignments`).once('value');
                const list = [];
                if (snap.exists()) {
                    snap.forEach(child => list.push({ cardId: child.key, ...child.val() }));
                    list.sort((a,b) => new Date(b.assignedAt||b.timestamp) - new Date(a.assignedAt||a.timestamp));
                }
                renderAssignmentsTable(list);
                // Ensure realtime listener is active
                setupAssignmentsRealtimeListener();
            } catch (e) {
                console.error('loadAssignments error', e);
                renderAssignmentsTable([]);
            }
        }

        let assignmentsRef = null;
        function setupAssignmentsRealtimeListener() {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser?.companyId) return;
                if (assignmentsRef) assignmentsRef.off();
                assignmentsRef = db.ref(`companies/${currentUser.companyId}/cardAssignments`);
                assignmentsRef.on('value', snapshot => {
                    const list = [];
                    snapshot.forEach(child => list.push({ cardId: child.key, ...child.val() }));
                    list.sort((a,b) => new Date(b.assignedAt||b.timestamp) - new Date(a.assignedAt||a.timestamp));
                    renderAssignmentsTable(list);
                });
            } catch (e) {
                console.error('setupAssignmentsRealtimeListener error', e);
            }
        }

        async function unassignCard(cardId) {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser?.companyId) return;
                await db.ref(`companies/${currentUser.companyId}/cardAssignments/${cardId}`).remove();
            } catch (e) {
                console.error('unassignCard error', e);
                alert('Failed to unassign card');
            }
        }

        async function onAssignOrganizationChange() {
            const orgSelect = document.getElementById('assignOrg');
            const empSelect = document.getElementById('assignEmployee');
            const selectedOrg = orgSelect.value;
            
            // Reset employee dropdown
            empSelect.innerHTML = '<option value="">-- Loading employees... --</option>';
            
            if (!selectedOrg) {
                empSelect.innerHTML = '<option value="">-- Select Organization First --</option>';
                return;
            }
            
            // Check if we already have employees for this organization
            if (employeesMap[selectedOrg] && employeesMap[selectedOrg].length > 0) {
                populateAssignEmployeeDropdown(employeesMap[selectedOrg]);
                return;
            }
            
            // Find the organization in our list
            const org = companiesList.find(c => c.name === selectedOrg);
            
            if (!org) {
                empSelect.innerHTML = '<option value="">-- No employees found --</option>';
                return;
            }
            
            // Use fetchCompanyUsers to get employees filtered by employerCompanyId
            try {
                const employees = await fetchCompanyUsers(org.id);
                employeesMap[selectedOrg] = employees;
                populateAssignEmployeeDropdown(employees);
            } catch (error) {
                console.error('Error loading employees for assignment:', error);
                empSelect.innerHTML = '<option value="">-- Error loading employees --</option>';
            }
        }
        
        function populateAssignEmployeeDropdown(employees) {
            const empSelect = document.getElementById('assignEmployee');
            if (!employees || employees.length === 0) {
                empSelect.innerHTML = '<option value="">-- No employees found --</option>';
                return;
            }
            
            empSelect.innerHTML = '<option value="">-- Select Employee --</option>' + 
                employees.map(e => `<option value="${e.id}" data-name="${escapeHtml(e.name || '')}" data-phone="${escapeHtml(e.phone || '')}" data-email="${escapeHtml(e.email || '')}" data-title="${escapeHtml(e.jobTitle || '')}">${escapeHtml(e.name || 'Unknown')}</option>`).join('');
        }
        
        function onAssignEmployeeChange() {
            // Get selected employee data if needed for display
            const empSelect = document.getElementById('assignEmployee');
            const selectedOption = empSelect.options[empSelect.selectedIndex];
            if (selectedOption && selectedOption.value) {
                // Can access data attributes: selectedOption.dataset.name, .phone, .email, .title
                console.log('Selected employee for assignment:', selectedOption.dataset.name);
            }
        }

        function populateAssignOrganizations() {
            const select = document.getElementById('assignOrg');
            if (!select) return;
            
            // Use the same companiesList as vCard dropdown with the same format
            select.innerHTML = '<option value="">-- Select Organization --</option>';
            
            (companiesList || []).forEach(c => {
                const option = document.createElement('option');
                option.value = c.name;
                option.textContent = c.name;
                // Show industry for main company, registration for subcontractors (same as vCard)
                if (c.type === 'main' && c.industry) {
                    option.textContent += ` (${c.industry})`;
                } else if (c.type === 'subcontractor' && c.registrationNumber) {
                    option.textContent += ` (Reg: ${c.registrationNumber})`;
                }
                select.appendChild(option);
            });
        }

        // Save scan record to Firebase (permanent)
        async function addScanRecordFirebase(cardData) {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    console.warn('addScanRecordFirebase: No user/companyId; cannot save');
                    console.log('Current authManager state:', window.authManager?.currentUser);
                    return false;
                }

                console.log('ðŸ’¾ Saving NFC record to Firebase...', { companyId: currentUser.companyId });

                const summary = summarizeCardData(cardData);
                const cardId = await generateCardId(cardData.serialNumber || 'Unknown');
                const newRecord = {
                    timestamp: cardData.timestamp || new Date().toISOString(),
                    type: summary.type || 'unknown',
                    name: summary.name || '-',
                    organization: summary.organization || '-',
                    status: 'scan',
                    encrypted: summary.encrypted || false,
                    passwordProtected: summary.passwordProtected || false,
                    scannedBy: currentUser.uid || 'unknown',
                    scannerName: currentUser.displayName || currentUser.email || 'Unknown User',
                    serialNumber: cardData.serialNumber || 'Unknown',
                    recordCount: cardData.recordCount || (cardData.records ? cardData.records.length : 0),
                    cardId: cardId,
                    source: cardData.source || 'web'
                };

                console.log('ðŸ“ Record to save:', newRecord);

                await db.ref(`companies/${currentUser.companyId}/nfcRecords`).push(newRecord);

                // Update local state immediately for UI responsiveness
                writeHistory.unshift({ id: Date.now().toString(), ...newRecord });
                renderWriteHistory();
                
                console.log('âœ… NFC record saved successfully');
                return true;
            } catch (err) {
                console.error('âŒ Failed to save scan record:', err);
                return false;
            }
        }

        // Queue a permanent lock request to be finalized by the mobile app
        async function queuePermanentLock(serialNumber) {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    showWriteStatus('Cannot queue lock: no company/user.', 'error');
                    return;
                }
                const cardId = await generateCardId(serialNumber || 'Unknown');
                await db.ref(`companies/${currentUser.companyId}/lockRequests/${cardId}`).set({
                    status: 'pending',
                    requestedAt: new Date().toISOString(),
                    requestedBy: currentUser.uid,
                    requestedByName: currentUser.displayName || currentUser.email || 'Unknown User',
                    serialNumber: serialNumber || 'Unknown',
                    cardId: cardId
                });
                showWriteStatus(`Permanent lock requested for Card ${cardId}. Open your mobile app to finalize.`, 'success');
            } catch (e) {
                console.error('queuePermanentLock error', e);
                showWriteStatus('Failed to queue permanent lock request.', 'error');
            }
        }

        // (Removed) Soft lock helpers were here

        // Real-time listener for NFC records (company-scoped)
        let nfcRecordsRef = null;
        function setupRecordRealtimeListener() {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) return;

                // Detach previous
                if (nfcRecordsRef) nfcRecordsRef.off();
                nfcRecordsRef = db.ref(`companies/${currentUser.companyId}/nfcRecords`);

                nfcRecordsRef.on('value', (snapshot) => {
                    const list = [];
                    snapshot.forEach(child => {
                        list.push({ id: child.key, ...child.val() });
                    });
                    list.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    writeHistory = list;
                    renderWriteHistory();
                });
            } catch (e) {
                console.error('setupRecordRealtimeListener error', e);
            }
        }


        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCUTmTn0rRBb0M-UkQJxnUMrWqXYU_BgIc",
            authDomain: "users-8be65.firebaseapp.com",
            databaseURL: "https://users-8be65-default-rtdb.firebaseio.com",
            projectId: "users-8be65",
            storageBucket: "users-8be65.firebasestorage.app",
            messagingSenderId: "829083030831",
            appId: "1:829083030831:web:36a370e62691e560bc3dda"
        };

        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();

        // Companies list
        let companiesList = [];
        // Employees map by organization
        let employeesMap = {};
        // Current selected employee data
        let selectedEmployeeData = null;

        // Check for NFC support on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkNFCSupport();
            loadScanHistory();
            loadWriteHistory();
            // Attempt to attach real-time listener; will no-op if auth not ready
            setupRecordRealtimeListener();
            setupWritePreview();
            
            // Show loading state immediately for organization dropdown
            const vcardOrgSelect = document.getElementById('vcardOrg');
            if (vcardOrgSelect) {
                vcardOrgSelect.innerHTML = '<option value="">-- Loading organizations... --</option>';
            }
            const vcardNameSelect = document.getElementById('vcardName');
            if (vcardNameSelect) {
                vcardNameSelect.innerHTML = '<option value="">-- Select Organization First --</option>';
            }
            
            // loadCompanies will be called after AuthManager initializes
            // If AuthManager isn't ready yet, retry attaching the realtime listener
            let attempts = 0;
            const retry = setInterval(() => {
                attempts++;
                if (window.authManager?.currentUser?.companyId) {
                    setupRecordRealtimeListener();
                    clearInterval(retry);
                }
                if (attempts > 20) clearInterval(retry);
            }, 300);
        });

        // Load company from user's company scope
        async function loadCompanies() {
            try {
                const vcardOrgSelect = document.getElementById('vcardOrg');
                vcardOrgSelect.innerHTML = '<option value="">-- Select Organization --</option>';
                
                // Get current user's company from AuthManager
                const currentUser = window.authManager ? window.authManager.currentUser : null;
                const currentCompany = window.authManager ? window.authManager.currentCompany : null;
                
                if (!currentUser || !currentUser.companyId) {
                    vcardOrgSelect.innerHTML = '<option value="">-- No company assigned --</option>';
                    return;
                }
                
                companiesList = [];
                
                // Add the user's main company first
                let mainCompanyName = '';
                if (currentCompany && currentCompany.companyName) {
                    mainCompanyName = currentCompany.companyName;
                    companiesList.push({
                        id: currentUser.companyId,
                        name: currentCompany.companyName,
                        industry: currentCompany.industry || '',
                        email: currentCompany.email || '',
                        type: 'main'
                    });
                    
                    const mainOption = document.createElement('option');
                    mainOption.value = currentCompany.companyName;
                    mainOption.textContent = currentCompany.companyName;
                    if (currentCompany.industry) {
                        mainOption.textContent += ` (${currentCompany.industry})`;
                    }
                    mainOption.selected = true; // Auto-select the user's company
                    vcardOrgSelect.appendChild(mainOption);
                    
                    console.log(`Loaded main company: ${currentCompany.companyName}`);
                } else {
                    // Fallback: fetch company data from Firebase
                    const companyRef = db.ref(`companies/${currentUser.companyId}`);
                    const snapshot = await companyRef.once('value');
                    
                    if (snapshot.exists()) {
                        const company = snapshot.val();
                        if (company.companyName) {
                            mainCompanyName = company.companyName;
                            companiesList.push({
                                id: currentUser.companyId,
                                name: company.companyName,
                                industry: company.industry || '',
                                email: company.email || '',
                                type: 'main'
                            });
                            
                            const mainOption = document.createElement('option');
                            mainOption.value = company.companyName;
                            mainOption.textContent = company.companyName;
                            if (company.industry) {
                                mainOption.textContent += ` (${company.industry})`;
                            }
                            mainOption.selected = true;
                            vcardOrgSelect.appendChild(mainOption);
                            
                            console.log(`Loaded main company: ${company.companyName}`);
                        }
                    }
                }
                
                // Load subcontractors from company scope
                try {
                    const subsRef = db.ref(`companies/${currentUser.companyId}/subcontractors`);
                    const subsSnapshot = await subsRef.once('value');
                    
                    if (subsSnapshot.exists()) {
                        const subcontractors = subsSnapshot.val();
                        const subsList = Object.entries(subcontractors);
                        
                        if (subsList.length > 0) {
                            // Sort subcontractors alphabetically
                            subsList.sort((a, b) => (a[1].name || '').localeCompare(b[1].name || ''));
                            
                            subsList.forEach(([subId, sub]) => {
                                if (sub.name) {
                                    companiesList.push({
                                        id: subId,
                                        name: sub.name,
                                        registrationNumber: sub.registrationNumber || '',
                                        contactName: sub.contactName || '',
                                        contactEmail: sub.contactEmail || '',
                                        type: 'subcontractor'
                                    });
                                    
                                    const subOption = document.createElement('option');
                                    subOption.value = sub.name;
                                    subOption.textContent = sub.name;
                                    if (sub.registrationNumber) {
                                        subOption.textContent += ` (Reg: ${sub.registrationNumber})`;
                                    }
                                    vcardOrgSelect.appendChild(subOption);
                                }
                            });
                            
                            console.log(`Loaded ${subsList.length} subcontractors`);
                        }
                    }
                } catch (subError) {
                    console.warn('Error loading subcontractors:', subError);
                }
                
                // If no companies were loaded at all
                if (companiesList.length === 0) {
                    vcardOrgSelect.innerHTML = '<option value="">-- No organizations found --</option>';
                }
                
                // Pre-load employees for main company
                await loadEmployeesForMainCompany();
                
                // If main company is auto-selected, trigger employee dropdown population
                if (vcardOrgSelect.value && employeesMap[vcardOrgSelect.value]) {
                    populateEmployeeDropdown(employeesMap[vcardOrgSelect.value]);
                }
                
            } catch (error) {
                console.error('Error loading company:', error);
                const vcardOrgSelect = document.getElementById('vcardOrg');
                vcardOrgSelect.innerHTML = '<option value="">-- Error loading company --</option>';
            }
        }

        // Fetch employees for a specific company (filtered by employerCompanyId like camp.html)
        async function fetchCompanyUsers(companyIdToLoad) {
            try {
                const ownerCompanyId = window.authManager.currentUser.companyId;
                // Always load from the owner company's users list (companymanagement scope)
                const usersRef = db.ref(`companies/${ownerCompanyId}/users`);
                const usersSnap = await usersRef.once('value');
                if (!usersSnap.exists()) return [];

                const userIds = Object.keys(usersSnap.val() || {});
                if (!userIds.length) return [];

                const details = await Promise.all(userIds.map(async (uid) => {
                    try {
                        // Get global user details
                        const uSnap = await db.ref(`users/${uid}`).once('value');
                        // Also read scoped user (to access employerCompany fields - this is the source of truth from companymanagement)
                        const scopedSnap = await db.ref(`companies/${ownerCompanyId}/users/${uid}`).once('value');
                        if (!uSnap.exists() && !scopedSnap.exists()) return null;
                        const u = uSnap.val() || {};
                        const scoped = scopedSnap.val() || {};
                        
                        // Determine the user's employer company id (scoped source of truth)
                        const employerCompanyId = scoped.employerCompanyId || u.employerCompanyId || ownerCompanyId;
                        // Filter: only include users whose employer company matches the selected company
                        if (employerCompanyId !== companyIdToLoad) return null;
                        
                        // Build display name - prefer scoped data (from companymanagement), then global
                        const firstName = scoped.firstName || u.firstName || '';
                        const lastName = scoped.lastName || u.lastName || '';
                        const fullName = scoped.fullName || scoped.name || u.fullName || u.name || '';
                        const displayName = u.displayName || fullName || (firstName ? `${firstName} ${lastName}`.trim() : '') || (u.email ? u.email.split('@')[0] : 'Unknown');
                        
                        // Get phone - prioritize scoped data (from companymanagement user management tab)
                        const phone = scoped.phone || scoped.phoneNumber || scoped.mobileNumber || u.phone || u.phoneNumber || u.mobileNumber || '';
                        
                        // Get email - prioritize scoped data
                        const email = scoped.email || u.email || '';
                        
                        // Get job title - prioritize scoped data (from companymanagement user management tab)
                        const jobTitle = scoped.jobTitle || u.jobTitle || scoped.position || u.position || scoped.title || u.title || '';
                        
                        return {
                            id: uid,
                            name: displayName,
                            email: email,
                            phone: phone,
                            jobTitle: jobTitle
                        };
                    } catch (e) {
                        console.warn('Failed loading user details for', uid, e);
                        return null;
                    }
                }));

                let filtered = details.filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));

                // Fallback: if nothing matched via employerCompanyId, try selected company's own scope
                if (!filtered.length && companyIdToLoad && companyIdToLoad !== ownerCompanyId) {
                    try {
                        const scopedUsersRef = db.ref(`companies/${companyIdToLoad}/users`);
                        const scopedUsersSnap = await scopedUsersRef.once('value');
                        const scopedIds = Object.keys(scopedUsersSnap.val() || {});
                        if (scopedIds.length) {
                            const scopedDetails = await Promise.all(scopedIds.map(async (uid) => {
                                try {
                                    const uSnap = await db.ref(`users/${uid}`).once('value');
                                    const scopedSnap = await db.ref(`companies/${companyIdToLoad}/users/${uid}`).once('value');
                                    if (!uSnap.exists() && !scopedSnap.exists()) return null;
                                    const u = uSnap.val() || {};
                                    const scoped = scopedSnap.val() || {};
                                    
                                    const firstName = scoped.firstName || u.firstName || '';
                                    const lastName = scoped.lastName || u.lastName || '';
                                    const fullName = scoped.fullName || scoped.name || u.fullName || u.name || '';
                                    const displayName = u.displayName || fullName || (firstName ? `${firstName} ${lastName}`.trim() : '') || (u.email ? u.email.split('@')[0] : 'Unknown');
                                    
                                    return {
                                        id: uid,
                                        name: displayName,
                                        email: scoped.email || u.email || '',
                                        phone: scoped.phone || scoped.phoneNumber || u.phone || u.phoneNumber || '',
                                        jobTitle: scoped.jobTitle || u.jobTitle || scoped.position || u.position || ''
                                    };
                                } catch (e2) { return null; }
                            }));
                            filtered = scopedDetails.filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));
                        }
                    } catch (e2) {
                        // ignore
                    }
                }

                return filtered;
            } catch (e) {
                console.error('Error fetching company users:', e);
                return [];
            }
        }

        // Load employees for the main company (pre-load)
        async function loadEmployeesForMainCompany() {
            try {
                const currentUser = window.authManager ? window.authManager.currentUser : null;
                if (!currentUser || !currentUser.companyId) return;
                
                const currentCompany = window.authManager ? window.authManager.currentCompany : null;
                const companyName = currentCompany ? currentCompany.companyName : '';
                
                if (!companyName) return;
                
                // Use fetchCompanyUsers to get employees filtered by employerCompanyId
                const employeesList = await fetchCompanyUsers(currentUser.companyId);
                employeesMap[companyName] = employeesList;
                
                console.log(`Loaded ${employeesList.length} employees for ${companyName}`);
            } catch (error) {
                console.error('Error loading employees for main company:', error);
            }
        }

        // Handle organization change
        async function onOrganizationChange() {
            const vcardOrgSelect = document.getElementById('vcardOrg');
            const vcardNameSelect = document.getElementById('vcardName');
            const selectedOrg = vcardOrgSelect.value;
            
            // Reset name dropdown
            vcardNameSelect.innerHTML = '<option value="">-- Loading employees... --</option>';
            
            // Reset other fields
            document.getElementById('vcardPhone').value = '';
            document.getElementById('vcardEmail').value = '';
            document.getElementById('vcardTitle').value = '';
            selectedEmployeeData = null;
            
            if (!selectedOrg) {
                vcardNameSelect.innerHTML = '<option value="">-- Select Organization First --</option>';
                updateWritePreview();
                return;
            }
            
            // Check if we already have employees for this organization
            if (employeesMap[selectedOrg]) {
                populateEmployeeDropdown(employeesMap[selectedOrg]);
                updateWritePreview();
                return;
            }
            
            // Find the organization in our list
            const org = companiesList.find(c => c.name === selectedOrg);
            
            if (!org) {
                vcardNameSelect.innerHTML = '<option value="">-- No employees found --</option>';
                updateWritePreview();
                return;
            }
            
            // Use fetchCompanyUsers to get employees filtered by employerCompanyId (like camp.html)
            try {
                const employees = await fetchCompanyUsers(org.id);
                employeesMap[selectedOrg] = employees;
                populateEmployeeDropdown(employees);
            } catch (error) {
                console.error('Error loading employees for organization:', error);
                vcardNameSelect.innerHTML = '<option value="">-- Error loading employees --</option>';
            }
            
            updateWritePreview();
        }

        // Helper function to format job title without hyphens and with title case
        function formatJobTitle(title) {
            if (!title) return '';
            // Replace hyphens with spaces, trim, and capitalize first letter of each word
            return title
                .replace(/-/g, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        }

        // Populate employee dropdown
        function populateEmployeeDropdown(employees) {
            const vcardNameSelect = document.getElementById('vcardName');
            vcardNameSelect.innerHTML = '<option value="">-- Select Employee --</option>';
            
            if (!employees || employees.length === 0) {
                vcardNameSelect.innerHTML = '<option value="">-- No employees found --</option>';
                return;
            }
            
            employees.forEach(emp => {
                const option = document.createElement('option');
                option.value = emp.name;
                option.textContent = emp.name;
                if (emp.jobTitle) {
                    option.textContent += ` (${formatJobTitle(emp.jobTitle)})`;
                }
                option.dataset.employeeId = emp.id;
                vcardNameSelect.appendChild(option);
            });
        }

        // Handle employee selection
        function onEmployeeChange() {
            const vcardOrgSelect = document.getElementById('vcardOrg');
            const vcardNameSelect = document.getElementById('vcardName');
            const selectedOrg = vcardOrgSelect.value;
            const selectedName = vcardNameSelect.value;
            
            // Get field elements
            const phoneField = document.getElementById('vcardPhone');
            const emailField = document.getElementById('vcardEmail');
            const titleField = document.getElementById('vcardTitle');
            
            if (!selectedOrg || !selectedName) {
                selectedEmployeeData = null;
                // Clear fields when no selection
                phoneField.value = '';
                emailField.value = '';
                titleField.value = '';
                updateWritePreview();
                return;
            }
            
            // Find the employee in our map
            const employees = employeesMap[selectedOrg] || [];
            const employee = employees.find(emp => emp.name === selectedName);
            
            if (employee) {
                selectedEmployeeData = employee;
                
                // Auto-fill phone, email, and job title from user management data
                phoneField.value = employee.phone || '';
                emailField.value = employee.email || '';
                titleField.value = formatJobTitle(employee.jobTitle) || '';
                
                console.log('ðŸ“‹ Auto-filled employee data:', {
                    name: employee.name,
                    phone: employee.phone,
                    email: employee.email,
                    jobTitle: employee.jobTitle
                });
            } else {
                selectedEmployeeData = null;
                // Clear fields if employee not found
                phoneField.value = '';
                emailField.value = '';
                titleField.value = '';
            }
            
            updateWritePreview();
        }

        // =============================================
        // WebToApp / WebView NFC Bridge Support
        // =============================================
        let isWebViewApp = false;
        let nativeNFCAvailable = false;
        
        // Detect if running in WebView/WebToApp environment
        function detectWebViewEnvironment() {
            const userAgent = navigator.userAgent || '';
            isWebViewApp = (
                userAgent.includes('wv') ||
                userAgent.includes('WebView') ||
                userAgent.includes('Android') && !userAgent.includes('Chrome/') ||
                window.AndroidNFC !== undefined ||
                window.Android !== undefined ||
                window.NativeNFC !== undefined ||
                window.webkit?.messageHandlers?.nfc !== undefined ||
                window.gonative !== undefined ||
                window.webtoapp !== undefined
            );
            
            console.log('WebView environment detected:', isWebViewApp);
            console.log('User Agent:', userAgent);
            
            // Check for native NFC bridges from various WebToApp platforms
            nativeNFCAvailable = (
                typeof window.AndroidNFC !== 'undefined' ||
                typeof window.Android?.scanNFC !== 'undefined' ||
                typeof window.NativeNFC !== 'undefined' ||
                typeof window.webkit?.messageHandlers?.nfc !== 'undefined' ||
                typeof window.gonative?.nfc !== 'undefined' ||
                typeof window.webtoapp?.nfc !== 'undefined'
            );
            
            console.log('Native NFC bridge available:', nativeNFCAvailable);
            
            return isWebViewApp;
        }
        
        // Global handler for receiving NFC data from native Android app
        // WebToApp platforms will call this function when an NFC tag is scanned
        window.handleNativeNFC = function(serialNumber, data) {
            console.log('ðŸ“± NFC data received from native Android:', { serialNumber, data });
            
            // Vibrate for feedback
            if ('vibrate' in navigator) {
                navigator.vibrate([100, 50, 100]);
            }
            
            updateStatus('âœ… Card read successfully!', 'active');
            
            // Parse the data if it's a string
            let parsedData = data;
            if (typeof data === 'string' && data) {
                try {
                    parsedData = JSON.parse(data);
                } catch (e) {
                    parsedData = { text: data };
                }
            }
            
            // Build records array in format compatible with summarizeCardData
            let records = [];
            if (parsedData?.records && Array.isArray(parsedData.records)) {
                records = parsedData.records;
            } else if (parsedData?.text) {
                // Check if it looks like a vCard
                if (parsedData.text.includes('BEGIN:VCARD')) {
                    records = [{
                        type: 'text',
                        mediaType: 'text/vcard',
                        displayData: parsedData.text,
                        data: parsedData.text
                    }];
                } else if (parsedData.text.startsWith('http://') || parsedData.text.startsWith('https://')) {
                    records = [{
                        type: 'url',
                        isUrl: true,
                        displayData: parsedData.text,
                        data: parsedData.text
                    }];
                } else {
                    records = [{
                        type: 'text',
                        displayData: parsedData.text,
                        data: parsedData.text
                    }];
                }
            } else if (typeof data === 'string' && data) {
                // Raw string data
                if (data.includes('BEGIN:VCARD')) {
                    records = [{
                        type: 'text',
                        mediaType: 'text/vcard',
                        displayData: data,
                        data: data
                    }];
                } else {
                    records = [{
                        type: 'text',
                        displayData: data,
                        data: data
                    }];
                }
            } else {
                records = [{ type: 'text', displayData: 'Card detected', data: 'No data' }];
            }
            
            // Build card data object
            const cardData = {
                serialNumber: serialNumber || 'Unknown',
                timestamp: new Date().toISOString(),
                records: records,
                rawRecords: parsedData?.rawRecords || [],
                recordCount: records.length,
                source: 'native_android'
            };
            
            // Display the data
            displayCardData(cardData);
            
            // Add to local history
            addToHistory(cardData);
            
            // Save to Firebase - with retry if AuthManager not ready yet
            saveNativeNFCRecord(cardData);
            
            return true;
        };
        
        // Save native NFC record with retry logic for AuthManager
        async function saveNativeNFCRecord(cardData, retryCount = 0) {
            const maxRetries = 10;
            const retryDelay = 500; // ms
            
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) {
                    if (retryCount < maxRetries) {
                        console.log(`AuthManager not ready, retrying (${retryCount + 1}/${maxRetries})...`);
                        setTimeout(() => saveNativeNFCRecord(cardData, retryCount + 1), retryDelay);
                        return;
                    }
                    console.warn('No user/companyId after retries; skipping scan record save');
                    return;
                }
                
                // Use addScanRecordFirebase to save
                await addScanRecordFirebase(cardData);
                console.log('âœ… NFC record saved to Firebase');
                
            } catch (err) {
                console.error('Failed to save native NFC record:', err);
                if (retryCount < maxRetries) {
                    setTimeout(() => saveNativeNFCRecord(cardData, retryCount + 1), retryDelay);
                }
            }
        }
        
        // Alternative handler names that WebToApp platforms might use
        window.onNFCTagDiscovered = window.handleNativeNFC;
        window.onNFCRead = window.handleNativeNFC;
        window.nfcCallback = window.handleNativeNFC;
        window.receiveNFCData = window.handleNativeNFC;
        
        // Handler for NFC write completion from native app
        window.onNativeNFCWriteComplete = function(success, message) {
            console.log('ðŸ“± NFC write result from native:', { success, message });
            if (success) {
                showWriteStatus('âœ… ' + (message || 'Data written to NFC card successfully!'), 'success');
            } else {
                showWriteStatus('âŒ ' + (message || 'Failed to write to NFC card'), 'error');
            }
            isWriting = false;
            updateWriteUI(false);
        };
        
        // Request native app to start NFC scanning
        function requestNativeNFCScan() {
            console.log('Requesting native NFC scan...');
            
            // Try various WebToApp platform bridges
            if (typeof window.AndroidNFC?.startScan === 'function') {
                window.AndroidNFC.startScan();
                return true;
            }
            if (typeof window.Android?.scanNFC === 'function') {
                window.Android.scanNFC();
                return true;
            }
            if (typeof window.Android?.startNFCScan === 'function') {
                window.Android.startNFCScan();
                return true;
            }
            if (typeof window.NativeNFC?.scan === 'function') {
                window.NativeNFC.scan();
                return true;
            }
            if (typeof window.gonative?.nfc?.scan === 'function') {
                window.gonative.nfc.scan();
                return true;
            }
            if (typeof window.webtoapp?.nfc?.scan === 'function') {
                window.webtoapp.nfc.scan();
                return true;
            }
            if (window.webkit?.messageHandlers?.nfc) {
                window.webkit.messageHandlers.nfc.postMessage({ action: 'scan' });
                return true;
            }
            
            // Generic Android JavaScript interface call
            if (typeof window.Android?.postMessage === 'function') {
                window.Android.postMessage(JSON.stringify({ action: 'startNFCScan' }));
                return true;
            }
            
            return false;
        }
        
        // Request native app to write NFC data
        function requestNativeNFCWrite(data) {
            console.log('Requesting native NFC write...', data);
            
            const payload = JSON.stringify(data);
            
            if (typeof window.AndroidNFC?.write === 'function') {
                window.AndroidNFC.write(payload);
                return true;
            }
            if (typeof window.Android?.writeNFC === 'function') {
                window.Android.writeNFC(payload);
                return true;
            }
            if (typeof window.NativeNFC?.write === 'function') {
                window.NativeNFC.write(payload);
                return true;
            }
            if (typeof window.gonative?.nfc?.write === 'function') {
                window.gonative.nfc.write(payload);
                return true;
            }
            if (typeof window.webtoapp?.nfc?.write === 'function') {
                window.webtoapp.nfc.write(payload);
                return true;
            }
            if (window.webkit?.messageHandlers?.nfc) {
                window.webkit.messageHandlers.nfc.postMessage({ action: 'write', data: data });
                return true;
            }
            
            return false;
        }
        
        // Check if Web NFC is supported (updated for WebView support)
        function checkNFCSupport() {
            // First detect WebView environment
            detectWebViewEnvironment();
            
            // If we have a native NFC bridge, use that
            if (nativeNFCAvailable) {
                console.log('âœ… Native NFC bridge detected - using native Android NFC');
                updateStatus('ðŸ“± Native NFC ready. Tap "Start Scanning" to begin.', '');
                return true;
            }
            
            // If in WebView but no native bridge, show helpful message
            if (isWebViewApp && !('NDEFReader' in window)) {
                console.log('âš ï¸ WebView detected without NFC bridge');
                updateStatus('ðŸ“± NFC ready via native app. Tap "Start Scanning" to begin.', '');
                // Don't disable buttons - let native app handle NFC
                return true;
            }
            
            // Standard Web NFC check
            if (!('NDEFReader' in window)) {
                // In WebView, don't disable - native app might handle NFC
                if (isWebViewApp) {
                    console.log('WebView mode - assuming native NFC available');
                    updateStatus('ðŸ“± Tap "Start Scanning" to use device NFC.', '');
                    return true;
                }
                
                document.getElementById('startScanBtn').disabled = true;
                document.getElementById('writeNfcBtn').disabled = true;
                document.getElementById('scanStatus').textContent = 'Web NFC not supported. Use Chrome on Android.';
                document.getElementById('scanStatus').classList.add('error');
                return false;
            }
            
            return true;
        }
        
        // Request NFC permission (simplified for WebView)
        async function requestNFCPermission() {
            // In WebView, skip permission check - native app handles it
            if (isWebViewApp) {
                console.log('WebView mode - skipping web permission check');
                return true;
            }
            
            try {
                if ('permissions' in navigator) {
                    const result = await navigator.permissions.query({ name: 'nfc' });
                    console.log('NFC permission status:', result.state);
                    
                    if (result.state === 'denied') {
                        // Don't block in WebView - try anyway
                        console.warn('NFC permission denied, but will try native bridge');
                        return true;
                    }
                }
                return true;
            } catch (error) {
                console.log('Permissions API not available:', error);
                return true;
            }
        }
        
        // Show help for enabling NFC permissions
        function showNFCPermissionHelp() {
            const helpMessage = `
To enable NFC access:

ðŸ“± For WebToApp/WebView apps:
1. Make sure NFC is enabled on your device
   Settings â†’ Connected devices â†’ NFC â†’ ON
2. The app needs NFC permission in Android settings
   Settings â†’ Apps â†’ [Your App] â†’ Permissions â†’ Allow NFC

ðŸ“± On Android Chrome:
1. Tap the lock icon (ðŸ”’) in the address bar
2. Tap "Site settings" â†’ Find "NFC" â†’ "Allow"

ðŸ” Requirements:
â€¢ NFC must be enabled on your device
â€¢ Hold the card to the back of your phone
            `.trim();
            
            alert(helpMessage);
        }

        // Helper to select active NFC tool button
        function selectNFCToolBtn(tool) {
            const toggle = document.getElementById('nfcToolsToggle');
            if (toggle) {
                toggle.querySelectorAll('.main-tab-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });
            }
        }
        
        // Switch between read and write modes
        function switchMode(mode) {
            currentMode = mode;
            
            // Update all tool buttons - highlight the selected one
            selectNFCToolBtn(mode);
            
            // Show/hide sections
            document.getElementById('readModeSection').style.display = mode === 'read' ? 'block' : 'none';
            document.getElementById('writeModeSection').style.display = mode === 'write' ? 'block' : 'none';
            
            // Stop any ongoing operations when switching modes
            if (mode === 'write' && isScanning) {
                stopNFCScan();
            } else if (mode === 'read' && isWriting) {
                cancelNFCWrite();
            }
        }

        // Select write data type
        function selectWriteType(type) {
            selectedWriteType = type;
            
            // Update buttons
            document.querySelectorAll('.record-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            
            // Show/hide input groups
            document.getElementById('textInputGroup').style.display = type === 'text' ? 'block' : 'none';
            document.getElementById('urlInputGroup').style.display = type === 'url' ? 'block' : 'none';
            document.getElementById('jsonInputGroup').style.display = type === 'json' ? 'block' : 'none';
            document.getElementById('vcardInputGroup').style.display = type === 'vcard' ? 'block' : 'none';
            
            // Update preview
            updateWritePreview();
        }

        // Setup write preview listeners
        function setupWritePreview() {
            // Text input
            document.getElementById('writeText').addEventListener('input', updateWritePreview);
            // URL input
            document.getElementById('writeUrl').addEventListener('input', updateWritePreview);
            // JSON input
            document.getElementById('writeJson').addEventListener('input', updateWritePreview);
            // vCard inputs - vcardName and vcardOrg are now dropdowns
            ['vcardPhone', 'vcardEmail', 'vcardTitle'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateWritePreview);
            });
            // Dropdown fields use change event
            document.getElementById('vcardOrg').addEventListener('change', updateWritePreview);
            document.getElementById('vcardName').addEventListener('change', updateWritePreview);
        }

        // Update write preview
        function updateWritePreview() {
            const preview = document.getElementById('writePreview');
            let previewData = {};
            
            switch (selectedWriteType) {
                case 'text':
                    const text = document.getElementById('writeText').value;
                    previewData = {
                        type: 'text',
                        content: text || '(empty)',
                        byteLength: new TextEncoder().encode(text).length
                    };
                    break;
                    
                case 'url':
                    const url = document.getElementById('writeUrl').value;
                    previewData = {
                        type: 'url',
                        url: url || '(empty)',
                        valid: isValidUrl(url)
                    };
                    break;
                    
                case 'json':
                    const jsonStr = document.getElementById('writeJson').value;
                    try {
                        const parsed = JSON.parse(jsonStr || '{}');
                        previewData = {
                            type: 'application/json',
                            data: parsed,
                            valid: true
                        };
                    } catch (e) {
                        previewData = {
                            type: 'application/json',
                            error: 'Invalid JSON: ' + e.message,
                            valid: false
                        };
                    }
                    break;
                    
                case 'vcard':
                    previewData = {
                        type: 'text/vcard',
                        vcard: generateVCard()
                    };
                    break;
            }
            
            preview.textContent = JSON.stringify(previewData, null, 2);
        }

        // Validate URL
        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        // Generate vCard string
        function generateVCard() {
            const name = document.getElementById('vcardName').value;
            const phone = document.getElementById('vcardPhone').value;
            const email = document.getElementById('vcardEmail').value;
            const org = document.getElementById('vcardOrg').value;
            const title = document.getElementById('vcardTitle').value;
            
            let vcard = 'BEGIN:VCARD\n';
            vcard += 'VERSION:3.0\n';
            if (name) vcard += `FN:${name}\n`;
            if (name) {
                const parts = name.split(' ');
                const lastName = parts.pop() || '';
                const firstName = parts.join(' ') || '';
                vcard += `N:${lastName};${firstName};;;\n`;
            }
            if (phone) vcard += `TEL:${phone}\n`;
            if (email) vcard += `EMAIL:${email}\n`;
            if (org) vcard += `ORG:${org}\n`;
            if (title) vcard += `TITLE:${title}\n`;
            vcard += 'END:VCARD';
            
            return vcard;
        }

        // Start NFC scanning
        async function startNFCScan() {
            if (!checkNFCSupport()) return;

            try {
                // Request permission first
                const hasPermission = await requestNFCPermission();
                if (!hasPermission) return;
                
                updateStatus('ðŸ“± Initializing NFC reader...', 'active');
                
                // Try native Android bridge first (for WebToApp / WebView apps)
                if (isWebViewApp || nativeNFCAvailable) {
                    console.log('Attempting native NFC scan...');
                    const nativeStarted = requestNativeNFCScan();
                    if (nativeStarted) {
                        isScanning = true;
                        updateScanUI(true);
                        updateStatus('ðŸ“± Scanning... Hold your NFC card near the device', 'active');
                        console.log('Native NFC scan started');
                        return;
                    }
                    console.log('Native bridge not available, trying Web NFC...');
                }
                
                // Fallback to Web NFC API
                if ('NDEFReader' in window) {
                    nfcReader = new NDEFReader();
                    abortController = new AbortController();

                    // The scan() call will trigger the permission prompt if needed
                    await nfcReader.scan({ signal: abortController.signal });

                    isScanning = true;
                    updateScanUI(true);
                    updateStatus('âœ… Scanning... Hold your NFC card near the device', 'active');

                    // Handle reading events
                    nfcReader.addEventListener('reading', handleNFCReading);
                    nfcReader.addEventListener('readingerror', handleNFCError);
                } else if (isWebViewApp) {
                    // WebView without NDEFReader - assume native app handles NFC
                    isScanning = true;
                    updateScanUI(true);
                    updateStatus('ðŸ“± Waiting for NFC card... Hold card near device', 'active');
                    console.log('WebView mode - waiting for native NFC callback');
                } else {
                    throw new Error('NFC not available');
                }

            } catch (error) {
                console.error('Error starting NFC scan:', error);
                
                // In WebView, try to continue anyway - native app might handle it
                if (isWebViewApp) {
                    console.log('WebView: ignoring error, waiting for native NFC');
                    isScanning = true;
                    updateScanUI(true);
                    updateStatus('ðŸ“± Ready for NFC. Hold card near device.', 'active');
                    return;
                }
                
                // Provide specific guidance for permission errors
                if (error.name === 'NotAllowedError') {
                    updateStatus('âŒ NFC permission denied. Tap "Help" for instructions.', 'error');
                    
                    // Add a help button temporarily
                    const statusEl = document.getElementById('scanStatus');
                    if (statusEl && !document.getElementById('nfcHelpBtn')) {
                        const helpBtn = document.createElement('button');
                        helpBtn.id = 'nfcHelpBtn';
                        helpBtn.className = 'btn btn-primary';
                        helpBtn.style.cssText = 'margin-left: 10px; padding: 0.5rem 1rem; font-size: 0.85rem;';
                        helpBtn.innerHTML = '<i class="fas fa-question-circle"></i> Help';
                        helpBtn.onclick = showNFCPermissionHelp;
                        statusEl.parentNode.insertBefore(helpBtn, statusEl.nextSibling);
                    }
                } else {
                    handleNFCError(error);
                }
            }
        }

        // Stop NFC scanning
        function stopNFCScan() {
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            isScanning = false;
            updateScanUI(false);
            updateStatus('Scanning stopped', '');
        }

        // Handle NFC reading event
        async function handleNFCReading(event) {
            const { message, serialNumber } = event;
            
            console.log('NFC Tag Read:', { serialNumber, message });

            // Vibrate device for feedback (if supported)
            if ('vibrate' in navigator) {
                navigator.vibrate(200);
            }

            updateStatus('Processing card data...', 'active');

            // Parse and display the data (with decryption)
            const cardData = await parseNFCMessage(message, serialNumber);
            displayCardData(cardData);

            // Add to history
            addToHistory(cardData);

            // Persist scan to Firebase and show in Record tab
            addScanRecordFirebase(cardData);

            updateStatus('Card read successfully!', 'active');

            // Reset status after 3 seconds
            setTimeout(() => {
                if (isScanning) {
                    updateStatus('Scanning... Hold another card to read', 'active');
                }
            }, 3000);
        }

        // Handle NFC reading error
        function handleNFCError(error) {
            console.error('NFC Error:', error);
            
            let errorMessage = 'Error reading NFC card';
            
            // In WebView mode, be more forgiving - native app might handle NFC
            if (isWebViewApp) {
                console.log('WebView mode - suppressing NFC error, waiting for native callback');
                if (error.name !== 'AbortError') {
                    updateStatus('ðŸ“± Ready for NFC. Hold card near device.', 'active');
                }
                return;
            }
            
            if (error.name === 'NotAllowedError') {
                errorMessage = 'âŒ NFC permission denied. Please allow NFC access in your browser settings.';
                // Show help button
                setTimeout(() => {
                    const statusEl = document.getElementById('scanStatus');
                    if (statusEl && !document.getElementById('nfcHelpBtn')) {
                        const helpBtn = document.createElement('button');
                        helpBtn.id = 'nfcHelpBtn';
                        helpBtn.className = 'btn btn-primary';
                        helpBtn.style.cssText = 'margin-left: 10px; padding: 0.5rem 1rem; font-size: 0.85rem;';
                        helpBtn.innerHTML = '<i class="fas fa-question-circle"></i> How to Enable';
                        helpBtn.onclick = showNFCPermissionHelp;
                        statusEl.parentNode.insertBefore(helpBtn, statusEl.nextSibling);
                    }
                }, 100);
            } else if (error.name === 'NotSupportedError') {
                errorMessage = 'âŒ NFC is not supported on this device or browser.';
            } else if (error.name === 'AbortError') {
                errorMessage = 'Scanning cancelled.';
            } else if (error.name === 'SecurityError') {
                errorMessage = 'ðŸ”’ Security error: NFC requires HTTPS connection.';
            } else if (error.message) {
                errorMessage = error.message;
            }

            updateStatus(errorMessage, 'error');
            updateScanUI(false);
        }

        // Parse NFC message
        async function parseNFCMessage(message, serialNumber) {
            const records = [];
            const rawRecords = [];

            for (const record of message.records) {
                const parsedRecord = await parseNDEFRecord(record);
                records.push(parsedRecord);
                rawRecords.push({
                    recordType: record.recordType,
                    mediaType: record.mediaType,
                    id: record.id,
                    encoding: record.encoding,
                    lang: record.lang,
                    dataLength: record.data ? record.data.byteLength : 0
                });
            }

            return {
                serialNumber: serialNumber || 'Unknown',
                timestamp: new Date().toISOString(),
                records: records,
                rawRecords: rawRecords,
                recordCount: message.records.length
            };
        }

        // Parse individual NDEF record (with decryption support)
        async function parseNDEFRecord(record) {
            const result = {
                type: record.recordType,
                mediaType: record.mediaType || null,
                id: record.id || null,
                data: null,
                displayData: null,
                encrypted: false,
                decrypted: false
            };

            try {
                switch (record.recordType) {
                    case 'text':
                        const textDecoder = new TextDecoder(record.encoding || 'utf-8');
                        result.data = textDecoder.decode(record.data);
                        result.displayData = result.data;
                        result.language = record.lang;
                        break;

                    case 'url':
                        const urlDecoder = new TextDecoder();
                        result.data = urlDecoder.decode(record.data);
                        result.displayData = result.data;
                        result.isUrl = true;
                        break;

                    case 'mime':
                        const mimeDecoder = new TextDecoder();
                        const rawData = mimeDecoder.decode(record.data);
                        
                        // Check for DreamEx proprietary format (DXD: = data, DXP: = password)
                        if (rawData.startsWith('DXD:')) {
                            result.encrypted = true;
                            const typeCode = rawData.charAt(4); // T, U, J, V, or X
                            const encryptedPayload = rawData.substring(5);
                            
                            // Try to decrypt
                            const decryptResult = await decryptData(encryptedPayload);
                            if (decryptResult.decrypted) {
                                result.decrypted = true;
                                result.data = decryptResult.data;
                                
                                // Parse based on type code
                                const typeMap = { T: 'text', U: 'url', J: 'json', V: 'vcard' };
                                const originalType = typeMap[typeCode] || 'unknown';
                                
                                if (originalType === 'json') {
                                    try {
                                        const parsed = JSON.parse(decryptResult.data);
                                        result.displayData = JSON.stringify(parsed, null, 2);
                                    } catch {
                                        result.displayData = decryptResult.data;
                                    }
                                } else if (originalType === 'vcard') {
                                    result.displayData = decryptResult.data;
                                    result.mediaType = 'text/vcard';
                                } else if (originalType === 'url') {
                                    result.displayData = decryptResult.data;
                                    result.isUrl = true;
                                } else {
                                    result.displayData = decryptResult.data;
                                }
                                result.decryptionNote = 'ðŸ”“ Decrypted successfully (Proprietary Format)';
                            } else {
                                // Could not decrypt - this is NOT from your company
                                result.data = '[PROTECTED]';
                                result.displayData = 'ðŸ” PROPRIETARY ENCRYPTED DATA\n\nThis card uses DreamEx proprietary encryption.\nOnly the originating company can read this data.\n\nYou do not have access to view this card\'s contents.';
                                result.decryptionNote = 'Access denied - different company encryption key';
                            }
                        } else if (rawData.startsWith('DXP:')) {
                            // Proprietary password hash format
                            result.data = '(password protection)';
                            result.displayData = 'ðŸ”’ Password Protected Card';
                            result.isPasswordRecord = true;
                            result.passwordHash = rawData.substring(4);
                        }
                        // Handle legacy encrypted data types (for backwards compatibility)
                        else if (record.mediaType && record.mediaType.startsWith('application/x-encrypted-')) {
                            result.encrypted = true;
                            const originalType = record.mediaType.replace('application/x-encrypted-', '');
                            
                            // Try to decrypt
                            const decryptResult = await decryptData(rawData);
                            if (decryptResult.decrypted) {
                                result.decrypted = true;
                                result.data = decryptResult.data;
                                
                                // Parse based on original type
                                if (originalType === 'json') {
                                    try {
                                        const parsed = JSON.parse(decryptResult.data);
                                        result.displayData = JSON.stringify(parsed, null, 2);
                                    } catch {
                                        result.displayData = decryptResult.data;
                                    }
                                } else if (originalType === 'vcard') {
                                    result.displayData = decryptResult.data;
                                    result.mediaType = 'text/vcard';
                                } else {
                                    result.displayData = decryptResult.data;
                                }
                                result.decryptionNote = 'ðŸ”“ Decrypted successfully';
                            } else {
                                // Could not decrypt - show encrypted data
                                result.data = rawData;
                                result.displayData = 'ðŸ” ENCRYPTED DATA\n\nThis card contains encrypted data from another company.\nYou cannot view this data without the correct encryption key.\n\nRaw data: ' + rawData.substring(0, 50) + '...';
                                result.decryptionNote = decryptResult.error || 'Unable to decrypt';
                            }
                        } else if (record.mediaType === 'application/x-nfc-password') {
                            // Legacy password hash - don't display
                            result.data = '(password protection hash)';
                            result.displayData = 'ðŸ”’ Password Protected Card';
                            result.isPasswordRecord = true;
                        } else if (record.mediaType === 'application/json') {
                            const jsonString = rawData;
                            
                            // Check if JSON content is encrypted
                            if (isEncryptedData(jsonString)) {
                                result.encrypted = true;
                                const decryptResult = await decryptData(jsonString);
                                if (decryptResult.decrypted) {
                                    result.decrypted = true;
                                    result.data = JSON.parse(decryptResult.data);
                                    result.displayData = JSON.stringify(result.data, null, 2);
                                    result.decryptionNote = 'ðŸ”“ Decrypted successfully';
                                } else {
                                    result.displayData = 'ðŸ” ENCRYPTED JSON\n' + jsonString.substring(0, 100) + '...';
                                }
                            } else {
                                result.data = JSON.parse(jsonString);
                                result.displayData = JSON.stringify(result.data, null, 2);
                            }
                        } else if (record.mediaType && record.mediaType.startsWith('text/')) {
                            // Check if text content is encrypted
                            if (isEncryptedData(rawData)) {
                                result.encrypted = true;
                                const decryptResult = await decryptData(rawData);
                                if (decryptResult.decrypted) {
                                    result.decrypted = true;
                                    result.data = decryptResult.data;
                                    result.displayData = decryptResult.data;
                                    result.decryptionNote = 'ðŸ”“ Decrypted successfully';
                                } else {
                                    result.displayData = 'ðŸ” ENCRYPTED DATA\n' + rawData.substring(0, 100) + '...';
                                }
                            } else {
                                result.data = rawData;
                                result.displayData = rawData;
                            }
                        } else if (record.mediaType === 'application/octet-stream') {
                            // Generic binary - check if it's our proprietary format
                            if (rawData.startsWith('DXD:') || rawData.startsWith('DXP:')) {
                                // Already handled above, but double check
                                result.displayData = 'ðŸ” Proprietary encrypted data';
                            } else {
                                result.data = arrayBufferToHex(record.data);
                                result.displayData = 'Binary data: ' + result.data.substring(0, 50) + '...';
                            }
                        } else {
                            result.data = arrayBufferToHex(record.data);
                            result.displayData = result.data;
                        }
                        break;

                    case 'smart-poster':
                        result.displayData = 'Smart Poster Record';
                        result.data = 'Smart Poster (contains nested records)';
                        break;

                    case 'absolute-url':
                        const absUrlDecoder = new TextDecoder();
                        result.data = absUrlDecoder.decode(record.data);
                        result.displayData = result.data;
                        result.isUrl = true;
                        break;

                    case 'empty':
                        result.data = '(empty record)';
                        result.displayData = '(empty record)';
                        break;

                    case 'unknown':
                    default:
                        // Try to decode as text first
                        try {
                            const unknownDecoder = new TextDecoder();
                            const unknownData = unknownDecoder.decode(record.data);
                            
                            // Check if encrypted
                            if (isEncryptedData(unknownData)) {
                                result.encrypted = true;
                                const decryptResult = await decryptData(unknownData);
                                if (decryptResult.decrypted) {
                                    result.decrypted = true;
                                    result.data = decryptResult.data;
                                    result.displayData = decryptResult.data;
                                } else {
                                    result.displayData = 'ðŸ” ENCRYPTED\n' + unknownData.substring(0, 100) + '...';
                                }
                            } else {
                                result.data = unknownData;
                                result.displayData = unknownData;
                            }
                        } catch {
                            result.data = arrayBufferToHex(record.data);
                            result.displayData = result.data;
                        }
                        break;
                }
            } catch (error) {
                console.error('Error parsing record:', error);
                result.data = record.data ? arrayBufferToHex(record.data) : '(error parsing)';
                result.displayData = result.data;
            }

            return result;
        }

        // Fetch avatar URL for any employee by their uid
        async function getEmployeeAvatarUrl(employeeUid, companyId) {
            if (!employeeUid) return null;
            const cid = companyId || window.authManager?.currentUser?.companyId || 'default';
            const possiblePaths = [
                `companies/${cid}/avatars/${employeeUid}/profile.jpg`,
                `companies/${cid}/avatars/${employeeUid}/profile.png`,
                `companies/${cid}/avatars/${employeeUid}/profile.jpeg`,
                `companies/${cid}/avatars/${employeeUid}/avatar.jpg`,
                `companies/${cid}/avatars/${employeeUid}/avatar.png`,
                `avatars/${employeeUid}/profile.jpg`,
                `avatars/${employeeUid}/profile.png`,
                `avatars/${employeeUid}/avatar.jpg`,
                `avatars/${employeeUid}/avatar.png`
            ];
            for (const path of possiblePaths) {
                try {
                    const ref = firebase.storage().ref(path);
                    const url = await ref.getDownloadURL();
                    return url;
                } catch (err) { continue; }
            }
            return null;
        }

        // Look up card assignment by serial number or card ID
        async function lookupCardAssignment(serialNumber, cardId) {
            try {
                const currentUser = window.authManager?.currentUser;
                if (!currentUser?.companyId) return null;
                
                const assignmentsRef = db.ref(`companies/${currentUser.companyId}/cardAssignments`);
                const snapshot = await assignmentsRef.once('value');
                if (!snapshot.exists()) return null;
                
                let foundAssignment = null;
                snapshot.forEach(child => {
                    const assignment = child.val();
                    // Match by card ID (key) or by serial number
                    if (child.key === cardId || assignment.serialNumber === serialNumber) {
                        foundAssignment = { ...assignment, cardId: child.key };
                    }
                });
                return foundAssignment;
            } catch (err) {
                console.warn('Error looking up card assignment:', err);
                return null;
            }
        }

        // Display assigned employee profile in the UI
        async function displayAssignedEmployee(serialNumber, cardId) {
            const section = document.getElementById('assignedEmployeeSection');
            const avatarContainer = document.getElementById('assignedEmployeeAvatar');
            const nameEl = document.getElementById('assignedEmployeeName');
            const orgEl = document.getElementById('assignedEmployeeOrg');
            
            // Initially hide the section
            section.style.display = 'none';
            
            // Look up the assignment
            const assignment = await lookupCardAssignment(serialNumber, cardId);
            if (!assignment) return;
            
            // Show the section
            section.style.display = 'block';
            
            // Set employee name and organization
            nameEl.textContent = assignment.employeeName || 'Unknown Employee';
            orgEl.textContent = assignment.organization || '-';
            
            // Fetch and display avatar
            const avatarUrl = await getEmployeeAvatarUrl(assignment.employeeId);
            if (avatarUrl) {
                avatarContainer.innerHTML = `<img src="${avatarUrl}" alt="${assignment.employeeName || 'Employee'} Avatar" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.parentElement.innerHTML='<div style=\'width:100%;height:100%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:1.5rem;\'>${getInitials(assignment.employeeName)}</div>'">`;
            } else {
                // Show initials as fallback
                const initials = getInitials(assignment.employeeName);
                avatarContainer.innerHTML = `<div style="width: 100%; height: 100%; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); display: flex; align-items: center; justify-content: center; color: #fff; font-weight: 600; font-size: 1.5rem;">${initials}</div>`;
            }
        }
        
        // Get initials from name
        function getInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ').filter(Boolean);
            if (parts.length === 0) return '?';
            if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
            return parts.slice(0, 2).map(p => p[0]).join('').toUpperCase();
        }

        // Convert ArrayBuffer to hex string
        function arrayBufferToHex(buffer) {
            if (!buffer) return '';
            const bytes = new Uint8Array(buffer);
            return Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');
        }

        // Display card data in UI
        function displayCardData(cardData) {
            document.getElementById('noDataMessage').style.display = 'none';
            document.getElementById('cardDataContainer').style.display = 'block';

            // Display serial number
            if (cardData.serialNumber && cardData.serialNumber !== 'Unknown') {
                document.getElementById('serialNumberSection').style.display = 'block';
                document.getElementById('serialNumber').textContent = formatSerialNumber(cardData.serialNumber);
                
                // Look up and display assigned employee (async, non-blocking)
                displayAssignedEmployee(cardData.serialNumber, null);
            } else {
                document.getElementById('serialNumberSection').style.display = 'none';
                document.getElementById('assignedEmployeeSection').style.display = 'none';
            }

            // Display parsed records
            const dataList = document.getElementById('nfcDataList');
            dataList.innerHTML = '';

            // Filter out password hash records (they're for verification, not display)
            const displayRecords = cardData.records.filter(r => !r.isPasswordRecord);
            
            // Check for encryption status
            const encryptedRecords = displayRecords.filter(r => r.encrypted);
            const decryptedRecords = encryptedRecords.filter(r => r.decrypted);
            const failedDecrypt = encryptedRecords.filter(r => !r.decrypted);
            const hasPassword = cardData.records.some(r => r.isPasswordRecord);

            // Show security summary if applicable
            if (encryptedRecords.length > 0 || hasPassword) {
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'alert';
                summaryDiv.style.cssText = 'margin-bottom: 1rem; padding: 0.75rem; border-radius: 8px; font-size: 0.9rem;';
                
                let summaryHtml = '<i class="fas fa-shield-alt"></i> <strong>Card Security:</strong><br>';
                
                if (hasPassword) {
                    summaryHtml += '<span style="margin-left: 1rem;">ðŸ”’ Password Protected</span><br>';
                }
                
                if (encryptedRecords.length > 0) {
                    if (decryptedRecords.length === encryptedRecords.length) {
                        summaryDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                        summaryDiv.style.border = '1px solid var(--success-color)';
                        summaryHtml += `<span style="margin-left: 1rem;">ðŸ”“ ${decryptedRecords.length} encrypted record(s) successfully decrypted</span>`;
                    } else if (decryptedRecords.length > 0) {
                        summaryDiv.style.background = 'rgba(245, 158, 11, 0.1)';
                        summaryDiv.style.border = '1px solid var(--warning-color)';
                        summaryHtml += `<span style="margin-left: 1rem;">ðŸ”“ ${decryptedRecords.length} decrypted, ðŸ” ${failedDecrypt.length} from other company</span>`;
                    } else {
                        summaryDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                        summaryDiv.style.border = '1px solid var(--danger-color)';
                        summaryHtml += `<span style="margin-left: 1rem;">ðŸ” ${failedDecrypt.length} encrypted record(s) from another company</span>`;
                    }
                } else if (hasPassword) {
                    summaryDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                    summaryDiv.style.border = '1px solid var(--success-color)';
                }
                
                summaryDiv.innerHTML = summaryHtml;
                dataList.appendChild(summaryDiv);
            }

            if (displayRecords.length === 0) {
                dataList.innerHTML += '<p style="color: var(--text-secondary); text-align: center;">No NDEF records found on this card</p>';
            } else {
                displayRecords.forEach((record, index) => {
                    const recordElement = createRecordElement(record, index);
                    dataList.appendChild(recordElement);
                });
            }

            // Display raw data
            document.getElementById('rawDataContent').textContent = JSON.stringify(cardData, null, 2);
        }

        // Create HTML element for a record
        function createRecordElement(record, index) {
            const div = document.createElement('div');
            div.className = 'data-item';

            const typeLabel = getRecordTypeLabel(record.type);
            const typeColor = getRecordTypeColor(record.type);

            let contentHtml = '';
            if (record.isUrl) {
                contentHtml = `<a href="${escapeHtml(record.displayData)}" target="_blank" rel="noopener noreferrer">${escapeHtml(record.displayData)}</a>`;
            } else {
                contentHtml = escapeHtml(record.displayData);
            }

            // Build encryption/decryption badge
            let encryptionBadge = '';
            if (record.isPasswordRecord) {
                encryptionBadge = '<span style="background: var(--warning-color); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; margin-left: 0.5rem;">ðŸ”’ Protected</span>';
            } else if (record.encrypted && record.decrypted) {
                encryptionBadge = '<span style="background: var(--success-color); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; margin-left: 0.5rem;">ðŸ”“ Decrypted</span>';
            } else if (record.encrypted && !record.decrypted) {
                encryptionBadge = '<span style="background: var(--danger-color); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; margin-left: 0.5rem;">ðŸ” Encrypted (Other Company)</span>';
            }

            div.innerHTML = `
                <div class="data-item-header">
                    <span class="data-item-label">Record ${index + 1}${encryptionBadge}</span>
                    <span class="data-item-type" style="background: ${typeColor}">${typeLabel}</span>
                </div>
                ${record.mediaType ? `<p style="font-size: 0.8rem; color: var(--text-secondary);">MIME: ${escapeHtml(record.mediaType)}</p>` : ''}
                ${record.language ? `<p style="font-size: 0.8rem; color: var(--text-secondary);">Language: ${escapeHtml(record.language)}</p>` : ''}
                ${record.decryptionNote ? `<p style="font-size: 0.8rem; color: var(--success-color);"><i class="fas fa-shield-alt"></i> ${escapeHtml(record.decryptionNote)}</p>` : ''}
                <div class="data-item-content">
                    ${contentHtml}
                    ${!record.isPasswordRecord ? `<button class="copy-btn" onclick="copyToClipboard('${escapeHtml(record.displayData).replace(/'/g, "\\'")}')">
                        <i class="fas fa-copy"></i>
                    </button>` : ''}
                </div>
            `;

            return div;
        }

        // Get human-readable record type label
        function getRecordTypeLabel(type) {
            const labels = {
                'text': 'Text',
                'url': 'URL',
                'mime': 'MIME Data',
                'smart-poster': 'Smart Poster',
                'absolute-url': 'Absolute URL',
                'empty': 'Empty',
                'unknown': 'Unknown'
            };
            return labels[type] || type.toUpperCase();
        }

        // Get color for record type
        function getRecordTypeColor(type) {
            const colors = {
                'text': '#3498db',
                'url': '#2ecc71',
                'mime': '#9b59b6',
                'smart-poster': '#e67e22',
                'absolute-url': '#2ecc71',
                'empty': '#95a5a6',
                'unknown': '#7f8c8d'
            };
            return colors[type] || '#7f8c8d';
        }

        // Format serial number for display
        function formatSerialNumber(serial) {
            // Format as groups of 2 characters separated by colons
            return serial.replace(/(.{2})(?=.)/g, '$1:').toUpperCase();
        }

        // Update scanning UI
        function updateScanUI(scanning) {
            const nfcIcon = document.getElementById('nfcIcon');
            const nfcContainer = document.getElementById('nfcIconContainer');
            const startBtn = document.getElementById('startScanBtn');
            const stopBtn = document.getElementById('stopScanBtn');

            if (scanning) {
                nfcIcon.classList.add('scanning');
                nfcContainer.classList.add('scanning');
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-flex';
            } else {
                nfcIcon.classList.remove('scanning');
                nfcContainer.classList.remove('scanning');
                startBtn.style.display = 'inline-flex';
                stopBtn.style.display = 'none';
            }
        }

        // Update status message
        function updateStatus(message, className) {
            const status = document.getElementById('scanStatus');
            status.textContent = message;
            status.className = 'scan-status';
            if (className) {
                status.classList.add(className);
            }
        }

        // Switch between tabs
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Copy to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Show feedback
                const feedback = document.createElement('div');
                feedback.textContent = 'Copied!';
                feedback.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--green); color: white; padding: 0.75rem 1.5rem; border-radius: 5px; z-index: 9999; animation: fadeOut 2s forwards;';
                document.body.appendChild(feedback);
                setTimeout(() => feedback.remove(), 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add scan to history
        function addToHistory(cardData) {
            const historyItem = {
                serialNumber: cardData.serialNumber,
                timestamp: cardData.timestamp,
                recordCount: cardData.recordCount,
                data: cardData
            };

            scanHistory.unshift(historyItem);
            
            // Keep only last 10 scans
            if (scanHistory.length > 10) {
                scanHistory.pop();
            }

            // Save to localStorage
            localStorage.setItem('nfcScanHistory', JSON.stringify(scanHistory));

            // Update UI
            updateHistoryUI();
        }

        // Load scan history from localStorage
        function loadScanHistory() {
            const saved = localStorage.getItem('nfcScanHistory');
            if (saved) {
                try {
                    scanHistory = JSON.parse(saved);
                    updateHistoryUI();
                } catch (e) {
                    console.error('Error loading history:', e);
                }
            }
        }

        // Update history UI
        function updateHistoryUI() {
            const historySection = document.getElementById('historySection');
            const historyList = document.getElementById('historyList');

            if (scanHistory.length === 0) {
                historySection.style.display = 'none';
                return;
            }

            historySection.style.display = 'block';
            historyList.innerHTML = '';

            scanHistory.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.onclick = () => displayCardData(item.data);

                const date = new Date(item.timestamp);
                const timeStr = date.toLocaleString();

                div.innerHTML = `
                    <div>
                        <strong>${formatSerialNumber(item.serialNumber)}</strong>
                        <br>
                        <small>${item.recordCount} record(s)</small>
                    </div>
                    <span class="history-time">${timeStr}</span>
                `;

                historyList.appendChild(div);
            });
        }

        // Clear history
        function clearHistory() {
            scanHistory = [];
            localStorage.removeItem('nfcScanHistory');
            updateHistoryUI();
        }

        // =============================================
        // Data Encryption Functions (AES-256-GCM)
        // =============================================
        // Company-specific encryption key (derived from company ID)
        const ENCRYPTION_PREFIX = 'DXENC:'; // Prefix to identify encrypted data
        let companyEncryptionKey = null;

        // Generate or retrieve company encryption key
        async function getEncryptionKey() {
            if (companyEncryptionKey) return companyEncryptionKey;
            
            try {
                const companyId = window.authManager?.currentUser?.companyId || 'default';
                // Create a deterministic key from company ID + secret salt
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    new TextEncoder().encode(companyId + '_dreamex_nfc_secure_2024'),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                companyEncryptionKey = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: new TextEncoder().encode('dreamex_nfc_salt_v1'),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );
                
                return companyEncryptionKey;
            } catch (error) {
                console.error('Error generating encryption key:', error);
                throw error;
            }
        }

        // Encrypt data using AES-256-GCM
        async function encryptData(plainText) {
            try {
                const key = await getEncryptionKey();
                const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for GCM
                const encodedData = new TextEncoder().encode(plainText);
                
                const encryptedBuffer = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encodedData
                );
                
                // Combine IV + encrypted data and encode as base64
                const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encryptedBuffer), iv.length);
                
                const base64 = btoa(String.fromCharCode(...combined));
                return ENCRYPTION_PREFIX + base64;
            } catch (error) {
                console.error('Encryption error:', error);
                throw error;
            }
        }

        // Decrypt data using AES-256-GCM
        async function decryptData(encryptedText) {
            try {
                if (!encryptedText.startsWith(ENCRYPTION_PREFIX)) {
                    return { decrypted: false, data: encryptedText };
                }
                
                const base64Data = encryptedText.substring(ENCRYPTION_PREFIX.length);
                const combined = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
                
                const iv = combined.slice(0, 12);
                const encryptedBuffer = combined.slice(12);
                
                const key = await getEncryptionKey();
                
                const decryptedBuffer = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encryptedBuffer
                );
                
                const decryptedText = new TextDecoder().decode(decryptedBuffer);
                return { decrypted: true, data: decryptedText };
            } catch (error) {
                console.error('Decryption error:', error);
                return { decrypted: false, data: encryptedText, error: 'Unable to decrypt - different company key or corrupted data' };
            }
        }

        // Check if data is encrypted
        function isEncryptedData(data) {
            return typeof data === 'string' && data.startsWith(ENCRYPTION_PREFIX);
        }

        // =============================================
        // Password Protection Functions
        // =============================================
        let pendingWriteData = null;
        let detectedPasswordHash = null;

        // Toggle password input field visibility
        function togglePasswordField() {
            const checkbox = document.getElementById('enablePassword');
            const passwordGroup = document.getElementById('passwordInputGroup');
            passwordGroup.style.display = checkbox.checked ? 'block' : 'none';
            if (!checkbox.checked) {
                document.getElementById('cardPassword').value = '';
            }
        }

        // Toggle password visibility in write form
        function togglePasswordVisibility() {
            const input = document.getElementById('cardPassword');
            const icon = document.getElementById('passwordToggleIcon');
            if (input.type === 'password') {
                input.type = 'text';
                icon.className = 'fas fa-eye-slash';
            } else {
                input.type = 'password';
                icon.className = 'fas fa-eye';
            }
        }

        // Toggle password visibility in verification modal
        function toggleVerifyPasswordVisibility() {
            const input = document.getElementById('verifyPassword');
            const icon = document.getElementById('verifyPasswordToggleIcon');
            if (input.type === 'password') {
                input.type = 'text';
                icon.className = 'fas fa-eye-slash';
            } else {
                input.type = 'password';
                icon.className = 'fas fa-eye';
            }
        }

        // Simple hash function for password (SHA-256 style)
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password + '_nfc_card_protection');
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Check if card has password protection by reading it first
        async function checkCardProtection() {
            // In WebView mode, skip password check (native app handles it)
            if (isWebViewApp || nativeNFCAvailable) {
                console.log('WebView mode - skipping card protection check');
                return { protected: false, hash: null, serialNumber: null };
            }
            
            // Web NFC check
            if (!('NDEFReader' in window)) {
                return { protected: false, hash: null, serialNumber: null };
            }
            
            return new Promise(async (resolve) => {
                try {
                    const ndef = new NDEFReader();
                    const controller = new AbortController();
                    
                    // Set a timeout to stop scanning
                    const timeout = setTimeout(() => {
                        controller.abort();
                        resolve({ protected: false, hash: null, serialNumber: null });
                    }, 3000);

                    ndef.addEventListener('reading', ({ message, serialNumber }) => {
                        clearTimeout(timeout);
                        controller.abort();
                        
                        // Look for password protection record (both legacy and proprietary formats)
                        for (const record of message.records) {
                            // Legacy format
                            if (record.recordType === 'mime' && record.mediaType === 'application/x-nfc-password') {
                                const decoder = new TextDecoder();
                                const hash = decoder.decode(record.data);
                                resolve({ protected: true, hash: hash, serialNumber });
                                return;
                            }
                            // Proprietary format (DXP: prefix)
                            if (record.recordType === 'mime' && record.mediaType === 'application/octet-stream') {
                                const decoder = new TextDecoder();
                                const data = decoder.decode(record.data);
                                if (data.startsWith('DXP:')) {
                                    const hash = data.substring(4);
                                    resolve({ protected: true, hash: hash, serialNumber });
                                    return;
                                }
                            }
                        }
                        resolve({ protected: false, hash: null, serialNumber });
                    }, { once: true });

                    await ndef.scan({ signal: controller.signal });
                } catch (error) {
                    resolve({ protected: false, hash: null, serialNumber: null });
                }
            });
        }

        // Open password verification modal
        function openPasswordModal(hash) {
            detectedPasswordHash = hash;
            document.getElementById('passwordModal').style.display = 'flex';
            document.getElementById('verifyPassword').value = '';
            document.getElementById('passwordError').style.display = 'none';
            document.getElementById('verifyPassword').focus();
        }

        // Close password verification modal
        function closePasswordModal() {
            document.getElementById('passwordModal').style.display = 'none';
            pendingWriteData = null;
            detectedPasswordHash = null;
            
            // Reset write UI
            document.getElementById('writeNfcBtn').style.display = 'inline-flex';
            document.getElementById('cancelWriteBtn').style.display = 'none';
            document.getElementById('nfcIcon').classList.remove('writing');
            document.getElementById('nfcIconContainer').classList.remove('scanning');
            showWriteStatus('Write cancelled - password verification required.', 'error');
        }

        // Verify password and proceed with write
        async function verifyAndWrite() {
            const enteredPassword = document.getElementById('verifyPassword').value;
            
            if (!enteredPassword) {
                document.getElementById('passwordError').textContent = 'Please enter the password.';
                document.getElementById('passwordError').style.display = 'block';
                return;
            }

            const enteredHash = await hashPassword(enteredPassword);
            
            if (enteredHash !== detectedPasswordHash) {
                document.getElementById('passwordError').textContent = 'Incorrect password. Please try again.';
                document.getElementById('passwordError').style.display = 'block';
                document.getElementById('verifyPassword').value = '';
                document.getElementById('verifyPassword').focus();
                return;
            }

            // Password correct - close modal and proceed with write
            document.getElementById('passwordModal').style.display = 'none';
            
            if (pendingWriteData) {
                await executeNFCWrite(pendingWriteData);
            }
        }

        // Start NFC Write
        async function startNFCWrite() {
            if (!checkNFCSupport()) return;
            
            // Validate input
            const writeData = getWriteData();
            if (!writeData.valid) {
                showWriteStatus(writeData.error, 'error');
                return;
            }

            // Check if password protection is enabled and validate password
            const enablePassword = document.getElementById('enablePassword').checked;
            if (enablePassword) {
                const password = document.getElementById('cardPassword').value;
                if (!password || password.length < 4) {
                    showWriteStatus('Password must be at least 4 characters.', 'error');
                    return;
                }
                writeData.password = password;
            }
            
            // Check if encryption is enabled
            const enableEncryption = document.getElementById('enableEncryption').checked;
            writeData.encrypt = enableEncryption;

            // Permanent Read-Only request (to be finalized via mobile app)
            const enablePermanentLock = document.getElementById('enablePermanentLock').checked;
            writeData.permanentLock = !!enablePermanentLock;
            
            try {
                isWriting = true;
                writeAbortController = new AbortController();
                
                // Update UI
                document.getElementById('writeNfcBtn').style.display = 'none';
                document.getElementById('cancelWriteBtn').style.display = 'inline-flex';
                document.getElementById('nfcIcon').classList.add('writing');
                document.getElementById('nfcIconContainer').classList.add('scanning');
                
                // In WebView mode, use native bridge directly
                if (isWebViewApp || nativeNFCAvailable) {
                    console.log('WebView mode - using native NFC write');
                    showWriteStatus('ðŸ“± Hold your NFC card near the device...', 'writing');
                    
                    const nativeWriteStarted = requestNativeNFCWrite(writeData);
                    if (nativeWriteStarted) {
                        console.log('Native NFC write requested');
                        return;
                    }
                    
                    // If native bridge didn't respond, still wait for card
                    showWriteStatus('ðŸ“± Ready to write. Hold card near device...', 'writing');
                    console.log('Waiting for native NFC write callback...');
                    return;
                }
                
                showWriteStatus('Checking card... Hold your NFC card near the device.', 'writing');
                
                // First, check if the card is password protected (Web NFC only)
                const protection = await checkCardProtection();
                // save serial for lock queuing later
                writeData._serialForLock = protection.serialNumber || null;
                
                if (protection.protected) {
                    // Card is protected - show password modal
                    pendingWriteData = writeData;
                    openPasswordModal(protection.hash);
                    return;
                }
                
                // Card is not protected - proceed with write
                await executeNFCWrite(writeData);
                
            } catch (error) {
                console.error('NFC Write Error:', error);
                
                // In WebView, suppress errors and wait for native
                if (isWebViewApp) {
                    console.log('WebView mode - ignoring write error, waiting for native');
                    showWriteStatus('ðŸ“± Hold card near device to write...', 'writing');
                    return;
                }
                
                handleWriteError(error);
            }
        }

        // Execute the actual NFC write operation
        async function executeNFCWrite(writeData) {
            try {
                // Update UI for writing
                document.getElementById('writeNfcBtn').style.display = 'none';
                document.getElementById('cancelWriteBtn').style.display = 'inline-flex';
                document.getElementById('nfcIcon').classList.add('writing');
                document.getElementById('nfcIconContainer').classList.add('scanning');
                showWriteStatus('Writing to NFC card...', 'writing');
                
                // Try native Android bridge first (for WebToApp / WebView apps)
                if (isWebViewApp || nativeNFCAvailable) {
                    console.log('Attempting native NFC write...');
                    const nativeWriteStarted = requestNativeNFCWrite(writeData);
                    if (nativeWriteStarted) {
                        console.log('Native NFC write requested');
                        // Native app will call onNativeNFCWriteComplete when done
                        return;
                    }
                    console.log('Native write bridge not available, trying Web NFC...');
                }
                
                // Fallback to Web NFC API
                if (!('NDEFReader' in window)) {
                    if (isWebViewApp) {
                        // WebView mode - assume native handles it
                        showWriteStatus('ðŸ“± Hold card near device to write...', 'writing');
                        return;
                    }
                    throw new Error('NFC not available for writing');
                }
                
                const ndef = new NDEFReader();
                writeAbortController = new AbortController();
                
                // Build NDEF message based on type (with password if enabled)
                const message = await buildNDEFMessage(writeData);
                
                await ndef.write(message, { signal: writeAbortController.signal });
                
                // Success
                if ('vibrate' in navigator) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                let successMsg = 'Successfully written to NFC card!';
                const features = [];
                if (writeData.encrypt) features.push('ðŸ” Encrypted');
                if (writeData.password) features.push('ðŸ”’ Password protected');
                if (features.length > 0) {
                    successMsg += ' ' + features.join(' | ');
                }
                showWriteStatus(successMsg, 'success');

                // If user requested permanent read-only, queue lock request in Firebase for mobile app
                if (writeData.permanentLock) {
                    try {
                        await queuePermanentLock(writeData._serialForLock);
                    } catch (e) {
                        console.error('Error queuing permanent lock', e);
                    }
                }
                
                // Add to write history
                addWriteRecord({
                    type: writeData.type,
                    name: writeData.type === 'vcard' ? (document.getElementById('vcardName')?.selectedOptions[0]?.text || '-') : (writeData.data?.substring(0, 30) || '-'),
                    organization: writeData.type === 'vcard' ? (document.getElementById('vcardOrg')?.value || '-') : '-',
                    encrypted: writeData.encrypt || false,
                    passwordProtected: !!writeData.password
                });
                
                // Clear password field after successful write
                document.getElementById('cardPassword').value = '';
                
            } catch (error) {
                console.error('NFC Write Error:', error);
                handleWriteError(error);
            } finally {
                isWriting = false;
                pendingWriteData = null;
                document.getElementById('writeNfcBtn').style.display = 'inline-flex';
                document.getElementById('cancelWriteBtn').style.display = 'none';
                document.getElementById('nfcIcon').classList.remove('writing');
                document.getElementById('nfcIconContainer').classList.remove('scanning');
            }
        }

        // Handle write errors
        function handleWriteError(error) {
            // In WebView mode, suppress errors and continue waiting for native NFC
            if (isWebViewApp) {
                console.log('WebView mode - suppressing write error:', error);
                showWriteStatus('ðŸ“± Ready to write. Hold card near device...', 'writing');
                return;
            }
            
            let errorMessage = 'Error writing to NFC card';
            if (error.name === 'NotAllowedError') {
                errorMessage = 'NFC permission denied. Please allow NFC access.';
            } else if (error.name === 'NotSupportedError') {
                errorMessage = 'NFC writing is not supported on this device.';
            } else if (error.name === 'AbortError') {
                errorMessage = 'Write operation cancelled.';
            } else if (error.name === 'NotReadableError') {
                errorMessage = 'Could not read from NFC card. Try again.';
            } else if (error.message) {
                errorMessage = error.message;
            }
            
            showWriteStatus(errorMessage, 'error');
            
            isWriting = false;
            document.getElementById('writeNfcBtn').style.display = 'inline-flex';
            document.getElementById('cancelWriteBtn').style.display = 'none';
            document.getElementById('nfcIcon').classList.remove('writing');
            document.getElementById('nfcIconContainer').classList.remove('scanning');
        }

        // Cancel NFC Write
        function cancelNFCWrite() {
            if (writeAbortController) {
                writeAbortController.abort();
                writeAbortController = null;
            }
            isWriting = false;
            pendingWriteData = null;
            document.getElementById('writeNfcBtn').style.display = 'inline-flex';
            document.getElementById('cancelWriteBtn').style.display = 'none';
            document.getElementById('nfcIcon').classList.remove('writing');
            document.getElementById('nfcIconContainer').classList.remove('scanning');
            showWriteStatus('Write operation cancelled.', 'error');
        }

        // Get write data from form
        function getWriteData() {
            switch (selectedWriteType) {
                case 'text':
                    const text = document.getElementById('writeText').value.trim();
                    if (!text) {
                        return { valid: false, error: 'Please enter some text to write.' };
                    }
                    return { valid: true, type: 'text', data: text };
                    
                case 'url':
                    const url = document.getElementById('writeUrl').value.trim();
                    if (!url) {
                        return { valid: false, error: 'Please enter a URL.' };
                    }
                    if (!isValidUrl(url)) {
                        return { valid: false, error: 'Please enter a valid URL (including http:// or https://).' };
                    }
                    return { valid: true, type: 'url', data: url };
                    
                case 'json':
                    const jsonStr = document.getElementById('writeJson').value.trim();
                    if (!jsonStr) {
                        return { valid: false, error: 'Please enter JSON data.' };
                    }
                    try {
                        JSON.parse(jsonStr);
                        return { valid: true, type: 'json', data: jsonStr };
                    } catch (e) {
                        return { valid: false, error: 'Invalid JSON: ' + e.message };
                    }
                    
                case 'vcard':
                    const name = document.getElementById('vcardName').value.trim();
                    if (!name) {
                        return { valid: false, error: 'Please enter at least a name for the vCard.' };
                    }
                    return { valid: true, type: 'vcard', data: generateVCard() };
                    
                default:
                    return { valid: false, error: 'Unknown data type.' };
            }
        }

        // Build NDEF message for writing
        async function buildNDEFMessage(writeData) {
            const records = [];
            const shouldEncrypt = writeData.encrypt;
            
            // Add password protection record if password is set (also encrypted format)
            if (writeData.password) {
                const passwordHash = await hashPassword(writeData.password);
                if (shouldEncrypt) {
                    // Even password hash uses proprietary format
                    records.push({
                        recordType: 'mime',
                        mediaType: 'application/octet-stream',
                        data: new TextEncoder().encode('DXP:' + passwordHash)
                    });
                } else {
                    records.push({
                        recordType: 'mime',
                        mediaType: 'application/x-nfc-password',
                        data: new TextEncoder().encode(passwordHash)
                    });
                }
            }
            
            if (shouldEncrypt) {
                // PROPRIETARY ENCRYPTED FORMAT
                // Creates a single binary blob that other apps cannot interpret
                // Format: DXD:[type_code][encrypted_payload]
                // Type codes: T=text, U=url, J=json, V=vcard
                const typeCode = { text: 'T', url: 'U', json: 'J', vcard: 'V' }[writeData.type] || 'X';
                const encryptedPayload = await encryptData(writeData.data);
                const proprietaryData = 'DXD:' + typeCode + encryptedPayload;
                
                // Store as raw binary with generic MIME type - completely unrecognizable
                records.push({
                    recordType: 'mime',
                    mediaType: 'application/octet-stream',
                    data: new TextEncoder().encode(proprietaryData)
                });
                
                console.log('ðŸ” Data stored in proprietary encrypted format - unreadable by other apps');
            } else {
                // Unencrypted - use standard formats
                switch (writeData.type) {
                    case 'text':
                        records.push({
                            recordType: 'text',
                            data: writeData.data,
                            lang: 'en'
                        });
                        break;
                        
                    case 'url':
                        records.push({
                            recordType: 'url',
                            data: writeData.data
                        });
                        break;
                        
                    case 'json':
                        records.push({
                            recordType: 'mime',
                            mediaType: 'application/json',
                            data: new TextEncoder().encode(writeData.data)
                        });
                        break;
                        
                    case 'vcard':
                        records.push({
                            recordType: 'mime',
                            mediaType: 'text/vcard',
                            data: new TextEncoder().encode(writeData.data)
                        });
                        break;
                }
            }
            
            return { records };
        }

        // Show write status message
        function showWriteStatus(message, type) {
            const status = document.getElementById('writeStatus');
            status.textContent = message;
            status.className = 'write-status ' + type;
        }

        // Add CSS for fadeOut animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeOut {
                0%, 70% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // =============================================
        // AuthManager class for centralized authentication
        // =============================================
        class AuthManager {
            constructor() {
                this.currentUser = this.getCurrentUser();
                this.currentCompany = null;
                this.init();
            }
            getCurrentUser() {
                try { return JSON.parse(localStorage.getItem('currentUser') || 'null'); } catch { return null; }
            }
            setCurrentUser(u) {
                localStorage.setItem('currentUser', JSON.stringify(u));
                localStorage.setItem('user', JSON.stringify(u));
                this.currentUser = u;
            }
            async init() {
                if (!this.currentUser) {
                    window.location.href = 'login.html';
                    return;
                }
                await this.loadUserCompany();
                this.updateCompanyBranding();
                await this.updateUIForAuthenticatedUser();
                this.bindProfileDropdown();
                // Load company for vCard organization field after company data is ready
                if (typeof loadCompanies === 'function') {
                    loadCompanies();
                }
            }
            async loadUserCompany() {
                if (!this.currentUser) return;
                try {
                    // Fast path: if user already has companyId, load just that company
                    if (this.currentUser.companyId) {
                        const compSnap = await firebase.database().ref(`companies/${this.currentUser.companyId}`).once('value');
                        if (compSnap.exists()) {
                            const comp = compSnap.val();
                            if (comp.status === 'active') {
                                this.currentCompany = comp;
                                this.currentUser.companyName = comp.companyName;
                                // Get user's role from the company
                                if (comp.users && comp.users[this.currentUser.uid]) {
                                    const userData = comp.users[this.currentUser.uid];
                                    this.currentUser.role = userData.role || userData.userRole || this.currentUser.role || 'user';
                                }
                                this.setCurrentUser(this.currentUser);
                                return;
                            }
                        }
                    }
                    
                    // Fallback: search all companies if no companyId or company not found
                    const snap = await firebase.database().ref('companies').once('value');
                    if (!snap.exists()) return;
                    const companies = snap.val();
                    for (const [cid, comp] of Object.entries(companies)) {
                        if (comp.status !== 'active') continue;
                        if (comp.users) {
                            for (const [uid, u] of Object.entries(comp.users)) {
                                if (u.authUid === this.currentUser.uid || uid === this.currentUser.uid) {
                                    this.currentUser.companyId = cid;
                                    this.currentUser.companyName = comp.companyName;
                                    this.currentUser.role = u.role || u.userRole || 'user';
                                    this.currentCompany = comp;
                                    this.setCurrentUser(this.currentUser);
                                    return;
                                }
                            }
                        }
                    }
                } catch (e) { }
            }
            updateCompanyBranding() {
                const logoEl = document.getElementById('headerCompanyLogo');
                const nameEl = document.getElementById('headerCompanyName');
                if (!this.currentCompany) { this.showFallbackBranding(); return; }
                if (nameEl) nameEl.textContent = this.currentCompany.companyName || '';
                const logoUrl = this.currentCompany.logo || this.currentCompany.logoUrl;
                if (logoEl) {
                    if (logoUrl) {
                        logoEl.src = logoUrl;
                        logoEl.style.display = 'block';
                    } else {
                        const svg = this.generateCompanyInitialsSVG(this.getCompanyInitials(this.currentCompany.companyName || ''));
                        logoEl.src = svg;
                        logoEl.style.display = 'block';
                    }
                }
            }
            showFallbackBranding() {
                const logoEl = document.getElementById('headerCompanyLogo');
                if (logoEl) {
                    const svg = this.generateCompanyInitialsSVG('DX');
                    logoEl.src = svg;
                    logoEl.style.display = 'block';
                }
            }
            getCompanyInitials(name) {
                if (!name) return 'CO';
                const parts = name.trim().split(/\s+/);
                if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                return (parts[0][0] + parts[1][0]).toUpperCase();
            }
            generateCompanyInitialsSVG(initials) {
                const svg = `<svg width="44" height="44" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><rect width="44" height="44" rx="6" fill="#f0f3f6"/><text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle" fill="#495057" font-family="Inter,Arial,sans-serif" font-weight="600" font-size="14">${initials}</text></svg>`;
                return 'data:image/svg+xml;base64,' + btoa(svg);
            }
            getUserDisplayName() {
                if (!this.currentUser) return 'User';
                const n = v => typeof v === 'string' ? v.trim().replace(/\s+/g, ' ') : '';
                const cand = [this.currentUser.displayName, this.currentUser.name, this.currentUser.username];
                for (const c of cand) { const cleaned = n(c); if (cleaned) return cleaned; }
                if (this.currentUser.email) return n(this.currentUser.email.split('@')[0]) || 'User';
                return 'User';
            }
            getUserInitials() {
                const dn = this.getUserDisplayName();
                const parts = dn.split(' ').filter(Boolean);
                if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                return parts.slice(0, 2).map(p => p[0]).join('').toUpperCase();
            }
            async getUserAvatarUrl() {
                if (!this.currentUser) return null;
                const companyId = this.currentUser.companyId || 'default';
                const possiblePaths = [
                    `companies/${companyId}/avatars/${this.currentUser.uid}/profile.jpg`,
                    `companies/${companyId}/avatars/${this.currentUser.uid}/profile.png`,
                    `avatars/${this.currentUser.uid}/profile.jpg`,
                    `avatars/${this.currentUser.uid}/profile.png`
                ];
                for (const path of possiblePaths) {
                    try {
                        const ref = firebase.storage().ref(path);
                        const url = await ref.getDownloadURL();
                        return url;
                    } catch (err) { continue; }
                }
                return null;
            }
            async updateUIForAuthenticatedUser() {
                const btn = document.getElementById('userProfileBtn');
                const list = document.querySelector('.profile-dropdown ul');
                if (!btn || !list || !this.currentUser) return;
                const displayName = this.getUserDisplayName();
                const email = this.currentUser.email || '';
                
                let avatarUrl = null;
                try { avatarUrl = await this.getUserAvatarUrl(); } catch (error) { }
                
                const btnImg = btn.querySelector('img');
                if (avatarUrl && btnImg) {
                    btnImg.src = avatarUrl;
                    btnImg.alt = displayName + ' Avatar';
                    btnImg.style.display = 'block';
                    btnImg.onerror = () => {
                        btnImg.style.display = 'none';
                        btn.innerHTML = `<div style="width:38px;height:38px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:0.8rem;">${this.getUserInitials()}</div>`;
                    };
                } else {
                    btn.innerHTML = `<div style="width:38px;height:38px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:0.8rem;">${this.getUserInitials()}</div>`;
                }
                
                const avatarHtml = avatarUrl ? `<img src="${avatarUrl}" alt="${displayName} Avatar" style="width:32px;height:32px;border-radius:50%;object-fit:cover;">` : `<div style="width:32px;height:32px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:12px;">${this.getUserInitials()}</div>`;
                list.innerHTML = `<li style="border-bottom:1px solid #eee;padding:12px 16px;background:#f8f9fa;"><div style="display:flex;align-items:center;gap:12px;">${avatarHtml}<div><div style="font-weight:600;color:#333;font-size:14px;margin-bottom:2px;">${displayName}</div><div style="color:#666;font-size:12px;">${email}</div></div></div></li><li><a href="profile.html"><i class="fas fa-user"></i> Profile</a></li><li><a href="account.html"><i class="fas fa-cog"></i> Account Settings</a></li><li><a href="#" id="logoutLink"><i class="fas fa-sign-out-alt"></i> Sign out</a></li>`;
                list.querySelector('#logoutLink')?.addEventListener('click', e => { e.preventDefault(); this.logout(); });
            }
            bindProfileDropdown() {
                const btn = document.getElementById('userProfileBtn');
                const dd = document.querySelector('.profile-dropdown');
                if (btn && dd) {
                    btn.addEventListener('click', e => { e.stopPropagation(); dd.classList.toggle('show'); });
                    document.addEventListener('click', e => { if (!btn.contains(e.target)) dd.classList.remove('show'); });
                }
            }
            async logout() {
                try {
                    await firebase.auth().signOut();
                    localStorage.removeItem('currentUser');
                    localStorage.removeItem('user');
                    window.location.href = 'login.html';
                } catch (error) {
                    localStorage.removeItem('currentUser');
                    localStorage.removeItem('user');
                    window.location.href = 'login.html';
                }
            }
        }

        // =============================================
        // Notification System
        // =============================================
        function getAuthUser() {
            if (window.authManager && window.authManager.currentUser) return window.authManager.currentUser;
            try { return JSON.parse(localStorage.getItem('currentUser') || 'null'); } catch { return null; }
        }

        async function loadNotificationsOnce() {
            const user = getAuthUser();
            if (!user) return [];
            const snap = await firebase.database().ref(`notifications/${user.uid}`).once('value');
            if (!snap.exists()) return [];
            const list = Object.entries(snap.val()).map(([id, v]) => ({ id, ...v }));
            list.sort((a,b)=> (b.timestamp||0) - (a.timestamp||0));
            return list;
        }

        async function markAllNotificationsAsRead() {
            const user = getAuthUser();
            if (!user) return;
            const ref = firebase.database().ref(`notifications/${user.uid}`);
            const snap = await ref.once('value');
            if (!snap.exists()) return;
            const updates = {};
            Object.keys(snap.val()).forEach(k => { updates[`${k}/read`] = true; });
            await ref.update(updates);
            updateNotificationBadgeCount([]);
        }

        async function markNotificationAsRead(notificationId) {
            const user = getAuthUser();
            if (!user || !notificationId) return;
            await firebase.database().ref(`notifications/${user.uid}/${notificationId}/read`).set(true);
        }

        async function deleteNotificationWithConfirm(notificationId) {
            if (!confirm('Delete this notification?')) return;
            const user = getAuthUser();
            if (!user || !notificationId) return;
            await firebase.database().ref(`notifications/${user.uid}/${notificationId}`).remove();
            const notifications = await loadNotificationsOnce();
            populateNotificationDropdown(notifications);
        }

        async function clearAllNotifications() {
            if (!confirm('Delete all notifications? This cannot be undone.')) return;
            const user = getAuthUser();
            if (!user) return;
            await firebase.database().ref(`notifications/${user.uid}`).remove();
        }

        function formatTimeAgo(ts) {
            if (!ts) return 'Just now';
            const diff = Date.now() - ts;
            const m = Math.floor(diff/60000); const h = Math.floor(diff/3600000); const d = Math.floor(diff/86400000);
            if (m < 1) return 'Just now';
            if (m < 60) return `${m}m ago`; if (h < 24) return `${h}h ago`; return `${d}d ago`;
        }

        function updateNotificationBadgeCount(notifications) {
            const badge = document.querySelector('.notification-badge');
            if (!badge) return;
            const unread = notifications.filter(n => !n.read).length;
            if (unread > 0) { badge.textContent = unread > 99 ? '99+' : String(unread); badge.style.display = 'block'; }
            else { badge.style.display = 'none'; }
        }

        function populateNotificationDropdown(notifications) {
            const listEl = document.querySelector('.notification-list');
            const emptyEl = document.querySelector('.notification-empty');
            if (!listEl) return;
            listEl.innerHTML = '';
            if (!notifications || notifications.length === 0) {
                if (emptyEl) emptyEl.style.display = 'block';
                updateNotificationBadgeCount([]);
                return;
            }
            if (emptyEl) emptyEl.style.display = 'none';
            notifications.slice(0,10).forEach(n => {
                const div = document.createElement('div');
                div.className = `notification-item ${n.read ? 'read' : 'unread'}`;
                div.innerHTML = `
                    <div class="notification-content">
                        <div class="notification-title">${n.title || 'New Notification'}</div>
                        <div class="notification-message">${n.message || ''}</div>
                        <div class="notification-time">${formatTimeAgo(n.timestamp)}</div>
                    </div>
                    ${!n.read ? '<div class="notification-dot"></div>' : ''}
                `;
                listEl.appendChild(div);
            });
            updateNotificationBadgeCount(notifications);
        }

        function wireNotificationUI() {
            const btn = document.getElementById('notificationBtn');
            const dropdown = document.querySelector('.notification-dropdown');
            const profileDropdown = document.querySelector('.profile-dropdown');
            if (!btn || !dropdown) return;
            const header = dropdown.querySelector('.notification-header');
            if (header && !header.querySelector('.clear-all-notifications')) {
                const clearBtn = document.createElement('button');
                clearBtn.className = 'clear-all-notifications';
                clearBtn.textContent = 'Clear all';
                clearBtn.style.cssText = 'background:none;border:none;color:#e74c3c;cursor:pointer;font-size:12px;padding:4px 8px;border-radius:4px;margin-left:8px;';
                clearBtn.addEventListener('click', async () => {
                    await clearAllNotifications();
                    const list = await loadNotificationsOnce();
                    populateNotificationDropdown(list);
                });
                header.appendChild(clearBtn);
                const markBtn = header.querySelector('.mark-all-read');
                if (markBtn) markBtn.addEventListener('click', async () => {
                    await markAllNotificationsAsRead();
                    const list = await loadNotificationsOnce();
                    populateNotificationDropdown(list);
                });
            }
            btn.addEventListener('click', async (e) => {
                e.stopPropagation();
                dropdown.classList.toggle('show');
                if (profileDropdown) profileDropdown.classList.remove('show');
                if (dropdown.classList.contains('show')) {
                    const list = await loadNotificationsOnce();
                    populateNotificationDropdown(list);
                }
            });
            document.addEventListener('click', (e) => {
                if (!btn.contains(e.target) && !dropdown.contains(e.target)) dropdown.classList.remove('show');
            });
        }

        function subscribeNotifications() {
            try {
                const user = getAuthUser();
                if (!user) return;
                const ref = firebase.database().ref(`notifications/${user.uid}`);
                ref.on('value', (snap) => {
                    if (!snap.exists()) { updateNotificationBadgeCount([]); return; }
                    const list = Object.values(snap.val());
                    updateNotificationBadgeCount(list);
                });
            } catch (e) { }
        }

        // =============================================
        // Menu Authorization System (from project-list.html)
        // =============================================
        let isMenuUpdateInProgress = false;

        // Reset all menu items to hidden (preserve core features only when authorized)
        function resetMenuVisibility() {
            document.querySelectorAll('[data-feature]').forEach(item => {
                item.classList.remove('menu-visible');
            });
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                dropdown.classList.remove('menu-visible');
            });
        }

        // Emergency fallback - show basic menu items
        function showBasicMenu() {
            console.log('ðŸ”§ Emergency fallback: Showing basic menu items');
            resetMenuVisibility();
            
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.classList.remove('menu-loading');
            }
            
            const homeItem = document.querySelector('[data-feature="home_view"]');
            if (homeItem) {
                homeItem.classList.add('menu-visible');
            }
        }

        // Feature-based authorization system that takes priority over role permissions
        async function updateMenuWithFeatureAuthorization() {
            // Prevent multiple simultaneous executions
            if (isMenuUpdateInProgress) {
                console.log('ðŸ”„ Menu update already in progress, skipping...');
                return;
            }
            
            isMenuUpdateInProgress = true;
            console.log('ðŸŽ¯ Starting feature-based menu authorization for nfc.html...');
            
            try {
                let currentUser = null;
                let companyId = null;
                let userRole = null;
                
                // Get user and company info using authManager first
                if (window.authManager && window.authManager.currentUser) {
                    currentUser = window.authManager.currentUser;
                    companyId = currentUser.companyId;
                    userRole = currentUser.role;
                    console.log('ðŸ‘¤ Using AuthManager - User:', currentUser.email, 'Company ID:', companyId, 'Role:', userRole);
                } else if (firebase.auth().currentUser) {
                    currentUser = firebase.auth().currentUser;
                    console.log('ðŸ‘¤ Using Firebase auth - will search for company and role');
                } else {
                    console.log('âŒ No authenticated user found');
                    resetMenuVisibility();
                    return;
                }
                
                // If no company ID from authManager, search companies collection
                if (!companyId && currentUser) {
                    console.log('ðŸ” Searching for user company and role...');
                    const database = firebase.database();
                    const companiesRef = database.ref('companies');
                    const companiesSnapshot = await companiesRef.once('value');
                    
                    if (companiesSnapshot.exists()) {
                        const companies = companiesSnapshot.val();
                        
                        for (const [cId, company] of Object.entries(companies)) {
                            if (company.status !== 'active') continue;
                            
                            if (company.users && company.users[currentUser.uid]) {
                                companyId = cId;
                                userRole = company.users[currentUser.uid].role || company.users[currentUser.uid].userRole;
                                console.log(`âœ… Found user in company: ${companyId} (${company.name}) with role: ${userRole}`);
                                break;
                            }
                        }
                    }
                }
                
                if (!companyId) {
                    console.error('âŒ No company ID found, cannot determine authorized features');
                    resetMenuVisibility();
                    return;
                }
                
                if (!userRole) {
                    console.warn('âš ï¸ No user role found, proceeding with company features only');
                }
                
                // STEP 1: Apply company feature-based authorization
                console.log('ðŸ¢ STEP 1: Applying company feature authorization...');
                const authorizedPages = await applyFeatureBasedMenuVisibility(companyId);
                
                // STEP 2: Filter by user role permissions within authorized features
                if (userRole) {
                    console.log('ðŸ‘¤ STEP 2: Applying role-based filtering within authorized features...');
                    await applyRoleBasedFiltering(companyId, userRole, authorizedPages);
                } else {
                    console.log('âš ï¸ STEP 2: Skipping role-based filtering (no role found)');
                }
                
            } catch (error) {
                console.error('âŒ Error in feature-based menu authorization:', error);
                resetMenuVisibility();
            } finally {
                // Reset the flag to allow future updates
                isMenuUpdateInProgress = false;
            }
        }

        // Apply feature-based menu visibility
        async function applyFeatureBasedMenuVisibility(companyId) {
            try {
                console.log('ðŸ”§ Applying feature-based menu visibility for company:', companyId);
                
                // Get platform features
                const database = firebase.database();
                const featuresSnapshot = await database.ref('/platformFeatures').once('value');
                
                if (!featuresSnapshot.exists()) {
                    console.log('âš ï¸ No platform features found');
                    resetMenuVisibility();
                    return;
                }
                
                const featuresData = featuresSnapshot.val();
                
                // Get company's selected features
                const companySnapshot = await database.ref(`/companies/${companyId}`).once('value');
                const companyData = companySnapshot.val();
                
                if (!companyData) {
                    console.error('âŒ Company data not found');
                    resetMenuVisibility();
                    return;
                }
                
                const subscribedFeatureIds = companyData.selectedFeatures || [];
                console.log('ðŸ¢ Company subscribed features:', subscribedFeatureIds);
                
                if (subscribedFeatureIds.length === 0) {
                    console.log('âš ï¸ Company has no subscribed features');
                    resetMenuVisibility();
                    return;
                }
                
                // Collect authorized pages from subscribed features
                const authorizedPages = [];
                subscribedFeatureIds.forEach(featureId => {
                    const feature = featuresData[featureId];
                    if (feature && feature.status === 'active' && feature.authorizedPages) {
                        console.log(`ðŸ“¦ Adding pages from feature "${feature.name}":`, feature.authorizedPages);
                        authorizedPages.push(...feature.authorizedPages);
                    } else {
                        console.log(`âš ï¸ Feature ${featureId} not found or inactive`);
                    }
                });
                
                console.log('ðŸ” All authorized pages:', authorizedPages);
                
                // Reset all menu items first
                resetMenuVisibility();
                
                // Create set of authorized features and hrefs (with alias mapping)
                const authorizedFeatures = new Set();
                const authorizedHrefs = new Set();

                const featureAlias = (key) => {
                    if (!key) return key;
                    // Treat these as aliases of each other
                    if (key === 'risk_view') return 'risk_management_section';
                    if (key === 'risk_management_section') return 'risk_view';
                    return null;
                };
                const normalizeHref = (href) => {
                    if (!href) return '';
                    // Keep relative path portion only
                    try {
                        // If absolute, take pathname; else, use as is
                        const u = new URL(href, window.location.origin);
                        return (u.pathname || '').replace(/^\//, '');
                    } catch {
                        return String(href).replace(/^\//, '');
                    }
                };

                authorizedPages.forEach(pageInfo => {
                    if (pageInfo.feature) {
                        authorizedFeatures.add(pageInfo.feature);
                        const alias = featureAlias(pageInfo.feature);
                        if (alias) authorizedFeatures.add(alias);
                    }
                    if (pageInfo.href) authorizedHrefs.add(normalizeHref(pageInfo.href));
                    if (pageInfo.page) authorizedHrefs.add(normalizeHref(pageInfo.page));
                    if (pageInfo.url) authorizedHrefs.add(normalizeHref(pageInfo.url));
                });

                console.log('ðŸŽ¯ Authorized features for nfc.html:', Array.from(authorizedFeatures));
                console.log('ðŸ”— Authorized hrefs for nfc.html:', Array.from(authorizedHrefs));
                
                // Apply menu visibility
                const allMenuItems = document.querySelectorAll('#roleBasedMenu li[data-feature]');
                let visibleCount = 0;
                
                allMenuItems.forEach(menuItem => {
                    const featureAttribute = menuItem.getAttribute('data-feature');
                    const isDropdownContainer = menuItem.classList.contains('menu-dropdown');
                    const anchor = menuItem.querySelector('a[href]');
                    const href = anchor ? anchor.getAttribute('href') : '';
                    const normalized = normalizeHref(href);
                    const featureAuthorized = authorizedFeatures.has(featureAttribute);
                    const hrefAuthorized = normalized && authorizedHrefs.has(normalized);
                    const isAuthorized = featureAuthorized || hrefAuthorized;

                    if (isDropdownContainer) {
                        return; // Handle dropdowns separately after all items are processed
                    }

                    if (isAuthorized) {
                        menuItem.classList.add('menu-visible');
                        visibleCount++;
                        console.log(`âœ… Authorized - showing: feature=${featureAttribute} href=${normalized || 'â€”'}`);
                    } else {
                        menuItem.classList.remove('menu-visible');
                        console.log(`âŒ Not authorized - hiding: feature=${featureAttribute} href=${normalized || 'â€”'}`);
                    }
                });
                
                // Handle dropdown menus - show if they have visible children
                const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
                dropdownMenus.forEach(dropdown => {
                    const dropdownFeature = dropdown.getAttribute('data-feature');
                    const submenuItems = dropdown.querySelectorAll('.submenu li[data-feature]');
                    let hasVisibleChildren = false;
                    
                    submenuItems.forEach(submenuItem => {
                        if (submenuItem.classList.contains('menu-visible')) {
                            hasVisibleChildren = true;
                        }
                    });
                    
                    if (hasVisibleChildren || authorizedFeatures.has(dropdownFeature)) {
                        dropdown.classList.add('menu-visible');
                        console.log(`âœ… Showing dropdown menu: ${dropdownFeature} (has visible children or directly authorized)`);
                    } else {
                        dropdown.classList.remove('menu-visible');
                        console.log(`âŒ Hiding dropdown menu: ${dropdownFeature} (no visible children and not authorized)`);
                    }
                });
                
                console.log(`ðŸŽ¯ Company feature authorization completed - ${visibleCount} items initially visible`);
                
                // Return authorized pages for role-based filtering
                return authorizedPages;
                
            } catch (error) {
                console.error('âŒ Error applying feature-based menu visibility:', error);
                resetMenuVisibility();
                return [];
            }
        }

        // Apply role-based filtering within company authorized features
        async function applyRoleBasedFiltering(companyId, userRole, authorizedPages) {
            try {
                console.log('ðŸ‘¤ Applying role-based filtering for role:', userRole);
                
                // Get user role permissions from company
                const database = firebase.database();
                const permissionsRef = database.ref(`companies/${companyId}/roles/${userRole}/permissions`);
                const permissionsSnapshot = await permissionsRef.once('value');
                
                if (!permissionsSnapshot.exists()) {
                    console.log(`âš ï¸ No permissions found for role ${userRole} in company ${companyId}`);
                    
                    // Try to get all roles to see what's available
                    const allRolesRef = database.ref(`companies/${companyId}/roles`);
                    const allRolesSnapshot = await allRolesRef.once('value');
                    
                    if (allRolesSnapshot.exists()) {
                        const allRoles = allRolesSnapshot.val();
                        console.log('ðŸ” Available roles in company:', Object.keys(allRoles));
                        
                        // Enhanced debugging for administrator role
                        if (userRole === 'administrator') {
                            console.log('ðŸ”‘ ADMINISTRATOR - Full roles data:', allRoles);
                            if (allRoles.administrator) {
                                console.log('ðŸ”‘ ADMINISTRATOR role found in company:', allRoles.administrator);
                                if (allRoles.administrator.permissions) {
                                    console.log('ðŸ”‘ ADMINISTRATOR permissions found:', allRoles.administrator.permissions);
                                    filterMenuByPermissions(allRoles.administrator.permissions);
                                    return;
                                }
                            }
                        }
                        
                        // Check if the role exists with different casing or format
                        const roleKeys = Object.keys(allRoles);
                        const matchingRole = roleKeys.find(key => 
                            key.toLowerCase() === userRole.toLowerCase() ||
                            key.replace(/\s+/g, '').toLowerCase() === userRole.replace(/\s+/g, '').toLowerCase()
                        );
                        
                        if (matchingRole && allRoles[matchingRole].permissions) {
                            console.log(`âœ… Found matching role: ${matchingRole}`);
                            const permissions = allRoles[matchingRole].permissions;
                            filterMenuByPermissions(permissions);
                            return;
                        }
                    }
                    
                    // CRITICAL: If user is administrator but no permissions found, provide full access as fallback
                    if (userRole === 'administrator') {
                        console.log('ðŸ”‘ ADMINISTRATOR FALLBACK - Skipping role filtering (keeping all company features visible)');
                        showSidebarAfterAuth();
                        return;
                    }
                    
                    // For other roles without permissions, hide all items with permission requirements
                    console.log('âŒ No valid permissions found - filtering out items requiring permissions');
                    hideItemsRequiringPermissions();
                    showSidebarAfterAuth();
                    return;
                }
                
                const permissions = permissionsSnapshot.val();
                console.log('âœ… Loaded role permissions:', permissions);
                
                // Apply permission-based filtering
                filterMenuByPermissions(permissions);
                
            } catch (error) {
                console.error('âŒ Error applying role-based filtering:', error);
                // Don't hide everything on error - keep company features visible
                showSidebarAfterAuth();
            }
        }

        // Filter currently visible menu items by role permissions
        function filterMenuByPermissions(permissions) {
            console.log('ðŸ” Filtering visible menu items by role permissions...');
            
            if (!permissions) {
                console.log('âš ï¸ No permissions object provided');
                hideItemsRequiringPermissions();
                showSidebarAfterAuth();
                return;
            }
            const permissionAlias = (key) => {
                if (!key) return key;
                if (key === 'risk_view') return 'risk_management_section';
                if (key === 'risk_management_section') return 'risk_view';
                return null;
            };

            // Evaluate all permission-gated items (allow role permissions to add visibility too)
            const itemsRequiringPermissions = document.querySelectorAll('#roleBasedMenu li[data-requires-permission]');
            console.log(`ðŸŽ¯ Found ${itemsRequiringPermissions.length} items requiring permissions to check`);

            let hiddenCount = 0;
            let shownByPermission = 0;

            itemsRequiringPermissions.forEach(item => {
                const requiresPermission = item.getAttribute('data-requires-permission');
                const feature = item.getAttribute('data-feature');

                const perm = permissions[requiresPermission];
                const aliasKey = permissionAlias(requiresPermission);
                const aliasPerm = aliasKey ? permissions[aliasKey] : undefined;

                const hasViewPermission = (p) => p === true || (p && p.view === true);
                const allowed = hasViewPermission(perm) || hasViewPermission(aliasPerm);

                if (allowed) {
                    if (!item.classList.contains('menu-visible')) shownByPermission++;
                    item.classList.add('menu-visible');
                    console.log(`âœ… Showing by permission: ${feature} (requires: ${requiresPermission}${aliasKey ? ` | alias: ${aliasKey}` : ''})`);
                } else {
                    if (item.classList.contains('menu-visible')) hiddenCount++;
                    item.classList.remove('menu-visible');
                    console.log(`âŒ Hiding (no permission): ${feature} (requires: ${requiresPermission}${aliasKey ? ` | alias: ${aliasKey}` : ''})`);
                }
            });

            // Re-check dropdown menus after permission filtering
            const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
            dropdownMenus.forEach(dropdown => {
                const submenuItems = dropdown.querySelectorAll('.submenu li.menu-visible');
                const dropdownFeature = dropdown.getAttribute('data-feature');
                const dropdownRequires = dropdown.getAttribute('data-requires-permission');

                if (submenuItems.length === 0) {
                    if (dropdownRequires) {
                        const perm = permissions[dropdownRequires];
                        const aliasKey = permissionAlias(dropdownRequires);
                        const aliasPerm = aliasKey ? permissions[aliasKey] : undefined;
                        const hasViewPermission = (p) => p === true || (p && p.view === true);
                        const allowed = hasViewPermission(perm) || hasViewPermission(aliasPerm);
                        if (allowed) {
                            dropdown.classList.add('menu-visible');
                            console.log(`âœ… Showing dropdown by permission: ${dropdownFeature}`);
                        } else {
                            dropdown.classList.remove('menu-visible');
                            hiddenCount++;
                            console.log(`âŒ Hiding dropdown (no children and no permission): ${dropdownFeature}`);
                        }
                    } else {
                        dropdown.classList.remove('menu-visible');
                        console.log(`âŒ Hiding dropdown (no visible children): ${dropdownFeature}`);
                    }
                } else {
                    console.log(`âœ… Keeping dropdown visible (has ${submenuItems.length} visible children): ${dropdownFeature}`);
                }
            });

            console.log(`ðŸŽ¯ Role-based filtering completed - ${hiddenCount} items hidden; ${shownByPermission} items shown by permission`);
            
            // Ensure at least home is visible
            ensureHomeIsVisible();
            
            // Show sidebar after all filtering is complete
            showSidebarAfterAuth();
        }

        // Hide menu items that require permissions (for users without role permissions)
        function hideItemsRequiringPermissions() {
            console.log('ðŸ”’ Hiding all menu items that require permissions...');
            
            const itemsRequiringPermissions = document.querySelectorAll('#roleBasedMenu li.menu-visible[data-requires-permission]');
            let hiddenCount = 0;
            
            itemsRequiringPermissions.forEach(item => {
                const feature = item.getAttribute('data-feature');
                const requiresPermission = item.getAttribute('data-requires-permission');
                
                item.classList.remove('menu-visible');
                hiddenCount++;
                console.log(`âŒ Hiding menu item (requires permission): ${feature} (${requiresPermission})`);
            });
            
            // Hide dropdowns that only contain permission-required items
            const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
            dropdownMenus.forEach(dropdown => {
                const visibleSubmenuItems = dropdown.querySelectorAll('.submenu li.menu-visible');
                if (visibleSubmenuItems.length === 0) {
                    dropdown.classList.remove('menu-visible');
                    const dropdownFeature = dropdown.getAttribute('data-feature');
                    console.log(`âŒ Hiding dropdown (no visible children): ${dropdownFeature}`);
                }
            });
            
            console.log(`ðŸ”’ Hidden ${hiddenCount} items requiring permissions`);
            
            // Ensure at least home is visible
            ensureHomeIsVisible();
        }

        // Ensure home menu item is visible as fallback
        function ensureHomeIsVisible() {
            const homeItem = document.querySelector('#roleBasedMenu li[data-feature="home_view"]');
            if (homeItem && !homeItem.classList.contains('menu-visible')) {
                homeItem.classList.add('menu-visible');
                console.log('âœ… Ensured home menu item is visible as fallback');
            }
        }

        // Show sidebar and remove loading state after authentication and filtering
        function showSidebarAfterAuth() {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.classList.remove('menu-loading');
                console.log('âœ… Sidebar loading state removed - menu authorization complete');
            }
        }

        // Initialize menu authorization system
        function initializeMenuAuthorization() {
            console.log('ðŸš€ Initializing menu authorization system...');
            
            // Set sidebar to loading state initially
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.classList.add('menu-loading');
            }
            
            // Wait a moment for Firebase to initialize, then start authorization
            setTimeout(() => {
                updateMenuWithFeatureAuthorization();
            }, 500);
        }

        // Make updateMenuWithFeatureAuthorization available globally
        window.updateMenuWithFeatureAuthorization = updateMenuWithFeatureAuthorization;

        // =============================================
        // Page Initialization
        // =============================================
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize AuthManager
            window.authManager = new AuthManager();
            
            // Setup sidebar toggle
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            
            if (sidebarToggle) {
                sidebarToggle.addEventListener('click', function() {
                    sidebar.classList.toggle('collapsed');
                    mainContent.classList.toggle('sidebar-collapsed');
                });
            }
            
            // Wire notification UI
            wireNotificationUI();
            subscribeNotifications();
            
            // Initialize menu authorization
            initializeMenuAuthorization();
        });
    </script>

    <!-- Password Verification Modal -->
    <div id="passwordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3><i class="fas fa-lock" style="color: var(--warning-color);"></i> Password Protected Card</h3>
                <button class="close-btn" onclick="closePasswordModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    This NFC card is password protected. Enter the password to overwrite it.
                </p>
                <div class="form-group">
                    <label for="verifyPassword">Password</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="password" id="verifyPassword" placeholder="Enter card password" style="flex: 1;">
                        <button type="button" class="btn btn-secondary" onclick="toggleVerifyPasswordVisibility()" style="padding: 0.5rem 0.75rem;">
                            <i class="fas fa-eye" id="verifyPasswordToggleIcon"></i>
                        </button>
                    </div>
                </div>
                <div id="passwordError" style="color: var(--danger-color); font-size: 0.875rem; margin-top: 0.5rem; display: none;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closePasswordModal()">Cancel</button>
                <button class="btn btn-primary" onclick="verifyAndWrite()"><i class="fas fa-unlock"></i> Verify & Write</button>
            </div>
        </div>
    </div>
    
    <!-- Set Password Modal -->
    <div id="setPasswordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3><i class="fas fa-key" style="color: var(--purple);"></i> Set Tag Password</h3>
                <button class="close-btn" onclick="closeSetPasswordModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    Set a password to protect this NFC tag from being overwritten by others.
                </p>
                <div class="form-group">
                    <label for="newTagPassword">New Password</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="password" id="newTagPassword" placeholder="Enter new password (min 4 chars)" minlength="4" maxlength="32" style="flex: 1;">
                        <button type="button" class="btn btn-secondary" onclick="toggleNewPasswordVisibility()" style="padding: 0.5rem 0.75rem;">
                            <i class="fas fa-eye" id="newPasswordToggleIcon"></i>
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="confirmTagPassword">Confirm Password</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="password" id="confirmTagPassword" placeholder="Confirm password" minlength="4" maxlength="32" style="flex: 1;">
                    </div>
                </div>
                <div class="form-group" style="margin-top: 1rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="preserveTagData" checked>
                        Preserve existing tag data
                    </label>
                    <small style="color: var(--text-secondary);">If unchecked, tag data will be erased</small>
                </div>
                <div id="setPasswordError" style="color: var(--danger-color); font-size: 0.875rem; margin-top: 0.5rem; display: none;"></div>
                <div id="setPasswordStatus" class="write-status" style="display: none; margin-top: 1rem;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSetPasswordModal()">Cancel</button>
                <button class="btn btn-primary" id="setPasswordBtn" onclick="executeSetPassword()"><i class="fas fa-key"></i> Set Password</button>
            </div>
        </div>
    </div>
    
    <!-- Remove Password Modal -->
    <div id="removePasswordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3><i class="fas fa-unlock" style="color: var(--green);"></i> Remove Tag Password</h3>
                <button class="close-btn" onclick="closeRemovePasswordModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    Enter the current password to remove protection from this NFC tag.
                </p>
                <div class="form-group">
                    <label for="currentTagPassword">Current Password</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="password" id="currentTagPassword" placeholder="Enter current password" style="flex: 1;">
                        <button type="button" class="btn btn-secondary" onclick="toggleCurrentPasswordVisibility()" style="padding: 0.5rem 0.75rem;">
                            <i class="fas fa-eye" id="currentPasswordToggleIcon"></i>
                        </button>
                    </div>
                </div>
                <div class="form-group" style="margin-top: 1rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="preserveTagDataOnRemove" checked>
                        Preserve existing tag data
                    </label>
                    <small style="color: var(--text-secondary);">If unchecked, tag data will be erased along with password</small>
                </div>
                <div id="removePasswordError" style="color: var(--danger-color); font-size: 0.875rem; margin-top: 0.5rem; display: none;"></div>
                <div id="removePasswordStatus" class="write-status" style="display: none; margin-top: 1rem;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeRemovePasswordModal()">Cancel</button>
                <button class="btn btn-success" id="removePasswordBtn" onclick="executeRemovePassword()"><i class="fas fa-unlock"></i> Remove Password</button>
            </div>
        </div>
    </div>
</body>
</html>
