<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fuel Storage Status - Dreamex Datalab HSE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for analytics charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        /* CSS Variables */
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --text-color: #333;
            --bg-color: #f5f6fa;
            --sidebar-width: 250px;
            --blue: #3498db;
            --green: #2ecc71;
            --purple: #9b59b6;
            --orange: #e67e22;
            --red: #e74c3c;
            --accent-color: var(--blue);
            --font-family: 'Inter', system-ui, -apple-system, sans-serif;
            --base-font-size: 0.9rem;
            --font-scale: 1;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --spacing-unit: 1rem;
            --padding-sm: 0.5rem;
            --padding-md: 1rem;
            --padding-lg: 1.5rem;
            --transition-speed: 0.2s;
        }

        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
        }

        body {
            font-family: var(--font-family);
            font-size: var(--base-font-size);
            line-height: calc(1.5 * var(--font-scale));
            color: var(--text-primary);
            background-color: var(--bg-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Sidebar Styles */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--primary-color);
            color: white;
            padding: 1rem;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .logo h2 {
            text-align: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .menu {
            list-style: none;
            margin-top: 2rem;
        }

        .menu li {
            margin-bottom: 0.5rem;
        }

        .menu a {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .menu a i {
            margin-right: 10px;
        }

        .menu a:hover, .menu a.active {
            background-color: var(--secondary-color);
        }

        .menu-dropdown .submenu {
            display: none;
            list-style: none;
            margin-left: 2rem;
            margin-top: 0.5rem;
        }

        .menu-dropdown:hover .submenu {
            display: block;
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 0.5rem;
            padding-top: 5rem;
            width: calc(100% - var(--sidebar-width));
            box-sizing: border-box;
            overflow-x: hidden;
            max-width: calc(100vw - var(--sidebar-width));
        }

        .top-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            position: fixed;
            top: 0.5rem;
            right: 0.5rem;
            left: calc(var(--sidebar-width) + 0.5rem);
            z-index: 100;
        }

        .top-nav-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .sidebar-toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1.2rem;
            padding: 0.5rem;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .sidebar-toggle-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .header-company-logo {
            height: 35px;
            width: auto;
            max-width: 140px;
            border-radius: 4px;
            object-fit: contain;
            display: none;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .header-company-logo.visible {
            display: block;
        }

        .header-logo-placeholder {
            width: 35px;
            height: 35px;
            border-radius: 4px;
            background: #f8f9fa;
            border: 2px dashed #ced4da;
            display: none;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-size: 1rem;
        }

        .company-name-header {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 1rem;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .top-nav-right {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-left: auto;
        }

        /* Notification Styles */
        .notifications {
            position: relative;
            display: flex;
            align-items: center;
        }

        .notification-btn {
            background: none;
            border: none;
            cursor: pointer;
            position: relative;
            font-size: 1.2rem;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--accent-color);
            color: white;
            border-radius: 50%;
            padding: 0.2rem 0.5rem;
            font-size: 0.7rem;
        }

        .notification-dropdown {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            width: 300px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .notification-dropdown.show {
            display: block;
        }

        .notification-header {
            padding: 1rem;
            border-bottom: 1px solid #ddd;
        }

        .notification-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .mark-all-read {
            background: none;
            border: none;
            color: var(--secondary-color);
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mark-all-read:hover {
            background: #f8f9fa;
        }

        .notification-list {
            max-height: 300px;
            overflow-y: auto;
        }

        /* User Profile Styles */
        .user-profile {
            position: relative;
            display: flex;
            align-items: center;
        }

        .profile-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .profile-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: scale(1.05);
        }

        .profile-btn img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: border-color 0.2s ease;
        }

        .profile-btn:hover img {
            border-color: rgba(52, 152, 219, 0.5);
        }

        .profile-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            min-width: 200px;
            z-index: 1000;
        }

        .profile-dropdown.show {
            display: block;
        }

        .profile-dropdown ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .profile-dropdown ul li a {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #333;
            text-decoration: none;
            transition: background-color 0.2s;
        }

        .profile-dropdown ul li a:hover {
            background-color: #f8f9fa;
        }

        .profile-dropdown ul li a i {
            margin-right: 10px;
            width: 16px;
            color: #666;
        }

        /* Content Styles */
        .content {
            margin-top: 1rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 18px 24px;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            border-radius: 12px;
            color: white;
        }

        .content-header h1 {
            margin: 0;
            color: white;
            font-size: 1.6rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        

        /* Slim page header (match project-list style) */
        .page-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: #fff;
            padding: 0.35rem 0.6rem; /* reduced height */
            border-radius: 0;
            margin: 0.35rem 0 0.5rem 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 10px 28px rgba(0,0,0,0.18), 0 6px 16px rgba(0,0,0,0.14);
            font-size: 0.85rem; /* slightly smaller */
        }

        .header-main {
            display: flex;
            align-items: center;
            gap: 0.45rem; /* tighter spacing */
        }

        .page-header h1 {
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem; /* reduced font size */
            margin: 0;
            font-weight: 600;
        }

        .page-header i { font-size: 0.9rem; }

        .page-actions { display: flex; gap: 0.5rem; }

        /* Button Styles */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-create {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 3px 12px rgba(16, 185, 129, 0.25);
        }

        .btn-create:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .btn-create i {
            font-size: 1rem;
            transition: transform 0.3s ease;
        }

        .btn-create:hover i {
            transform: rotate(90deg);
        }

        /* Icon-only button (no background) for header action */
        .btn-icon {
            background: transparent !important;
            color: #fff;
            box-shadow: none;
            padding: 0.4rem;
            border-radius: 50%;
        }

        .btn-icon:hover {
            background: transparent;
            transform: none;
            box-shadow: none;
        }

        .btn-icon i {
            font-size: 1rem;
            transition: transform 0.3s ease;
        }

        .btn-icon:hover i {
            transform: rotate(90deg);
        }

        /* Table Styles (aligned with fueldist compact employees table) */
        .table-container {
            background:#fff;
            border:1px solid var(--line, #e2e8f0);
            border-radius:10px;
            box-shadow:0 2px 8px rgba(0,0,0,0.06);
            overflow:hidden;
            margin-top:14px;
        }
        /* Utility hidden column */
        .hidden-col { display:none !important; }
        .data-table { width:100%; border-collapse:collapse; font-size:.72rem; min-width:900px; }
        .data-table th { background:#f1f5f9; padding:6px 8px; font-size:.65rem; font-weight:600; color:#475569; border-bottom:1px solid var(--line, #e2e8f0); text-align:left; white-space:nowrap; }
        .data-table td { padding:6px 8px; font-size:.7rem; color:#334155; border-bottom:1px solid var(--line, #e2e8f0); vertical-align:middle; }
        .data-table tbody tr { transition:background .15s; }
        .data-table tbody tr:hover { background:#f8fafc; cursor:pointer; box-shadow:none; transform:none; }
        
        /* Column Filter Styles */
        .filter-container {
            margin-top: 6px;
            width: 100%;
        }
        
        .column-filter {
            width: 100%;
            padding: 4px 6px;
            font-size: 0.6rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            color: #374151;
            transition: all 0.2s ease;
        }
        
        .column-filter:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.1);
        }
        
        .column-filter::placeholder {
            color: #9ca3af;
            font-size: 0.58rem;
        }
        
        /* Make filter inputs smaller for better fit */
        .column-filter[type="number"],
        .column-filter[type="date"] {
            font-size: 0.58rem;
        }
        
        .status-badge { display:inline-block; padding:2px 6px; border-radius:12px; font-size:.6rem; font-weight:600; letter-spacing:.5px; }
        
        .equipment-info {
            font-size: 0.9em;
            line-height: 1.3;
        }
        
        .equipment-info strong {
            color: #374151;
        }
        
        .quantity-badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .quantity-cell {
            text-align: center;
        }

        .status-normal {
            background: #d4edda;
            color: #155724;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
        }

        .status-critical {
            background: #f8d7da;
            color: #721c24;
        }

        .status-full {
            background: #cce5ff;
            color: #004085;
        }

        /* Progress Bar Styles */
        .progress-bar { width:100%; height:16px; background-color:#e9ecef; border-radius:8px; overflow:hidden; position:relative; }

        .progress-fill { height:100%; transition:width 0.3s ease; display:flex; align-items:center; justify-content:center; font-size:.55rem; font-weight:600; color:#fff; text-shadow:1px 1px 2px rgba(0,0,0,0.25); }

        .progress-normal {
            background: linear-gradient(90deg, #10b981, #059669);
        }

        .progress-warning {
            background: linear-gradient(90deg, #f59e0b, #d97706);
        }

        .progress-critical {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }

        .progress-full {
            background: linear-gradient(90deg, #3b82f6, #2563eb);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 15px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            max-width: 600px;
            width: 95%;
            max-height: 95vh;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 15px 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 25px 30px;
            max-height: calc(95vh - 160px);
            overflow-y: auto;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            font-weight: 500;
            color: #374151;
            font-size: 0.85rem;
        }

        .required-field::after {
            content: '*';
            color: #ef4444;
            margin-left: 4px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
            background: white;
        }

        .form-hint {
            font-size: 0.75rem;
            color: #64748b;
            font-style: italic;
        }

        .calculated-field {
            background: #f0f9ff !important;
            color: #0369a1;
            font-weight: 600;
            cursor: not-allowed;
        }

        .modal-footer {
            padding: 15px 18px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-footer .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85rem;
        }

        .modal-footer .btn:not(.btn-create) {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }

        .modal-footer .btn:not(.btn-create):hover {
            background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
            transform: translateY(-1px);
        }

        /* Menu Visibility Styles */
        [data-feature]:not(.menu-visible) {
            display: none !important;
        }

        .menu-dropdown:not(.menu-visible) {
            display: none !important;
        }

        /* Hide ALL menu items by default during loading */
        .sidebar.menu-loading .menu-item,
        .sidebar.menu-loading .menu-dropdown,
        .sidebar.menu-loading li[data-feature],
        .sidebar.menu-loading [data-feature] {
            display: none !important;
        }

        /* Allow menu-visible items to show even during loading */
        .sidebar.menu-loading .menu-visible,
        .sidebar.menu-loading li.menu-visible,
        .sidebar.menu-loading [data-feature].menu-visible {
            display: block !important;
        }

        .menu-loading [data-feature] {
            display: none !important;
        }

        .menu-loading .menu-dropdown {
            display: none !important;
        }

        /* Ensure menu-visible items are always shown */
        .menu-visible {
            display: block !important;
        }

        li.menu-visible,
        [data-feature].menu-visible {
            display: block !important;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: relative;
                height: auto;
            }
            
            .main-content {
                margin-left: 0;
                width: 100%;
                max-width: 100vw;
                padding-top: 5rem;
            }
            
            .top-nav {
                left: 0.5rem;
                right: 0.5rem;
                padding: 0.75rem 1rem;
            }
            
            .content-header {
                flex-direction: column;
                gap: 12px;
                align-items: stretch;
                padding: 15px 18px;
            }
            
            .content-header h1 {
                font-size: 1.4rem;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .modal-content {
                width: 98%;
                max-width: none;
                margin: 10px;
            }
            
            .modal-body {
                padding: 20px;
            }
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #64748b;
        }

        .empty-state i {
            font-size: 3rem;
            color: #cbd5e1;
            margin-bottom: 15px;
        }

        .empty-state h3 {
            margin: 0 0 8px 0;
            color: #374151;
        }

        .empty-state p {
            margin: 0;
            font-size: 0.9rem;
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            border-bottom: 2px solid #e5e7eb;
            gap: 2px;
            margin-bottom: 1rem;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-btn:hover {
            color: var(--secondary-color);
            background-color: #f3f4f6;
        }

        .tab-btn.active {
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
            background-color: rgba(52, 152, 219, 0.05);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Table controls for details tab */
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
        }

        .table-header h3 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .table-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .refresh-btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background-color 0.2s ease;
        }

        .refresh-btn:hover {
            background: #2980b9;
        }
    </style>

    <!-- Firebase v8 CDN for compatibility -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    
    <!-- Centralized Authentication System (Module imports) -->
    <script type="module" src="js/firebase-config-v8.js"></script>
    <script type="module" src="js/company-data-service.js"></script>
    <script type="module" src="js/auth.js"></script>
    
    <!-- Module Integration Script -->
    <script type="module">
        // Initialize the centralized authentication system
        import AuthManager from './js/auth.js';
        import companyDataService from './js/company-data-service.js';
        
        // Make auth manager available globally for backward compatibility
        window.authManager = new AuthManager();
        window.companyDataService = companyDataService;
        
        // Expose Firebase for direct use if needed
        import { getDatabase, ref, get, set, update, remove } from './js/firebase-config-v8.js';
        window.getDatabase = getDatabase;
        window.ref = ref;
        window.get = get;
        window.set = set;
        window.update = update;
        window.remove = remove;
    </script>
    
    <!-- Immediate Firebase initialization for backward compatibility -->
    <script>
        // Firebase v8 configuration for immediate availability
        const firebaseConfig = {
            apiKey: "AIzaSyCUTmTn0rRBb0M-UkQJxnUMrWqXYU_BgIc",
            authDomain: "users-8be65.firebaseapp.com",
            databaseURL: "https://users-8be65-default-rtdb.firebaseio.com",
            projectId: "users-8be65",
            storageBucket: "users-8be65.firebasestorage.app",
            messagingSenderId: "909025468149",
            appId: "1:909025468149:web:fb4e7c4a8b4bd6d1076e4d",
            measurementId: "G-XHFMRCJQEZ"
        };

        // Initialize Firebase v8 immediately for direct access
        if (!window.firebase || !window.firebase.apps || window.firebase.apps.length === 0) {
            window.firebase.initializeApp(firebaseConfig);
            console.log('âœ… Firebase v8 initialized immediately for fuel storage page');
        }
    </script>
    <!-- Page will use centralized AuthManager from js/auth.js -->
    
    <!-- Initialize page after auth system loads -->
    <script>
        // AuthManager fallback implementation
        class FallbackAuthManager {
            constructor() {
                this.currentUser = this.getCurrentUser();
                this.initializeAuth();
            }

            getCurrentUser() {
                try {
                    const user = localStorage.getItem('currentUser');
                    return user ? JSON.parse(user) : null;
                } catch (error) {
                    console.error('Error parsing currentUser from localStorage:', error);
                    return null;
                }
            }

            initializeAuth() {
                if (window.location.pathname.includes('login.html')) {
                    return;
                } else {
                    if (!this.currentUser) {
                        window.location.href = 'login.html';
                        return;
                    }
                    this.updateUIForAuthenticatedUser();
                }
            }

            async updateUIForAuthenticatedUser() {
                const profileBtn = document.querySelector('#userProfileBtn');
                const profileDropdown = document.querySelector('.profile-dropdown');
                
                if (profileBtn && profileDropdown && this.currentUser) {
                    const displayName = this.getUserDisplayName();
                    const email = this.getUserEmail();
                    const initials = this.getUserInitials();
                    
                    // Get avatar URL
                    const avatarUrl = await this.getUserAvatarUrl();
                    
                    // Update profile image
                    const profileImg = profileBtn.querySelector('img');
                    if (profileImg) {
                        if (avatarUrl) {
                            profileImg.src = avatarUrl;
                            profileImg.alt = displayName + ' Avatar';
                            console.log('âœ… Profile image updated with avatar URL');
                        } else {
                            // Generate initials avatar
                            this.generateInitialsAvatar(displayName, profileImg);
                            console.log('ðŸ”¤ Profile image updated with initials');
                        }
                    }
                    
                    // Create avatar for dropdown
                    let dropdownAvatarHtml;
                    if (avatarUrl) {
                        dropdownAvatarHtml = `<img src="${avatarUrl}" alt="${displayName} Avatar" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover;">`;
                    } else {
                        dropdownAvatarHtml = `<div style="width: 32px; height: 32px; border-radius: 50%; background: #3498db; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 12px;">${initials}</div>`;
                    }
                    
                    const userInfoHtml = `
                        <li style="border-bottom: 1px solid #eee; padding: 12px 16px; background: #f8f9fa;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                ${dropdownAvatarHtml}
                                <div>
                                    <div style="font-weight: 600; color: #333; font-size: 14px; margin-bottom: 2px;">
                                        ${displayName}
                                    </div>
                                    <div style="color: #666; font-size: 12px;">
                                        ${email}
                                    </div>
                                </div>
                            </div>
                        </li>
                        <li><a href="account.html"><i class="fas fa-user"></i> Account Settings</a></li>
                        <li><a href="#" id="logoutLink"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
                    `;
                    
                    profileDropdown.innerHTML = userInfoHtml;
                    
                    const logoutBtn = document.getElementById('logoutLink');
                    if (logoutBtn) {
                        logoutBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.logout();
                        });
                    }
                }
            }

            generateInitialsAvatar(name, imgElement) {
                if (!imgElement || !name) return;
                
                const initials = this.getUserInitials();
                const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
                const backgroundColor = colors[name.length % colors.length];
                
                const svg = `
                    <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="20" cy="20" r="20" fill="${backgroundColor}"/>
                        <text x="20" y="25" text-anchor="middle" fill="white" font-size="14" font-weight="600" font-family="Arial, sans-serif">${initials}</text>
                    </svg>
                `;
                
                imgElement.src = 'data:image/svg+xml;base64,' + btoa(svg);
                imgElement.alt = name + ' Avatar';
            }

            getUserDisplayName() {
                if (!this.currentUser) return 'User';
                return this.currentUser.name || this.currentUser.displayName || 
                       (this.currentUser.firstName && this.currentUser.lastName 
                        ? this.currentUser.firstName + ' ' + this.currentUser.lastName 
                        : null) ||
                       this.currentUser.email?.split('@')[0] || 'User';
            }

            getUserInitials() {
                const displayName = this.getUserDisplayName();
                if (!displayName || displayName === 'User') return 'U';
                
                const words = displayName.split(' ').filter(word => word.length > 0);
                if (words.length === 1) {
                    return words[0].substring(0, 2).toUpperCase();
                } else {
                    return words.slice(0, 2).map(word => word.charAt(0)).join('').toUpperCase();
                }
            }

            getUserEmail() {
                return this.currentUser?.email || '';
            }

            async getUserAvatarUrl() {
                if (!this.currentUser) {
                    console.log('No current user for avatar URL');
                    return null;
                }
                
                try {
                    if (!window.firebase || !window.firebase.storage) {
                        console.log('Firebase Storage not available');
                        return null;
                    }
                    
                    const storage = window.firebase.storage();
                    const avatarPath = `avatars/${this.currentUser.uid}/profile.jpg`;
                    console.log('Attempting to get avatar from path:', avatarPath);
                    
                    const avatarRef = storage.ref(avatarPath);
                    const downloadURL = await avatarRef.getDownloadURL();
                    
                    console.log('âœ… Avatar URL retrieved successfully');
                    return downloadURL;
                } catch (error) {
                    console.log('Avatar not found or error occurred:', error.code || error.message);
                    return null;
                }
            }

            async logout() {
                try {
                    if (window.firebase && window.firebase.auth) {
                        await window.firebase.auth().signOut();
                    }
                    localStorage.removeItem('currentUser');
                    window.location.href = 'login.html';
                } catch (error) {
                    console.error('Logout error:', error);
                    localStorage.removeItem('currentUser');
                    window.location.href = 'login.html';
                }
            }
        }

        // Initialize authentication system
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                console.log('ðŸ”§ Fuel Storage page initializing with auth system...');
                
                // Try to use centralized AuthManager first, fallback to local implementation
                if (window.authManager) {
                    console.log('âœ… Using centralized AuthManager');
                } else {
                    console.log('ðŸ”„ Using fallback AuthManager');
                    window.authManager = new FallbackAuthManager();
                }
            }, 100);
        });
    </script>
</head>
<body>
    <div class="app-container">
        <!-- Left Sidebar -->
        <nav class="sidebar menu-loading">
            <div class="logo">
                <h2>Dreamex Datalab</h2>
            </div>
            <ul class="menu" id="roleBasedMenu">
                <li class="menu-item" data-feature="home_view" data-requires-permission="home_view">
                    <a href="index.html"><i class="fas fa-home"></i> Home</a>
                </li>
                <li class="menu-dropdown" data-feature="health_view" data-requires-permission="health_view">
                    <a href="#"><i class="fas fa-medkit"></i> Health</a>
                    <ul class="submenu">
                        <li data-feature="health_assessment_view" data-requires-permission="health_assessment_view">
                            <a href="health-assessment.html">Assessment</a>
                        </li>
                        <li data-feature="health_consultation_view" data-requires-permission="health_consultation_view">
                            <a href="health-consultation.html">Consultation</a>
                        </li>
                        <li data-feature="medical_folder_view" data-requires-permission="medical_folder_view">
                            <a href="medical-folder.html">Medical Folder</a>
                        </li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="safety_view" data-requires-permission="safety_view">
                    <a href="#"><i class="fas fa-shield-alt"></i> Safety</a>
                    <ul class="submenu">
                        <li data-feature="training_view" data-requires-permission="training_view"><a href="trainingboard.html">Training</a></li>
                        <li data-feature="jsa_view" data-requires-permission="jsa_view"><a href="jsaboard.html">Job Safety Analysis</a></li>
                        <li data-feature="ptw_view" data-requires-permission="ptw_view"><a href="ptwboard.html">Permit to Work</a></li>
                        <li data-feature="incident_view" data-requires-permission="incident_view"><a href="incidentboard.html">Incident Reports</a></li>
                        <li data-feature="inspection_view" data-requires-permission="inspection_view"><a href="inspectionboard.html">Inspection</a></li>
                        <li data-feature="audit_view" data-requires-permission="audit_view"><a href="auditboard.html">Audit</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="risk_view" data-requires-permission="risk_view">
                    <a href="#"><i class="fas fa-exclamation-triangle"></i> Risk Management</a>
                    <ul class="submenu">
                        <li data-feature="risk_view" data-requires-permission="risk_view"><a href="riskboard.html">Risk Management</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="investigation_view" data-requires-permission="investigation_view">
                    <a href="#"><i class="fas fa-search-plus"></i> Investigation</a>
                    <ul class="submenu">
                        <li data-feature="investigation_dashboard_view" data-requires-permission="investigation_dashboard_view"><a href="investigation-dashboard.html">Investigation Dashboard</a></li>
                        <li data-feature="investigation_list_view" data-requires-permission="investigation_list_view"><a href="investigation-list.html">Investigation List</a></li>
                        <li data-feature="create_investigation_view" data-requires-permission="create_investigation_view"><a href="investigation-create.html">Create Investigation</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="fuel_management" data-requires-permission="fuel_management">
                    <a href="#"><i class="fas fa-gas-pump"></i> Fuel Management</a>
                    <ul class="submenu">
                        <li data-feature="vessel_offloading" data-requires-permission="vessel_offloading"><a href="vessel-offloading.html">Vessel Offloading</a></li>
                        <li data-feature="fuel_storage" data-requires-permission="fuel_storage"><a href="fuelstor.html" class="active">Fuel Storage Status</a></li>
                        <li data-feature="tank_transfer" data-requires-permission="tank_transfer"><a href="fueltrans.html">Tank-to-Tank Transfer</a></li>
                        <li data-feature="truck_loading" data-requires-permission="truck_loading"><a href="fuel-truck-loading.html">Fuel Truck Loading</a></li>
                        <li data-feature="quality_analysis" data-requires-permission="quality_analysis"><a href="fuel-quality-analysis.html">Fuel Quality Analysis</a></li>
                        <li data-feature="fuel_distribution" data-requires-permission="fuel_distribution"><a href="fueldist.html">Fuel Distribution</a></li>
                        <li data-feature="fuel_consumption_analysis" data-requires-permission="fuel_consumption_analysis"><a href="fuelanalys.html">Consumption Analysis</a></li>
                        <li data-feature="fuel_daily_report" data-requires-permission="fuel_daily_report"><a href="fueldaily.html">Daily Fuel Report</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="environment_view">
                    <a href="#"><i class="fas fa-leaf"></i> Environment</a>
                    <ul class="submenu">
                        <li data-feature="water_view"><a href="waterboard.html">Water Quality</a></li>
                        <li data-feature="waste_view"><a href="wasteboard.html">Waste Management</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="security_view">
                    <a href="#"><i class="fas fa-lock"></i> Security</a>
                    <ul class="submenu">
                        <li data-feature="access_view" data-requires-permission="access_view"><a href="accessboard.html">Access Request</a></li>
                        <li data-feature="access_daily_view" data-requires-permission="access_daily_view"><a href="accessdaily.html">Daily Access Control</a></li>
                        <li data-feature="removal_view" data-requires-permission="removal_view"><a href="removalboard.html">Property Removal</a></li>
                    
						<li data-feature="security_level_evaluation_view" data-requires-permission="security_level_evaluation_view"><a href="seclevel.html">Security Level Evaluation</a></li></ul>
                </li>
                <li class="menu-dropdown" data-feature="project_management_section">
                    <a href="#"><i class="fas fa-project-diagram"></i> Project Management</a>
                    <ul class="submenu">
                        <li data-feature="project_dashboard_view" data-requires-permission="project_dashboard_view"><a href="project-dashboard.html">Project Dashboard</a></li>
                        <li data-feature="project_create_view" data-requires-permission="project_create_view"><a href="project-create.html">Create Project</a></li>
                        <li data-feature="project_list_view" data-requires-permission="project_list_view"><a href="project-list.html">Project List</a></li>
                        <li data-feature="project_reports_view" data-requires-permission="project_reports_view"><a href="project-reports.html">Project Reports</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="logistics_view" data-requires-permission="logistics_view">
                    <a href="#"><i class="fas fa-truck"></i> Logistics</a>
                    <ul class="submenu">
                        <li data-feature="fleet_view" data-requires-permission="fleet_view"><a href="fleet.html">Fleet Management</a></li>
                        <li data-feature="travel_view" data-requires-permission="travel_view"><a href="travel.html">Travel Requests</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="accommodation_view" data-requires-permission="accommodation_view">
                    <a href="#"><i class="fas fa-bed"></i> Accommodation</a>
                    <ul class="submenu">
                        <li data-feature="camp_view" data-requires-permission="camp_view"><a href="camp.html">Camp Management</a></li>
                        <li data-feature="camp_settings_view" data-requires-permission="camp_settings_view"><a href="campset.html">Camp Settings</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="hr_view" data-requires-permission="hr_view">
                    <a href="#"><i class="fas fa-users"></i> HR</a>
                    <ul class="submenu">
                        <li data-feature="human_hr_view" data-requires-permission="human_hr_view"><a href="human-hr.html"><i class="fas fa-user-tie"></i> Human HR</a></li>
                        <li data-feature="staff_management_view" data-requires-permission="staff_management_view"><a href="staff.html">Staffing</a></li>
                        <li data-feature="authority_to_recruit_view" data-requires-permission="authority_to_recruit_view"><a href="recruit.html">Authority to Recruit</a></li>
                        <li data-feature="job_advertising_view" data-requires-permission="job_advertising_view"><a href="jobpost.html">Job Advertising</a></li>
                        <li data-feature="screening_view" data-requires-permission="screening_view"><a href="jobscreen.html">Screening</a></li>
                        <li data-feature="interview_view" data-requires-permission="interview_view"><a href="interview.html">Interview</a></li>
                        <li data-feature="offer_view" data-requires-permission="offer_view"><a href="offer.html">Offer Management</a></li>
                        <li data-feature="contract_view" data-requires-permission="contract_view"><a href="contract.html">Contract Management</a></li>
                        <li data-feature="salary_management_view" data-requires-permission="salary_management_view"><a href="salary.html">Salary Management</a></li>
                        <li data-feature="onboarding_view" data-requires-permission="onboarding_view"><a href="onboard.html">Onboarding</a></li>
                        <li data-feature="chart_view" data-requires-permission="chart_view"><a href="chart.html">Chart Setup</a></li>
                        <li data-feature="chartboard_view" data-requires-permission="chartboard_view"><a href="chartboard.html">Org Chart</a></li>
                        <li data-feature="kpi_dashboard_view" data-requires-permission="kpi_dashboard_view"><a href="kpi.html">KPI</a></li>
                        <li data-feature="payroll_view" data-requires-permission="payroll_view"><a href="payroll.html">Payroll</a></li>
                    </ul>
                </li>
                <!-- Inventory Management as section button with submenu -->
                <li class="menu-dropdown" data-feature="inventory_view" data-requires-permission="inventory_view">
                    <a href="#"><i class="fas fa-boxes"></i> Inventory Management</a>
                    <ul class="submenu">
                        <li data-feature="inventory_dashboard_view" data-requires-permission="inventory_dashboard_view"><a href="inventory-dashboard.html"><i class="fas fa-tachometer-alt"></i> Inventory Dashboard</a></li>
                        <li data-feature="inventory_items_view" data-requires-permission="inventory_items_view"><a href="inventory-items.html"><i class="fas fa-cubes"></i> Items Management</a></li>
                        <li data-feature="inventory_warehouses_view" data-requires-permission="inventory_warehouses_view"><a href="inventory-warehouses.html"><i class="fas fa-warehouse"></i> Warehouses</a></li>
                        <li data-feature="inventory_reservations_view" data-requires-permission="inventory_reservations_view"><a href="inventory-reservations.html"><i class="fas fa-bookmark"></i> Material Reservations</a></li>
                        <li data-feature="inventory_approvals_view" data-requires-permission="inventory_approvals_view"><a href="inventory-approvals.html"><i class="fas fa-check-circle"></i> Approvals</a></li>
                        <li data-feature="inventory_issue_view" data-requires-permission="inventory_issue_view"><a href="inventory-issue.html"><i class="fas fa-shipping-fast"></i> Material Issue</a></li>
                    </ul>
                </li>
                <li data-feature="communication_view"><a href="info.html"><i class="fas fa-comments"></i> Communication</a></li>
                <li class="menu-dropdown" data-feature="settings_view">
                    <a href="#"><i class="fas fa-cog"></i> Settings</a>
                    <ul class="submenu">
                        <li data-feature="account_settings_view" data-requires-permission="account_settings_view"><a href="account.html">Account Settings</a></li>
                        <li data-feature="company_management_view" data-requires-permission="company_management_view"><a href="companymanagement.html">Company Management</a></li>
                        <li data-feature="approval_settings_view" data-requires-permission="approval_settings_view"><a href="approval-settings.html">Approval Flow Settings</a></li>
                        <li data-feature="field_setup_view" data-requires-permission="field_setup_view"><a href="fieldsetup.html">Field Setup</a></li>
                        <li data-feature="preferences_view" data-requires-permission="preferences_view"><a href="preferences.html">Preferences</a></li>
                        <li data-feature="notification_settings_view" data-requires-permission="notification_settings_view"><a href="notification-settings.html">Notification Settings</a></li>
                        <li data-feature="audit_log_view" data-requires-permission="audit_log_view"><a href="auditlog.html"><i class="fas fa-history"></i> Audit Log</a></li>
                        <li data-feature="user_management_view" data-requires-permission="user_management_view"><a href="users.html">User & Role Management</a></li>
                        <li data-feature="role_permissions_view" data-requires-permission="role_permissions_view"><a href="roles.html">Role Permissions</a></li>
                    </ul>
                </li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Top Navigation -->
            <header class="top-nav">
                <div class="top-nav-left">
                    <button id="sidebarToggle" class="sidebar-toggle-btn">
                        <i class="fas fa-bars"></i>
                    </button>
                    <img id="headerCompanyLogo" class="header-company-logo" src="" alt="Company Logo">
                    <div id="headerLogoPlaceholder" class="header-logo-placeholder">
                        <i class="fas fa-building"></i>
                    </div>
                    <span id="headerCompanyName" class="company-name-header"></span>
                </div>
                <div class="top-nav-right">
                    <div class="notifications">
                        <button id="notificationBtn" class="notification-btn">
                            <i class="fas fa-bell"></i>
                            <span class="notification-badge">0</span>
                        </button>
                        <div class="notification-dropdown">
                            <div class="notification-header">
                                <h3>Notifications</h3>
                                <button class="mark-all-read">Mark all as read</button>
                            </div>
                            <div class="notification-list">
                                <!-- Notifications will be dynamically added here -->
                            </div>
                        </div>
                    </div>
                    <div class="user-profile">
                        <button id="userProfileBtn" class="profile-btn">
                            <img id="userAvatar" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiMzNDk4ZGIiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSI+CjxwYXRoIGQ9Ik0yMCAyMXYtMmE0IDQgMCAwIDAtNC00SDhhNCA0IDAgMCAwLTQgNHYyIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8Y2lyY2xlIGN4PSIxMiIgY3k9IjciIHI9IjQiIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo8L3N2Zz4K" alt="User Avatar">
                        </button>
                        <div class="profile-dropdown">
                            <ul>
                                <li><a href="account.html"><i class="fas fa-user"></i> Account Settings</a></li>
                                <li><a href="#"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Page Content -->
            <div class="content">
                <div class="page-header">
                    <div class="header-main">
                        <h1><i class="fas fa-gas-pump"></i> Fuel Storage Status</h1>
                    </div>
                    <div class="page-actions">
                        <button id="updateVolumesBtn" class="btn btn-icon" aria-label="Update Volumes Based on Consumption" title="Update Volumes Based on Consumption">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button id="createTankBtn" class="btn btn-icon" aria-label="Add Tank Status" title="Add Tank Status">
                            <i class="fas fa-plus"></i>
                        </button>
                        <button id="deleteSelectedBtn" class="btn" aria-label="Delete Selected" title="Delete Selected" disabled>
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>

                <!-- Tab Navigation -->
                <div class="tab-navigation" style="margin-bottom: 1rem;">
                    <button class="tab-btn active" onclick="switchTab('storage')" data-tab="storage">
                        <i class="fas fa-gas-pump"></i> Storage Status
                    </button>
                    <button class="tab-btn" onclick="switchTab('details')" data-tab="details">
                        <i class="fas fa-chart-line"></i> Distribution Details
                    </button>
                    <button class="tab-btn" onclick="switchTab('analytics')" data-tab="analytics">
                        <i class="fas fa-chart-area"></i> Analytics
                    </button>
                </div>

                <!-- Storage Status Tab -->
                <div id="storageTab" class="tab-content active">
                    <div class="filter-controls" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button type="button" onclick="clearAllFilters()" class="btn-secondary" style="padding: 6px 12px; font-size: 0.8rem;">
                                <i class="fas fa-filter"></i> Clear All Filters
                            </button>
                            <span id="filterStatus" style="font-size: 0.75rem; color: #6b7280;"></span>
                        </div>
                    </div>
                    <div class="table-container">
                        <div style="overflow-x: auto;">
                            <table class="data-table" id="storageTable">
                                <thead>
                                    <tr>
                                        <th style="width:32px; text-align:center;">
                                            <input type="checkbox" id="selectAllTanks" aria-label="Select All" />
                                        </th>
                                        <th>
                                            Tank ID
                                            <div class="filter-container">
                                                <select class="column-filter" data-column="1" id="tankIdFilter">
                                                    <option value="">All Tanks</option>
                                                </select>
                                            </div>
                                        </th>
                                        <th class="hidden-col">Fuel Type</th>
                                        <th class="hidden-col">
                                            Max Volume (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="3" placeholder="Min volume..." />
                                            </div>
                                        </th>
                                        <th title="Opening stock recorded at the start of the day">
                                            Opening Stock (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="4" placeholder="Min stock..." />
                                            </div>
                                        </th>
                                        <th title="Total distributions deducted in closing stock calculation (previous day relative to stock date)">
                                            Distribution (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="5" placeholder="Min dist..." />
                                            </div>
                                        </th>
                                        <th title="Closing stock after all distributions/transfers">
                                            Closing Stock (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="6" placeholder="Min stock..." />
                                            </div>
                                        </th>
                                        <th title="Manual measured stock at end of day">
                                            Physical Stock (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="7" placeholder="Min stock..." />
                                            </div>
                                        </th>
                                        <th title="Variance = Closing Stock - Physical Stock">
                                            Variance (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="8" placeholder="Min variance..." />
                                            </div>
                                        </th>
                                        <th>
                                            Capacity
                                            <div class="filter-container">
                                                <input type="text" class="column-filter" data-column="9" placeholder="Filter capacity..." />
                                            </div>
                                        </th>
                                        <th>
                                            Stock Date
                                            <div class="filter-container">
                                                <input type="date" class="column-filter" data-column="10" />
                                            </div>
                                        </th>
                                        <th class="hidden-col">
                                            Ullage (L)
                                            <div class="filter-container">
                                                <input type="number" class="column-filter" data-column="11" placeholder="Min ullage..." />
                                            </div>
                                        </th>
                                        <th class="hidden-col">Status</th>
                                        <th>
                                            Last Update
                                            <div class="filter-container">
                                                <input type="date" class="column-filter" data-column="13" />
                                            </div>
                                        </th>
                                        <th class="hidden-col">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="storageTableBody">
                                    <!-- Dynamic content will be loaded here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Empty State -->
                    <div class="empty-state" id="storageEmptyState" style="display: none;">
                        <i class="fas fa-oil-can"></i>
                        <h3>No Tank Records</h3>
                        <p>Start by adding fuel tank status information.</p>
                    </div>
                </div>

                <!-- Distribution Details Tab -->
                <div id="detailsTab" class="tab-content" style="display: none;">
                    <!-- Summary View -->
                    <div id="distributionSummaryView">
                        <div class="table-container">
                            <div class="table-header">
                                <div class="table-controls">
                                    <select id="detailsDateFilter" onchange="loadDistributionDetails()">
                                        <option value="7">Last 7 days</option>
                                        <option value="30">Last 30 days</option>
                                        <option value="90">Last 90 days</option>
                                        <option value="365">Last 365 days</option>
                                    </select>
                                </div>
                            </div>
                            <div style="overflow-x: auto;">
                                <table class="data-table" id="distributionDetailsTable">
                                    <thead>
                                        <tr>
                                            <th>Tank ID</th>
                                            <th>Total Distributions</th>
                                            <th>Total Volume (L)</th>
                                            <th>Last Distribution</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="distributionDetailsBody">
                                        <!-- Distribution details will be loaded here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- Details Empty State -->
                        <div class="empty-state" id="detailsEmptyState" style="display: none;">
                            <i class="fas fa-chart-line"></i>
                            <h3>No Distribution Data</h3>
                            <p>No fuel distributions found for the selected period.</p>
                        </div>
                    </div>

                    <!-- Specific Tank Distributions View -->
                    <div id="tankDistributionsView" style="display: none;">
                        <div class="table-container">
                            <div class="table-header">
                                <div class="table-controls">
                                    <button class="refresh-btn" onclick="showDistributionSummary()" style="background: #6b7280;">
                                        <i class="fas fa-arrow-left"></i> Back to Summary
                                    </button>
                                    <select id="tankDetailsDateFilter" onchange="refreshTankDistributions()">
                                        <option value="7">Last 7 days</option>
                                        <option value="30">Last 30 days</option>
                                        <option value="90">Last 90 days</option>
                                        <option value="365">Last 365 days</option>
                                        <option value="all">All</option>
                                    </select>
                                </div>
                            </div>
                            <div style="overflow-x: auto;">
                                <table class="data-table" id="tankDistributionsTable">
                                    <thead>
                                        <tr>
                                            <th class="hidden-col">Distribution ID</th>
                                            <th>Date & Time</th>
                                            <th>Equipment</th>
                                            <th class="hidden-col">Operator</th>
                                            <th>Quantity (L)</th>
                                            <th>Stock After (L)</th>
                                            <th>Transfer</th>
                                            <th>Index Reading</th>
                                            <th class="hidden-col">Requested By</th>
                                            <th>Department</th>
                                            <th class="hidden-col">Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tankDistributionsBody">
                                        <!-- Tank-specific distributions will be loaded here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- Tank Distributions Empty State -->
                        <div class="empty-state" id="tankDistributionsEmptyState" style="display: none;">
                            <i class="fas fa-gas-pump"></i>
                            <h3 id="tankEmptyTitle">No Distributions Found</h3>
                            <p id="tankEmptyMessage">No fuel distributions found for this tank in the selected period.</p>
                        </div>
                    </div>
                </div>

                <!-- Analytics Tab -->
                <div id="analyticsTab" class="tab-content" style="display:none;">
                    <div class="table-container" style="padding:12px;">
                        <div class="table-header" style="border-bottom:none; display:flex; align-items:center; justify-content:space-between; gap:8px;">
                            <div style="display:flex; align-items:center; gap:6px;">
                                <button class="tab-btn active" data-an-tab="charts" type="button"><i class="fas fa-chart-area"></i> Charts</button>
                                <button class="tab-btn" data-an-tab="pivot" type="button"><i class="fas fa-table"></i> Pivot</button>
                            </div>
                            <div id="anKpiTotal" style="font-size:0.8rem; color:#475569; font-weight:600; display:none;"></div>
                        </div>

                        <!-- Charts Panel -->
                        <div id="anChartsPanel" class="tab-content" style="display:block;">
                            <div style="display:grid; grid-template-columns: 320px 1fr; gap:16px; align-items:flex-start;">
                                <!-- Options/Filters -->
                                <div style="min-width:300px; max-width:320px; flex:0 0 300px;">
                                    <div style="font-weight:600; color:#334155; margin-bottom:8px;">Chart Options</div>
                                    <div class="pivot-card" style="padding:10px;">
                                        <div class="pivot-section-title">Time Granularity & Date Range</div>
                                        <div style="margin-bottom:8px; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                            <div>
                                                <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Start Date</label>
                                                <input id="anStart" type="date" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px;" />
                                            </div>
                                            <div>
                                                <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">End Date</label>
                                                <input id="anEnd" type="date" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px;" />
                                            </div>
                                        </div>
                                        <div style="margin-bottom:12px;">
                                            <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Granularity</label>
                                            <select id="anGranularity" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px;">
                                                <option value="day">Daily</option>
                                                <option value="week">Weekly</option>
                                                <option value="month">Monthly</option>
                                            </select>
                                        </div>
                                        <div style="margin-bottom:12px;">
                                            <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Chart Type</label>
                                            <select id="anChartType" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px;">
                                                <option value="line">Line</option>
                                                <option value="area">Area</option>
                                                <option value="bar">Bar</option>
                                                <option value="stackedBar">Stacked Bar</option>
                                                <option value="stackedArea">Stacked Area</option>
                                                <option value="pie">Pie</option>
                                                <option value="doughnut">Doughnut</option>
                                            </select>
                                        </div>
                                        <div class="pivot-section-title">Display</div>
                                        <div style="margin-bottom:8px;">
                                            <label for="anSeriesPicker" style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Show Series</label>
                                            <select id="anSeriesPicker" multiple size="5" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px; min-height:120px;"></select>
                                            <div style="font-size:0.72rem; color:#94a3b8; margin-top:4px;">Tip: Hold Ctrl (Windows) to select multiple series.</div>
                                        </div>
                                        <div style="margin-bottom:12px;">
                                            <label for="anCategoryPicker" style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Show Categories</label>
                                            <select id="anCategoryPicker" multiple size="6" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px; min-height:140px;"></select>
                                            <div style="font-size:0.72rem; color:#94a3b8; margin-top:4px;">Filters which x-axis labels are displayed (dates or categories).</div>
                                        </div>
                                        <div class="pivot-section-title">Export</div>
                                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                                            <button class="refresh-btn" id="anExportChartCsvBtn" type="button" style="background:#16a34a;"><i class="fas fa-file-csv"></i> Export CSV</button>
                                            <button class="refresh-btn" id="anExportChartPngBtn" type="button" style="background:#0ea5e9;"><i class="fas fa-image"></i> Export PNG</button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Chart Area -->
                                <div style="flex:1; min-height:420px; display:flex; flex-direction:column; gap:10px;">
                                    <!-- Chart Builder (Filters / Columns / Rows / Values) -->
                                    <style>
                                        .chart-drop { min-height:38px; padding:6px; border:1px dashed #cbd5e1; border-radius:6px; background:#fff; display:flex; flex-wrap:wrap; gap:6px; }
                                    </style>
                                    <div class="pivot-card" style="padding:10px; background:#f8fafc;">
                                        <div style="display:grid; grid-template-columns: repeat(5, 1fr); gap:12px;">
                                            <div>
                                                <div class="pivot-section-title">Filters</div>
                                                <div id="chartDropFilters" class="chart-drop"></div>
                                                <select id="chartAddFilter" class="tiny-btn" style="width:100%; margin-top:6px;"></select>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Columns</div>
                                                <div id="chartDropColumns" class="chart-drop"></div>
                                                <select id="chartAddColumn" class="tiny-btn" style="width:100%; margin-top:6px;"></select>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Categories</div>
                                                <div id="chartDropCategories" class="chart-drop"></div>
                                                <select id="chartAddCategory" class="tiny-btn" style="width:100%; margin-top:6px;"></select>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Rows</div>
                                                <div id="chartDropRows" class="chart-drop"></div>
                                                <select id="chartAddRow" class="tiny-btn" style="width:100%; margin-top:6px;"></select>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Values</div>
                                                <div id="chartDropValues" class="chart-drop"></div>
                                                <select id="chartAddValue" class="tiny-btn" style="width:100%; margin-top:6px;"></select>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="pivot-card" style="padding:8px; min-height:380px; background:#fff;">
                                        <canvas id="consumptionChart" style="width:100%; height:360px;"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Pivot Panel -->
                        <div id="anPivotPanel" class="tab-content" style="display:none;">
                            <style>
                                .pivot-card { border:1px solid #e2e8f0; border-radius:8px; background:#f8fafc; }
                                .pivot-section-title { color:#475569; font-weight:600; margin:8px 0 6px; }
                                .pivot-field { display:flex; align-items:center; gap:6px; padding:6px 8px; margin:4px 0; background:#fff; border:1px solid #e2e8f0; border-radius:6px; cursor:grab; }
                                .pivot-drop { min-height:38px; padding:6px; border:1px dashed #cbd5e1; border-radius:6px; background:#fff; display:flex; flex-wrap:wrap; gap:6px; }
                                .pivot-chip { display:flex; align-items:center; gap:6px; padding:4px 8px; background:#e2e8f0; color:#334155; border-radius:999px; }
                                .pivot-chip button { border:none; background:transparent; cursor:pointer; color:#475569; }
                                .value-chip { background:#dbeafe; }
                                .pivot-actions { display:flex; gap:8px; margin-top:10px; }
                                .tiny-btn { padding:2px 6px; border:1px solid #94a3b8; border-radius:4px; font-size:.75rem; color:#334155; background:#fff; cursor:pointer; }
                            </style>
                            <div style="display:flex; gap:16px; align-items:flex-start;">
                                <!-- Pivot Options (left side) -->
                                <div style="min-width:260px; max-width:320px; flex:0 0 300px;">
                                    <div style="font-weight:600; color:#334155; margin-bottom:8px;">Pivot Options</div>
                                    <div class="pivot-card" style="padding:10px;">
                                        <div class="pivot-section-title">Time Granularity & Date Range</div>
                                        <div style="margin-bottom:8px;">
                                            <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Granularity</label>
                                            <select id="anPivotGranularity" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px;">
                                                <option value="day">Daily</option>
                                                <option value="week">Weekly</option>
                                                <option value="month">Monthly</option>
                                            </select>
                                        </div>
                                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px;">
                                            <div>
                                                <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">Start Date</label>
                                                <input type="date" id="anPivotStartDate" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px; font-size:0.85rem;">
                                            </div>
                                            <div>
                                                <label style="font-size:0.8rem; color:#64748b; display:block; margin-bottom:4px;">End Date</label>
                                                <input type="date" id="anPivotEndDate" style="width:100%; padding:6px 8px; border:1px solid #e2e8f0; border-radius:6px; font-size:0.85rem;">
                                            </div>
                                        </div>
                                        <div style="margin-bottom:8px;">
                                            <button class="tiny-btn" id="anPivotPresetLast30" style="margin-right:4px;">Last 30 Days</button>
                                            <button class="tiny-btn" id="anPivotPresetThisMonth">This Month</button>
                                        </div>
                                        <div class="pivot-actions">
                                            <button class="refresh-btn" id="anExportPivotBtn" style="background:#16a34a;"><i class="fas fa-file-csv"></i> Export CSV</button>
                                            <button class="refresh-btn" id="anExportRawBtn" style="background:#0ea5e9;"><i class="fas fa-database"></i> Export Raw CSV</button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Areas -->
                                <div style="flex:1; display:grid; grid-template-columns: 1fr; gap:12px;">
                                    <div class="pivot-card" style="padding:10px;">
                                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                                            <div>
                                                <div class="pivot-section-title">Filters</div>
                                                <select id="pivotAddFilter" class="tiny-btn" style="width:100%; margin-bottom:6px;"></select>
                                                <div id="pivotDropFilters" class="pivot-drop" data-dropzone="filters"></div>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Columns</div>
                                                <select id="pivotAddColumn" class="tiny-btn" style="width:100%; margin-bottom:6px;"></select>
                                                <div id="pivotDropColumns" class="pivot-drop" data-dropzone="columns"></div>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Rows</div>
                                                <select id="pivotAddRow" class="tiny-btn" style="width:100%; margin-bottom:6px;"></select>
                                                <div id="pivotDropRows" class="pivot-drop" data-dropzone="rows"></div>
                                            </div>
                                            <div>
                                                <div class="pivot-section-title">Values</div>
                                                <select id="pivotAddValue" class="tiny-btn" style="width:100%; margin-bottom:6px;"></select>
                                                <div id="pivotDropValues" class="pivot-drop" data-dropzone="values"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <div style="flex:1; overflow:auto;">
                                        <table class="data-table" id="anPivotTable" style="min-width:720px;">
                                            <thead id="anPivotHead"></thead>
                                            <tbody id="anPivotBody"></tbody>
                                            <tfoot id="anPivotFoot"></tfoot>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Empty state (used by charts when no data) -->
                    <div class="empty-state" id="analyticsEmptyState" style="display:none;"></div>
                </div>
                <!-- Visualization Tab (New) -->
                <div id="visualizationTab" class="tab-content" style="display:none; padding:12px;">
                    <div class="table-header" style="border-bottom:none; display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;">
                        <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
                            <button type="button" id="vzAddSetBtn" class="tab-btn" style="background:#2563eb;color:#fff;">Add Analysis Set</button>
                            <button type="button" id="vzClearSetsBtn" class="tab-btn" style="background:#e2e8f0;color:#334155;">Clear</button>
                        </div>
                        <div id="vzInlineStatus" style="font-size:0.65rem; color:#64748b;">Design custom analysis sets for storage movements.</div>
                    </div>
                    <div id="vzSetsContainer" class="flex flex-col gap-3 mt-3"></div>
                </div>

                <!-- Pivot Drilldown Modal -->
                <div id="anDrillModal" class="modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2 id="anDrillTitle">Details</h2>
                            <button class="close-modal" onclick="document.getElementById('anDrillModal').classList.remove('show')">&times;</button>
                        </div>
                        <div class="modal-body" style="max-height:70vh; overflow:auto;">
                            <div style="overflow-x:auto;">
                                <table class="data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <th>Equipment</th>
                                            <th>Equipment Type</th>
                                            <th>Department</th>
                                            <th>Location</th>
                                            <th>Tank</th>
                                            <th>Fuel Type</th>
                                            <th>Quantity (L)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="anDrillBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn" onclick="document.getElementById('anDrillModal').classList.remove('show')">Close</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tank Status Modal -->
            <div id="tankModal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2 id="modalTitle">Add Tank Status</h2>
                        <button class="close-modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="tankForm">
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="tankId" class="required-field">Tank ID</label>
                                    <select id="tankId" name="tankId" required>
                                        <option value="">Select Tank ID</option>
                                    </select>
                                    <small class="form-hint">Select tank from company configuration</small>
                                </div>
                                <div class="form-group">
                                    <label for="location" class="required-field">Location</label>
                                    <select id="location" name="location" required>
                                        <option value="">Select Location</option>
                                    </select>
                                    <small class="form-hint">Fetched from company areas</small>
                                </div>
                                <div class="form-group">
                                    <label for="fuelType" class="required-field">Fuel Type</label>
                                    <select id="fuelType" name="fuelType" required>
                                        <option value="">Select Fuel Type</option>
                                        <option value="Diesel">Diesel</option>
                                        <option value="Jet A1">Jet A1</option>
                                        <option value="Gasoline">Gasoline</option>
                                        <option value="Heavy Fuel Oil">Heavy Fuel Oil (HFO)</option>
                                        <option value="Marine Gas Oil">Marine Gas Oil</option>
                                        <option value="Kerosene">Kerosene</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="maxVolume" class="required-field">Maximum Volume (Liters)</label>
                                    <input type="number" id="maxVolume" name="maxVolume" min="1" step="0.01" required inputmode="decimal" pattern="[0-9]*[.,]?[0-9]*">
                                </div>
                                <div class="form-group">
                                    <label for="currentVolume" class="required-field">Opening Stock (Liters)</label>
                                    <input type="number" id="currentVolume" name="currentVolume" min="0" step="0.01" required inputmode="decimal" pattern="[0-9]*[.,]?[0-9]*">
                                </div>
                                <div class="form-group">
                                    <label for="physicalClosingStock">Physical Closing Stock (Liters)</label>
                                    <input type="number" id="physicalClosingStock" name="physicalClosingStock" min="0" step="0.01" inputmode="decimal" pattern="[0-9]*[.,]?[0-9]*">
                                    <small class="form-hint">Optional: manual closing stock measured at end of day</small>
                                </div>
                                <div class="form-group">
                                    <label for="reception">Reception (Liters)</label>
                                    <input type="number" id="reception" name="reception" min="0" step="0.01" inputmode="decimal" pattern="[0-9]*[.,]?[0-9]*">
                                    <small class="form-hint">Optional: total received for the day</small>
                                </div>
                                <div class="form-group">
                                    <label for="stockDate" class="required-field">Stock Date & Time</label>
                                    <input type="datetime-local" id="stockDate" name="stockDate" required>
                                    <small class="form-hint">Specify the exact date and time when the fuel was stocked</small>
                                </div>
                                
                                <div class="form-group">
                                    <label for="ullage">Ullage (Liters)</label>
                                    <input type="number" id="ullage" name="ullage" readonly class="calculated-field">
                                    <small class="form-hint">Auto-calculated: Max Volume - Opening Stock</small>
                                </div>
                                <div class="form-group full-width">
                                    <label for="statusField">Tank Status</label>
                                    <input type="text" id="statusField" name="statusField" readonly class="calculated-field">
                                    <small class="form-hint">Auto-calculated based on capacity percentage</small>
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn" id="cancelBtn">Cancel</button>
                        <button class="btn btn-create" id="saveTankBtn">Save Tank Status</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Tank Details Modal -->
    <div id="tankDetailsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="tankDetailsTitle">Tank Details</h2>
                <button class="close-modal" id="closeTankDetailsBtn" aria-label="Close details">&times;</button>
            </div>
            <div class="modal-body">
                <div id="tankDetailsBody" style="display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 14px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="deleteTankBtn" style="background:linear-gradient(135deg,#dc2626,#b91c1c);color:#fff;">
                    <i class="fas fa-trash-alt"></i> Delete
                </button>
                <button class="btn btn-create" id="tankDetailsEditBtn">Edit</button>
                <button class="btn" id="tankDetailsCloseFooter">Close</button>
            </div>
        </div>
    </div>

    <!-- Fuel Storage Management JavaScript -->
    <script>
        class FuelStorageManager {
            constructor() {
                this.tanks = JSON.parse(localStorage.getItem('fuelStorageTanks') || '[]');
                this.tankIdMap = {}; // value -> friendly label
                this.locationMap = {}; // value -> friendly label
                this.editingTankId = null;
                
                // Wait a moment for centralized auth to initialize
                setTimeout(() => {
                    this.initializeStorageManagement();
                    // Load selectable tank IDs first so display labels are available
                    this.loadTankIds().then(async () => {
                        await this.loadTanksFromFirebase();
                        // Preload distributions/storage caches so row-level daily closing calc has data
                        try { if (typeof ensureAnalyticsDataLoaded === 'function') await ensureAnalyticsDataLoaded(); } catch (_) {}
                        this.ensureTankIdDisplay();
                        this.renderTanks();
                        // Precompute current stock after last transaction
                        computeLastStockAfterTransactions();
                    });
                    // Also load location options early so analytics can use friendly labels
                    this.loadLocations();
                    this.loadCompanyAndBranding();
                }, 200);
            }

            async loadTanksFromFirebase() {
                try {
                    // Get current user's company ID
                    const currentUser = window.authManager?.currentUser;
                    if (!currentUser || !currentUser.companyId) {
                        console.warn('No company ID found, loading from localStorage only');
                        return;
                    }

                    const companyId = currentUser.companyId;
                    console.log('Loading fuel storage tanks from Firebase for company:', companyId);
                    
                    // Get Firebase database reference - use global functions or direct Firebase access
                    let db, tanksRef, snapshot;
                    
                    if (window.getDatabase && window.ref && window.get) {
                        // Use exposed functions from centralized system
                        db = window.getDatabase();
                        tanksRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatus`);
                        snapshot = await window.get(tanksRef);
                    } else if (window.firebase) {
                        // Fallback to direct Firebase access
                        console.log('Using direct Firebase access for fuel storage data');
                        db = window.firebase.database();
                        tanksRef = db.ref(`companies/${companyId}/fuelmanagement/storageStatus`);
                        snapshot = await tanksRef.once('value');
                    } else {
                        throw new Error('Firebase not available');
                    }
                    
                    if (snapshot.exists()) {
                        const firebaseTanks = snapshot.val();
                        // Convert Firebase object to array
                        this.tanks = Object.values(firebaseTanks);
                        
                        // Sort by last updated (newest first)
                        this.tanks.sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated));
                        
                        // Also save to localStorage for offline access
                        this.saveTanks();
                        this.ensureTankIdDisplay();
                        
                        console.log('âœ… Loaded', this.tanks.length, 'fuel storage tanks from Firebase');

                        // Attach realtime listener for future changes
                        try {
                            if (tanksRef && (tanksRef.on || (window.onValue && window.ref))) {
                                if (tanksRef.on) {
                                    // Compat API
                                    tanksRef.off('value');
                                    tanksRef.on('value', (snap) => {
                                        if (!snap.exists()) return;
                                        const data = snap.val();
                                        this.tanks = Object.values(data);
                                        this.tanks.sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated));
                                        this.saveTanks();
                                        this.ensureTankIdDisplay();
                                        this.renderTanks();
                                        computeLastStockAfterTransactions();
                                    });
                                } else if (window.onValue && window.ref) {
                                    // Modular API
                                    window.onValue(tanksRef, (snap) => {
                                        if (!snap.exists()) return;
                                        const data = snap.val();
                                        this.tanks = Object.values(data);
                                        this.tanks.sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated));
                                        this.saveTanks();
                                        this.ensureTankIdDisplay();
                                        this.renderTanks();
                                        computeLastStockAfterTransactions();
                                    });
                                }
                            }
                        } catch (e) {
                            console.warn('âš ï¸ Failed to attach realtime listener:', e);
                        }
                    } else {
                        console.log('No fuel storage tanks found in Firebase');
                    }
                    
                } catch (error) {
                    console.error('âŒ Error loading tanks from Firebase:', error);
                    console.log('Falling back to localStorage data');
                }
            }

            // Backfill tankIdDisplay for legacy records lacking it
            ensureTankIdDisplay() {
                let changed = false;
                const tankIdSelectEl = document.getElementById('tankId');
                // Build a mapping of value->label from current select options if available
                let map = { ...(this.tankIdMap || {}) };
                if (tankIdSelectEl) {
                    [...tankIdSelectEl.options].forEach(o => {
                        if (o.value) map[o.value] = o.textContent.trim();
                    });
                }
                // Expose globally for other modules (analytics/details)
                try { window._tankIdDisplayMap = map; } catch(_) {}
                this.tanks.forEach(t => {
                    if (!t.tankIdDisplay) {
                        t.tankIdDisplay = map[t.tankId] || t.tankId;
                        changed = true;
                    }
                });
                if (changed) {
                    this.saveTanks();
                    // Update last stock mapping; do not await in sync context
                    computeLastStockAfterTransactions();
                }
            }

            async loadCompanyAndBranding() {
                const headerLogo = document.getElementById('headerCompanyLogo');
                const headerLogoPlaceholder = document.getElementById('headerLogoPlaceholder');
                const headerCompanyName = document.getElementById('headerCompanyName');
                
                try {
                    // Get current user from authManager or localStorage
                    let currentUser = null;
                    if (window.authManager && window.authManager.currentUser) {
                        currentUser = window.authManager.currentUser;
                    } else {
                        const storedUser = localStorage.getItem('currentUser');
                        if (storedUser) {
                            currentUser = JSON.parse(storedUser);
                        }
                    }
                    
                    if (!currentUser) {
                        headerCompanyName.textContent = '';
                        headerLogo.style.display = 'none';
                        headerLogoPlaceholder.style.display = 'flex';
                        return;
                    }
                    
                    const database = firebase.database();
                    const companiesSnap = await database.ref('companies').once('value');
                    
                    if (!companiesSnap.exists()) {
                        headerCompanyName.textContent = '';
                        headerLogo.style.display = 'none';
                        headerLogoPlaceholder.style.display = 'flex';
                        return;
                    }
                    
                    const companies = companiesSnap.val();
                    let companyId = currentUser.companyId || null;
                    
                    // Search for user in companies if no direct companyId
                    if (!companyId) {
                        for (const [cId, company] of Object.entries(companies)) {
                            if (company?.status !== 'active') continue;
                            if (company?.users && (company.users[currentUser.uid] || company.users[currentUser.authUid])) {
                                companyId = cId;
                                break;
                            }
                        }
                    }
                    
                    if (companyId && companies[companyId]) {
                        const company = companies[companyId];
                        const companyName = company.companyName || company.name || '';
                        
                        // Set company name
                        headerCompanyName.textContent = companyName;
                        
                        // Set company logo
                        const logoUrl = company.logoUrl || company.logo || '';
                        if (logoUrl) {
                            headerLogo.src = logoUrl;
                            headerLogo.classList.add('visible');
                            headerLogo.style.display = 'block';
                            headerLogoPlaceholder.style.display = 'none';
                        } else {
                            headerLogo.style.display = 'none';
                            headerLogoPlaceholder.style.display = 'flex';
                        }
                        
                        // Update page title
                        if (companyName) {
                            document.title = document.title.replace('Dreamex Datalab HSE', `${companyName} HSE`);
                        }
                        
                        console.log('âœ… Company branding loaded:', companyName);
                    } else {
                        headerCompanyName.textContent = '';
                        headerLogo.style.display = 'none';
                        headerLogoPlaceholder.style.display = 'flex';
                    }
                    
                } catch (error) {
                    console.warn('âš ï¸ Error loading company branding:', error);
                    headerCompanyName.textContent = '';
                    headerLogo.style.display = 'none';
                    headerLogoPlaceholder.style.display = 'flex';
                }
            }

            initializeStorageManagement() {
                this.initializeModal();
                this.setupEventListeners();
                this.setupFormCalculations();
            }

            initializeModal() {
                const modal = document.getElementById('tankModal');
                const createBtn = document.getElementById('createTankBtn');
                const closeBtn = document.querySelector('.close-modal');
                const cancelBtn = document.getElementById('cancelBtn');
                const saveBtn = document.getElementById('saveTankBtn');
                const form = document.getElementById('tankForm');

                if (createBtn) {
                    createBtn.addEventListener('click', () => this.showModal());
                }

                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.hideModal());
                }

                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => this.hideModal());
                }

                if (saveBtn && form) {
                    saveBtn.addEventListener('click', async () => {
                        if (!this.validateForm(form)) return;
                        if (this.editingTankId) {
                            await this.updateTankRecord();
                        } else {
                            await this.createTankRecord();
                        }
                    });
                }

                if (modal) {
                    window.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            this.hideModal();
                        }
                    });
                }
            }

            setupEventListeners() {
                // Profile dropdown toggle
                const profileBtn = document.getElementById('userProfileBtn');
                const profileDropdown = document.querySelector('.profile-dropdown');
                
                if (profileBtn && profileDropdown) {
                    profileBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        profileDropdown.classList.toggle('show');
                    });

                    document.addEventListener('click', () => {
                        profileDropdown.classList.remove('show');
                    });
                }

                // Notification dropdown toggle
                const notificationBtn = document.getElementById('notificationBtn');
                const notificationDropdown = document.querySelector('.notification-dropdown');
                
                if (notificationBtn && notificationDropdown) {
                    notificationBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        notificationDropdown.classList.toggle('show');
                    });

                    document.addEventListener('click', () => {
                        notificationDropdown.classList.remove('show');
                    });
                }

                // Volume update button
                const updateVolumesBtn = document.getElementById('updateVolumesBtn');
                if (updateVolumesBtn) {
                    updateVolumesBtn.addEventListener('click', async () => {
                        try {
                            updateVolumesBtn.disabled = true;
                            updateVolumesBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                            
                            const updatedCount = await updateTankVolumesBasedOnConsumption();
                            
                            if (updatedCount > 0) {
                                this.showNotification('success', `Updated ${updatedCount} tank volume${updatedCount > 1 ? 's' : ''} based on consumption data`);
                            } else {
                                this.showNotification('info', 'All tank volumes are already up to date');
                            }
                            
                        } catch (error) {
                            console.error('Error updating volumes:', error);
                            this.showNotification('error', 'Failed to update tank volumes. Please try again.');
                        } finally {
                            updateVolumesBtn.disabled = false;
                            updateVolumesBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                        }
                    });
                }

                // Bulk selection: select all rows
                const selectAll = document.getElementById('selectAllTanks');
                const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
                if (selectAll) {
                    selectAll.addEventListener('change', () => {
                        document.querySelectorAll('#storageTableBody .row-select').forEach(cb => {
                            cb.checked = selectAll.checked;
                        });
                        this.updateBulkDeleteState();
                    });
                }

                // Delegate row checkbox changes to update button state
                const tableBody = document.getElementById('storageTableBody');
                if (tableBody) {
                    tableBody.addEventListener('change', (e) => {
                        if (e.target && e.target.classList.contains('row-select')) {
                            this.syncSelectAllCheckbox();
                            this.updateBulkDeleteState();
                        }
                    });
                }

                // Bulk delete action
                if (deleteSelectedBtn) {
                    deleteSelectedBtn.addEventListener('click', async () => {
                        const selectedIds = Array.from(document.querySelectorAll('#storageTableBody .row-select:checked')).map(cb => cb.getAttribute('data-id'));
                        if (!selectedIds.length) return;
                        const confirmed = confirm(`Delete ${selectedIds.length} selected record${selectedIds.length > 1 ? 's' : ''}? This cannot be undone.`);
                        if (!confirmed) return;
                        deleteSelectedBtn.disabled = true;
                        deleteSelectedBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                        try {
                            await this.bulkDeleteTanks(selectedIds);
                            this.showNotification('success', `Deleted ${selectedIds.length} record${selectedIds.length > 1 ? 's' : ''}`);
                        } catch (err) {
                            console.error('Bulk delete failed:', err);
                            this.showNotification('error', 'Failed to delete selected records');
                        } finally {
                            deleteSelectedBtn.disabled = true;
                            deleteSelectedBtn.innerHTML = '<i class="fas fa-trash"></i>';
                            this.renderTanks();
                            this.syncSelectAllCheckbox();
                        }
                    });
                }
            }

            updateBulkDeleteState() {
                const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
                if (!deleteSelectedBtn) return;
                const anyChecked = document.querySelector('#storageTableBody .row-select:checked') !== null;
                deleteSelectedBtn.disabled = !anyChecked;
            }

            syncSelectAllCheckbox() {
                const selectAll = document.getElementById('selectAllTanks');
                const checkboxes = document.querySelectorAll('#storageTableBody .row-select');
                if (!selectAll || !checkboxes.length) return;
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                const anyChecked = Array.from(checkboxes).some(cb => cb.checked);
                selectAll.indeterminate = !allChecked && anyChecked;
                selectAll.checked = allChecked && anyChecked;
            }

            async bulkDeleteTanks(ids) {
                // Remove locally first
                const idSet = new Set(ids);
                this.tanks = this.tanks.filter(t => !idSet.has(t.id));
                this.saveTanks();
                
                // Attempt Firebase removal for each id, plus associated daily entries
                const currentUser = window.authManager?.currentUser;
                if (!currentUser || !currentUser.companyId) return;
                const companyId = currentUser.companyId;
                let db = null;
                try {
                    if (window.getDatabase) {
                        db = window.getDatabase();
                        for (const tid of ids) {
                            const tankRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatus/${tid}`);
                            if (window.remove) await window.remove(tankRef);
                        }
                    } else if (window.firebase && window.firebase.database) {
                        db = window.firebase.database();
                        for (const tid of ids) {
                            await db.ref(`companies/${companyId}/fuelmanagement/storageStatus/${tid}`).remove();
                        }
                    }
                } catch (err) {
                    console.warn('Non-blocking: failed to remove some tanks from Firebase', err);
                }

                // Best-effort cleanup: remove daily snapshots for the deleted tankIds
                try {
                    if (!db) {
                        if (window.getDatabase) db = window.getDatabase();
                        else if (window.firebase && window.firebase.database) db = window.firebase.database();
                    }
                    if (db) {
                        if (window.ref && window.remove) {
                            for (const tid of ids) {
                                const dailyRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatusDaily/${tid}`);
                                await window.remove(dailyRef);
                            }
                        } else if (window.firebase && window.firebase.database) {
                            for (const tid of ids) {
                                await db.ref(`companies/${companyId}/fuelmanagement/storageStatusDaily/${tid}`).remove();
                            }
                        }
                    }
                } catch (err) {
                    console.warn('Non-blocking: failed to remove some daily entries', err);
                }
            }

            setupFormCalculations() {
                const maxVolumeInput = document.getElementById('maxVolume');
                const currentVolumeInput = document.getElementById('currentVolume');
                const receptionInput = document.getElementById('reception');
                const physicalClosingInput = document.getElementById('physicalClosingStock');
                const ullageInput = document.getElementById('ullage');
                const statusInput = document.getElementById('statusField');

                const calculateValues = () => {
                    const maxVolume = parseFloat(maxVolumeInput.value) || 0;
                    const currentVolume = parseFloat(currentVolumeInput.value) || 0;
                    
                    if (maxVolume > 0) {
                        // Calculate ullage
                        const ullage = maxVolume - currentVolume;
                        ullageInput.value = ullage.toFixed(2);
                        
                        // Calculate capacity percentage
                        const capacityPercentage = (currentVolume / maxVolume) * 100;
                        
                        // Determine status based on capacity
                        let status = '';
                        if (capacityPercentage >= 95) {
                            status = 'Full';
                        } else if (capacityPercentage >= 80) {
                            status = 'High';
                        } else if (capacityPercentage >= 50) {
                            status = 'Normal';
                        } else if (capacityPercentage >= 20) {
                            status = 'Low';
                        } else {
                            status = 'Critical';
                        }
                        
                        statusInput.value = `${status} (${capacityPercentage.toFixed(1)}%)`;
                    } else {
                        ullageInput.value = '';
                        statusInput.value = '';
                    }
                };

                // Normalize numeric typing: allow comma decimal and filter invalid chars
                const attachNumericNormalizer = (el) => {
                    if (!el) return;
                    el.setAttribute('inputmode','decimal');
                    el.setAttribute('pattern','[0-9]*[.,]?[0-9]*');
                    el.addEventListener('input', (e) => {
                        let v = e.target.value || '';
                        v = v.replace(',', '.').replace(/[^0-9.]/g, '');
                        const firstDot = v.indexOf('.');
                        if (firstDot !== -1) {
                            v = v.slice(0, firstDot + 1) + v.slice(firstDot + 1).replace(/\./g, '');
                        }
                        if (e.target.value !== v) e.target.value = v;
                        calculateValues();
                    });
                };

                attachNumericNormalizer(maxVolumeInput);
                attachNumericNormalizer(currentVolumeInput);
                attachNumericNormalizer(receptionInput);
                attachNumericNormalizer(physicalClosingInput);
            }

            showModal() {
                const modal = document.getElementById('tankModal');
                const form = document.getElementById('tankForm');
                const modalTitle = document.getElementById('modalTitle');
                const saveBtn = document.getElementById('saveTankBtn');
                
                if (!modal || !form || !modalTitle || !saveBtn) return;

                modalTitle.textContent = 'Add Tank Status';
                saveBtn.textContent = 'Save Tank Status';
                this.editingTankId = null;
                form.reset();
                // Prefill stock date-time to current local time (rounded to minutes)
                try {
                    const stockInput = document.getElementById('stockDate');
                    if (stockInput) {
                        const now = new Date();
                        now.setSeconds(0, 0);
                        stockInput.value = this.formatForDateTimeLocal(now);
                        // Ensure tank IDs are filtered for this date and keep them updated on change
                        const getYmd = (val) => {
                            if (!val) return null;
                            if (typeof val === 'string') return (val.includes('T') ? val.split('T')[0] : val);
                            try { return val.toISOString().slice(0,10); } catch { return null; }
                        };
                        const ymd = getYmd(stockInput.value);
                        // Load tank IDs from company settings excluding those already used for this date
                        this.loadTankIds({ excludeDateYMD: ymd });
                        // Re-filter when user changes the date
                        if (this._stockDateChangeHandler) {
                            stockInput.removeEventListener('change', this._stockDateChangeHandler);
                        }
                        this._stockDateChangeHandler = () => {
                            const y = getYmd(stockInput.value);
                            this.loadTankIds({ excludeDateYMD: y });
                        };
                        stockInput.addEventListener('change', this._stockDateChangeHandler);
                        // Also react to input if browser fires it for datetime-local
                        stockInput.addEventListener('input', this._stockDateChangeHandler);
                    }
                } catch {}
                
                // Load locations (areas) from company settings
                this.loadLocations();
                
                modal.classList.add('show');
                document.getElementById('tankId').focus();
            }

            hideModal() {
                const modal = document.getElementById('tankModal');
                const form = document.getElementById('tankForm');
                const modalTitle = document.getElementById('modalTitle');
                const saveBtn = document.getElementById('saveTankBtn');
                
                if (!modal || !form) return;
                
                modal.classList.remove('show');
                form.reset();
                this.editingTankId = null;
                if (modalTitle) modalTitle.textContent = 'Add Tank Status';
                if (saveBtn) saveBtn.textContent = 'Save Tank Status';
            }

            async openEditTank(tankId) {
                const tank = this.tanks.find(t => t.id === tankId);
                if (!tank) return;

                const modal = document.getElementById('tankModal');
                const form = document.getElementById('tankForm');
                const modalTitle = document.getElementById('modalTitle');
                const saveBtn = document.getElementById('saveTankBtn');
                if (!modal || !form || !modalTitle || !saveBtn) return;

                // Ensure selects are populated before setting values
                await this.loadTankIds({ allowValue: tank.tankId });
                await this.loadLocations();

                // Set values, ensuring options exist
                const tankIdSelect = document.getElementById('tankId');
                if (tankIdSelect) {
                    const displayLabel = this.tankIdMap?.[tank.tankId]
                        || (window._tankIdDisplayMap ? window._tankIdDisplayMap[tank.tankId] : null)
                        || tank.tankIdDisplay
                        || tank.tankId;
                    const existingOpt = [...tankIdSelect.options].find(o => o.value === tank.tankId);
                    if (existingOpt) {
                        // Ensure the option shows the friendly label
                        if (displayLabel && existingOpt.textContent !== displayLabel) {
                            existingOpt.textContent = displayLabel;
                        }
                    } else {
                        const opt = document.createElement('option');
                        opt.value = tank.tankId;
                        opt.textContent = displayLabel;
                        tankIdSelect.appendChild(opt);
                    }
                    tankIdSelect.value = tank.tankId;
                }

                const locationSelect = document.getElementById('location');
                if (locationSelect && tank.location && ![...locationSelect.options].some(o => o.value === tank.location)) {
                    const opt = document.createElement('option');
                    opt.value = tank.location;
                    opt.textContent = tank.location;
                    locationSelect.appendChild(opt);
                }
                locationSelect.value = tank.location || '';

                document.getElementById('fuelType').value = tank.fuelType || '';
                document.getElementById('maxVolume').value = tank.maxVolume ?? '';
                document.getElementById('currentVolume').value = tank.currentVolume ?? '';
                const physCloseEl = document.getElementById('physicalClosingStock');
                if (physCloseEl) {
                    const v = (typeof tank.physicalClosingStock === 'number') ? tank.physicalClosingStock : (tank.physicalClosingStock || '');
                    physCloseEl.value = (v === null || v === undefined) ? '' : v;
                }
                const stockInput = document.getElementById('stockDate');
                if (stockInput) {
                    stockInput.value = this.formatForDateTimeLocal(tank.stockDate) || '';
                }
                document.getElementById('ullage').value = tank.ullage ?? '';
                document.getElementById('statusField').value = `${tank.status} (${(tank.capacityPercentage ?? 0).toFixed(1)}%)`;

                modalTitle.textContent = 'Edit Tank Status';
                saveBtn.textContent = 'Update Tank Status';
                this.editingTankId = tank.id;
                modal.classList.add('show');
            }

            // Helper to format for <input type="datetime-local">
            formatForDateTimeLocal(value) {
                try {
                    if (!value) return '';
                    if (typeof value === 'string') {
                        if (value.includes('T')) {
                            // Already in a datetime-like format; ensure it's HH:MM
                            const parts = value.split('T');
                            const time = (parts[1] || '').slice(0,5);
                            return `${parts[0]}T${time || '00:00'}`;
                        }
                        if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                            return `${value}T00:00`;
                        }
                        const d = new Date(value);
                        if (!isNaN(d)) return this.formatForDateTimeLocal(d);
                        return '';
                    }
                    if (value instanceof Date) {
                        const pad = (n) => n.toString().padStart(2, '0');
                        const year = value.getFullYear();
                        const month = pad(value.getMonth() + 1);
                        const day = pad(value.getDate());
                        const hours = pad(value.getHours());
                        const minutes = pad(value.getMinutes());
                        return `${year}-${month}-${day}T${hours}:${minutes}`;
                    }
                    return '';
                } catch { return ''; }
            }

            async updateTankRecord() {
                const form = document.getElementById('tankForm');
                const formData = new FormData(form);

                const maxVolume = parseFloat(formData.get('maxVolume'));
                const currentVolume = parseFloat(formData.get('currentVolume'));
                const physicalClosingStock = formData.get('physicalClosingStock') ? parseFloat(formData.get('physicalClosingStock')) : null;
                const reception = formData.get('reception') ? parseFloat(formData.get('reception')) : 0;
                const ullage = maxVolume - currentVolume;
                const capacityPercentage = (currentVolume / maxVolume) * 100;

                let status = '';
                if (capacityPercentage >= 95) {
                    status = 'Full';
                } else if (capacityPercentage >= 80) {
                    status = 'High';
                } else if (capacityPercentage >= 50) {
                    status = 'Normal';
                } else if (capacityPercentage >= 20) {
                    status = 'Low';
                } else {
                    status = 'Critical';
                }

                const idx = this.tanks.findIndex(t => t.id === this.editingTankId);
                if (idx === -1) return;

                const existing = this.tanks[idx];
                // Preserve or recalculate display label for tank ID
                let newTankIdValue = formData.get('tankId');
                let tankIdDisplay = existing.tankIdDisplay || existing.tankId;
                if (newTankIdValue !== existing.tankId) {
                    const tankIdSelectEl = document.getElementById('tankId');
                    if (tankIdSelectEl) {
                        const selOpt = [...tankIdSelectEl.options].find(o => o.value === newTankIdValue);
                        if (selOpt) tankIdDisplay = selOpt.textContent.trim();
                        else tankIdDisplay = newTankIdValue;
                    } else {
                        tankIdDisplay = newTankIdValue;
                    }
                }

                const updated = {
                    ...existing,
                    tankId: newTankIdValue,
                    tankIdDisplay: tankIdDisplay,
                    location: formData.get('location'),
                    fuelType: formData.get('fuelType'),
                    maxVolume,
                    currentVolume,
                    reception: (typeof reception === 'number' && !isNaN(reception)) ? reception : 0,
                    physicalClosingStock: (typeof physicalClosingStock === 'number' && !isNaN(physicalClosingStock)) ? physicalClosingStock : null,
                    // If stockDate changed, reset the baseline to the new currentVolume
                    baselineVolumeAtStockDate: (function(){
                        const newStockDate = formData.get('stockDate');
                        const prevStockDate = existing.stockDate || null;
                        if (newStockDate && newStockDate !== prevStockDate) {
                            return currentVolume;
                        }
                        // keep prior baseline if set; else initialize to current
                        return typeof existing.baselineVolumeAtStockDate === 'number' ? existing.baselineVolumeAtStockDate : currentVolume;
                    })(),
                    stockDate: formData.get('stockDate'),
                    ullage,
                    capacityPercentage,
                    status,
                    lastUpdated: new Date().toISOString(),
                    updatedBy: window.authManager?.currentUser?.email || 'Unknown'
                };

                try {
                    this.tanks[idx] = updated;
                    this.saveTanks();
                    await this.updateTankInFirebase(updated);
                    // Also persist a daily stock entry for this tank on the selected date
                    await this.saveDailyStockEntry(updated);
                    this.renderTanks();
                    this.hideModal();
                    this.showNotification('success', 'Tank status updated successfully!');
                } catch (err) {
                    console.error('Error updating tank record:', err);
                    this.showNotification('error', 'Failed to update tank record. Please try again.');
                }
            }

            async updateTankInFirebase(tank) {
                try {
                    const currentUser = window.authManager?.currentUser;
                    if (!currentUser || !currentUser.companyId) {
                        console.warn('No company ID found for current user');
                        return;
                    }
                    const companyId = currentUser.companyId;

                    let db, tankRef;
                    if (window.getDatabase && window.ref && window.set) {
                        db = window.getDatabase();
                        tankRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatus/${tank.id}`);
                        await window.set(tankRef, tank);
                    } else if (window.firebase) {
                        db = window.firebase.database();
                        tankRef = db.ref(`companies/${companyId}/fuelmanagement/storageStatus/${tank.id}`);
                        await tankRef.set(tank);
                    } else {
                        throw new Error('Firebase not available');
                    }
                } catch (e) {
                    console.error('âŒ Error updating tank in Firebase:', e);
                    throw e;
                }
            }

            // options: { excludeDateYMD?: 'YYYY-MM-DD' | null, allowValue?: string }
            async loadTankIds(options = {}) {
                const tankSelect = document.getElementById('tankId');
                if (!tankSelect) return;

                try {
                    // Clear existing options except the first placeholder
                    tankSelect.innerHTML = '<option value="">Select Tank ID</option>';

                    let tankIdsRef;
                    // Prefer current user's company path; fall back to legacy fixed path
                    const currentCompanyId = (window.authManager?.currentUser?.companyId) || (window.authManager?.getCurrentUser?.()?.companyId) || null;
                    const dynamicPath = currentCompanyId ? `companies/${currentCompanyId}/fieldOptions/tank-id` : null;
                    const fixedPath = 'companies/-OYL6cpeH7JnNLPBhCTH/fieldOptions/tank-id';
                    
                    // Initialize db handle for both compat and modular API
                    let db;
                    if (window.getDatabase) {
                        db = window.getDatabase();
                    } else if (window.firebase && window.firebase.database) {
                        db = window.firebase.database();
                    }

                    const pathToUse = dynamicPath || fixedPath;
                    if (window.ref && db) {
                        tankIdsRef = window.ref(db, pathToUse);
                    } else if (db && db.ref) {
                        tankIdsRef = db.ref(pathToUse);
                    }

                    if (window.get && window.ref) {
                        const snapshot = await window.get(tankIdsRef);
                        if (snapshot.exists()) {
                            const tankIds = snapshot.val();
                            this.populateTankOptions(tankIds, tankSelect, options);
                        } else {
                            console.warn('No tank IDs configured in company settings');
                            this.addFallbackOption(tankSelect);
                        }
                    } else if (tankIdsRef && tankIdsRef.once) {
                        await new Promise((resolve) => {
                            tankIdsRef.once('value', (snapshot) => {
                                try {
                                    if (snapshot.exists()) {
                                        const tankIds = snapshot.val();
                                        this.populateTankOptions(tankIds, tankSelect, options);
                                    } else {
                                        console.warn('No tank IDs configured in company settings');
                                        this.addFallbackOption(tankSelect);
                                    }
                                } finally { resolve(); }
                            }, () => resolve());
                        });
                    } else {
                        console.error('Firebase reference not available to load tank IDs');
                        this.addFallbackOption(tankSelect);
                    }

                } catch (error) {
                    console.error('Error loading tank IDs:', error);
                    this.addFallbackOption(tankSelect);
                }
            }

            async loadLocations() {
                const select = document.getElementById('location');
                if (!select) return;

                try {
                    // Reset options
                    select.innerHTML = '<option value="">Select Location</option>';
                    // Prefer current user's company path; fall back to legacy fixed path
                    const currentCompanyId = (window.authManager?.currentUser?.companyId) || (window.authManager?.getCurrentUser?.()?.companyId) || null;
                    const dynamicPath = currentCompanyId ? `companies/${currentCompanyId}/fieldOptions/area` : null;
                    const fixedPath = 'companies/-OYL6cpeH7JnNLPBhCTH/fieldOptions/area';
                    const pathToUse = dynamicPath || fixedPath;
                    // Initialize db
                    let db;
                    if (window.getDatabase) {
                        db = window.getDatabase();
                    } else if (window.firebase && window.firebase.database) {
                        db = window.firebase.database();
                    }

                    let refNode;
                    if (window.ref && db) {
                        refNode = window.ref(db, pathToUse);
                    } else if (db && db.ref) {
                        refNode = db.ref(pathToUse);
                    }

                    if (window.get && window.ref) {
                        const snapshot = await window.get(refNode);
                        if (snapshot.exists()) {
                            const areas = snapshot.val();
                            this.populateLocationOptions(areas, select);
                        } else {
                            this.addLocationFallback(select);
                        }
                    } else if (refNode && refNode.once) {
                        refNode.once('value', (snapshot) => {
                            if (snapshot.exists()) {
                                const areas = snapshot.val();
                                this.populateLocationOptions(areas, select);
                            } else {
                                this.addLocationFallback(select);
                            }
                        });
                    } else {
                        this.addLocationFallback(select);
                    }
                } catch (err) {
                    console.error('Error loading locations:', err);
                    this.addLocationFallback(select);
                }
            }

            populateGenericOptions(items, selectElement) {
                if (Array.isArray(items)) {
                    items.forEach(item => {
                        if (item && (item.enabled === undefined || item.enabled)) {
                            const opt = document.createElement('option');
                            opt.value = item.value ?? item.label ?? '';
                            opt.textContent = item.label ?? item.value ?? '';
                            if (opt.value) selectElement.appendChild(opt);
                        }
                    });
                } else if (items && typeof items === 'object') {
                    Object.keys(items).forEach(key => {
                        const item = items[key];
                        if (item && (item.enabled === undefined || item.enabled)) {
                            const opt = document.createElement('option');
                            opt.value = item.value ?? key;
                            opt.textContent = item.label ?? key;
                            selectElement.appendChild(opt);
                        }
                    });
                } else {
                    this.addLocationFallback(selectElement);
                }
            }

            // Populate location select and build mapping for friendly display
            populateLocationOptions(items, selectElement) {
                this.locationMap = {};
                if (Array.isArray(items)) {
                    items.forEach(item => {
                        if (item && (item.enabled === undefined || item.enabled)) {
                            const val = item.value ?? item.label ?? '';
                            const label = item.label ?? item.value ?? '';
                            if (!val) return;
                            const opt = document.createElement('option');
                            opt.value = val;
                            opt.textContent = label;
                            selectElement.appendChild(opt);
                            this.locationMap[val] = label;
                        }
                    });
                } else if (items && typeof items === 'object') {
                    Object.keys(items).forEach(key => {
                        const item = items[key];
                        if (item && (item.enabled === undefined || item.enabled)) {
                            const val = item.value ?? key;
                            const label = item.label ?? key;
                            const opt = document.createElement('option');
                            opt.value = val;
                            opt.textContent = label;
                            selectElement.appendChild(opt);
                            this.locationMap[val] = label;
                        }
                    });
                } else {
                    this.addLocationFallback(selectElement);
                }
                try { window._locationDisplayMap = { ...(this.locationMap || {}) }; } catch (_) {}
            }

            addLocationFallback(selectElement) {
                const opt = document.createElement('option');
                opt.value = 'manual-entry';
                opt.textContent = 'Enter Location Manually (Settings Not Configured)';
                selectElement.appendChild(opt);
                selectElement.addEventListener('change', (e) => {
                    if (e.target.value === 'manual-entry') {
                        const manual = prompt('Enter Location:');
                        if (manual) {
                            const newOpt = document.createElement('option');
                            newOpt.value = manual;
                            newOpt.textContent = manual;
                            newOpt.selected = true;
                            // Insert before the fallback
                            selectElement.insertBefore(newOpt, selectElement.lastElementChild);
                        }
                    }
                });
            }

            // Populate Tank ID dropdown with optional exclusion based on existing rows for a given date
            populateTankOptions(tankIds, selectElement, options = {}) {
                const excludeDateYMD = options.excludeDateYMD || null;
                const allowValue = options.allowValue || null;
                const hasOption = (val) => Array.from(selectElement.options).some(o => o.value === String(val));
                if (Array.isArray(tankIds)) {
                    // Build exclusion set of tankIds already used for excludeDateYMD
                    let usedSet = new Set();
                    if (excludeDateYMD) {
                        try {
                            const toYMD = (d) => {
                                if (!d) return '';
                                const dt = (typeof d === 'string') ? new Date(d) : d;
                                if (isNaN(dt)) return '';
                                const y = dt.getFullYear();
                                const m = String(dt.getMonth()+1).padStart(2,'0');
                                const da = String(dt.getDate()).padStart(2,'0');
                                return `${y}-${m}-${da}`;
                            };
                            (this.tanks || []).forEach(t => {
                                // A row is considered created for that day if tankId matches and stockDate falls on that day
                                const ymd = toYMD(t.stockDate || t.lastUpdated || t.createdAt);
                                if (ymd === excludeDateYMD && t.tankId) usedSet.add(String(t.tankId));
                            });
                        } catch (_) {}
                    }
                    tankIds.forEach(tank => {
                        if (tank.enabled) {
                            // Skip if already used for the day, unless explicit allowValue overrides (for edit)
                            if (excludeDateYMD && usedSet.has(String(tank.value)) && String(allowValue) !== String(tank.value)) {
                                // do not add this option
                                // but keep mapping for display lookups
                                this.tankIdMap[tank.value] = tank.label;
                                return;
                            }
                            if (!hasOption(tank.value)) {
                                const option = document.createElement('option');
                                option.value = tank.value;
                                option.textContent = tank.label;
                                selectElement.appendChild(option);
                            }
                            // store mapping for friendly display
                            this.tankIdMap[tank.value] = tank.label;
                        }
                    });
                    try { window._tankIdDisplayMap = { ...(this.tankIdMap||{}) }; } catch(_) {}
                } else {
                    console.warn('Tank IDs data is not in expected array format');
                    this.addFallbackOption(selectElement);
                }
            }

            addFallbackOption(selectElement) {
                const option = document.createElement('option');
                option.value = 'manual-entry';
                option.textContent = 'Enter Tank ID Manually (Settings Not Configured)';
                selectElement.appendChild(option);
                
                // Add event listener to allow manual entry
                selectElement.addEventListener('change', (e) => {
                    if (e.target.value === 'manual-entry') {
                        const manualId = prompt('Enter Tank ID:');
                        if (manualId) {
                            // Avoid duplicates if this ID already exists
                            const exists = Array.from(selectElement.options).some(o => o.value === manualId);
                            if (exists) {
                                selectElement.value = manualId;
                            } else {
                                const newOption = document.createElement('option');
                                newOption.value = manualId;
                                newOption.textContent = manualId;
                                newOption.selected = true;
                                selectElement.insertBefore(newOption, selectElement.lastElementChild);
                            }
                        }
                    }
                });
            }

            validateForm(form) {
                // Check required fields
                const requiredFields = form.querySelectorAll('[required]');
                let isValid = true;

                requiredFields.forEach(field => {
                    if (!field.value.trim()) {
                        field.style.borderColor = '#ef4444';
                        isValid = false;
                    } else {
                        field.style.borderColor = '#e2e8f0';
                    }
                });

                // Additional validation: opening stock and physical closing should not exceed max volume
                const maxVolume = parseFloat(form.maxVolume.value);
                const currentVolume = parseFloat(form.currentVolume.value);
                const physicalClosingStock = parseFloat(form.physicalClosingStock.value);

                if (!isNaN(currentVolume) && !isNaN(maxVolume) && currentVolume > maxVolume) {
                    form.currentVolume.style.borderColor = '#ef4444';
                    alert('Opening stock cannot exceed maximum volume.');
                    isValid = false;
                }
                if (!isNaN(physicalClosingStock) && !isNaN(maxVolume) && physicalClosingStock > maxVolume) {
                    form.physicalClosingStock.style.borderColor = '#ef4444';
                    alert('Physical closing stock cannot exceed maximum volume.');
                    isValid = false;
                } else if (form.physicalClosingStock) {
                    form.physicalClosingStock.style.borderColor = '#e2e8f0';
                }

                if (!isValid) {
                    alert('Please fill in all required fields correctly.');
                }

                return isValid;
            }

            async createTankRecord() {
                const form = document.getElementById('tankForm');
                const formData = new FormData(form);
                
                const maxVolume = parseFloat(formData.get('maxVolume'));
                const currentVolume = parseFloat(formData.get('currentVolume'));
                const physicalClosingStock = formData.get('physicalClosingStock') ? parseFloat(formData.get('physicalClosingStock')) : null;
                const reception = formData.get('reception') ? parseFloat(formData.get('reception')) : 0;
                const ullage = maxVolume - currentVolume;
                const capacityPercentage = (currentVolume / maxVolume) * 100;
                
                // Determine status
                let status = '';
                if (capacityPercentage >= 95) {
                    status = 'Full';
                } else if (capacityPercentage >= 80) {
                    status = 'High';
                } else if (capacityPercentage >= 50) {
                    status = 'Normal';
                } else if (capacityPercentage >= 20) {
                    status = 'Low';
                } else {
                    status = 'Critical';
                }

                // Capture display label for selected tank option
                let rawTankId = formData.get('tankId');
                let tankIdDisplay = rawTankId;
                const tankIdSelectEl = document.getElementById('tankId');
                if (tankIdSelectEl) {
                    const selOpt = [...tankIdSelectEl.options].find(o => o.value === rawTankId);
                    if (selOpt) tankIdDisplay = selOpt.textContent.trim();
                }

                const tank = {
                    id: Date.now().toString(),
                    tankId: rawTankId,
                    tankIdDisplay: tankIdDisplay,
                    location: formData.get('location'),
                    fuelType: formData.get('fuelType'),
                    maxVolume: maxVolume,
                    currentVolume: currentVolume,
                    reception: (typeof reception === 'number' && !isNaN(reception)) ? reception : 0,
                    physicalClosingStock: (typeof physicalClosingStock === 'number' && !isNaN(physicalClosingStock)) ? physicalClosingStock : null,
                    baselineVolumeAtStockDate: currentVolume,
                    stockDate: formData.get('stockDate'),
                    ullage: ullage,
                    capacityPercentage: capacityPercentage,
                    status: status,
                    lastUpdated: new Date().toISOString(),
                    updatedBy: window.authManager?.currentUser?.email || 'Unknown'
                };

                try {
                    // Save to local storage first (for fallback)
                    this.tanks.push(tank);
                    this.saveTanks();
                    
                    // Save to Firebase Realtime Database under company scope
                    await this.saveToFirebase(tank);
                    // Persist daily stock entry for the specified stock date
                    await this.saveDailyStockEntry(tank);
                    
                    this.renderTanks();
                    this.hideModal();
                    
                    this.showNotification('success', 'Tank status record created successfully!');
                } catch (error) {
                    console.error('Error creating tank record:', error);
                    this.showNotification('error', 'Failed to create tank record. Please try again.');
                }
            }

            async saveToFirebase(tank) {
                try {
                    // Get current user's company ID
                    const currentUser = window.authManager?.currentUser;
                    if (!currentUser || !currentUser.companyId) {
                        console.warn('No company ID found for current user');
                        return;
                    }

                    const companyId = currentUser.companyId;
                    console.log('Saving fuel storage tank to Firebase for company:', companyId);
                    
                    // Get Firebase database reference - use global functions or direct Firebase access
                    let db, tankRef;
                    
                    if (window.getDatabase && window.ref && window.set) {
                        // Use exposed functions from centralized system
                        db = window.getDatabase();
                        tankRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatus/${tank.id}`);
                        await window.set(tankRef, tank);
                    } else if (window.firebase) {
                        // Fallback to direct Firebase access
                        console.log('Using direct Firebase access for saving fuel storage data');
                        db = window.firebase.database();
                        tankRef = db.ref(`companies/${companyId}/fuelmanagement/storageStatus/${tank.id}`);
                        await tankRef.set(tank);
                    } else {
                        throw new Error('Firebase not available');
                    }
                    
                    console.log('âœ… Fuel storage tank saved to Firebase successfully');
                    
                    // Also update the company's fuel management summary/stats if needed
                    await this.updateFuelManagementStats(companyId, tank);
                    
                } catch (error) {
                    console.error('âŒ Error saving to Firebase:', error);
                    throw error; // Re-throw to trigger error notification
                }
            }

            // Save or update a per-day stock snapshot for a tank
            async saveDailyStockEntry(tank) {
                try {
                    const currentUser = window.authManager?.currentUser;
                    if (!currentUser || !currentUser.companyId) {
                        console.warn('No company ID found for current user');
                        return;
                    }
                    if (!tank?.tankId) {
                        console.warn('Cannot save daily entry: missing tankId');
                        return;
                    }

                    // Derive yyyy-mm-dd date key from stockDate (input type=date already yyyy-mm-dd)
                    let dateKey = '';
                    if (tank.stockDate) {
                        if (typeof tank.stockDate === 'string') {
                            // Expecting YYYY-MM-DD or YYYY-MM-DDTHH:MM from datetime-local
                            dateKey = tank.stockDate.slice(0, 10);
                        } else {
                            dateKey = new Date(tank.stockDate).toISOString().slice(0, 10);
                        }
                    } else {
                        dateKey = new Date().toISOString().slice(0, 10);
                    }

                    const dailyEntry = {
                        date: dateKey,
                        tankId: tank.tankId,
                        tankIdDisplay: tank.tankIdDisplay || tank.tankId,
                        location: tank.location || null,
                        fuelType: tank.fuelType || null,
                        maxVolume: Number(tank.maxVolume) || 0,
                        currentVolume: Number(tank.currentVolume) || 0,
                        reception: (typeof tank.reception === 'number' && !isNaN(tank.reception)) ? Number(tank.reception) : 0,
                        physicalClosingStock: (typeof tank.physicalClosingStock === 'number' && !isNaN(tank.physicalClosingStock)) ? Number(tank.physicalClosingStock) : null,
                        ullage: Math.max(0, Number(tank.ullage) || 0),
                        capacityPercentage: Number(tank.capacityPercentage) || 0,
                        status: tank.status || null,
                        recordedAt: new Date().toISOString(),
                        recordedBy: window.authManager?.currentUser?.email || 'Unknown'
                    };

                    const companyId = currentUser.companyId;

                    let db, entryRef;
                    if (window.getDatabase && window.ref && window.set) {
                        db = window.getDatabase();
                        entryRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatusDaily/${tank.tankId}/${dateKey}`);
                        await window.set(entryRef, dailyEntry);
                    } else if (window.firebase) {
                        db = window.firebase.database();
                        entryRef = db.ref(`companies/${companyId}/fuelmanagement/storageStatusDaily/${tank.tankId}/${dateKey}`);
                        await entryRef.set(dailyEntry);
                    } else {
                        throw new Error('Firebase not available');
                    }

                    // Optional toast message, keep quiet to avoid duplicate notices with main save
                    console.log(`âœ… Daily stock entry saved for tank ${tank.tankId} on ${dateKey}`);
                } catch (e) {
                    console.error('âŒ Error saving daily stock entry:', e);
                    // Don't block the main flow on daily entry failure
                }
            }

            async updateFuelManagementStats(companyId, tank) {
                try {
                    const db = getDatabase();
                    const statsRef = ref(db, `companies/${companyId}/fuelmanagement/statistics`);
                    
                    // Get current stats
                    const statsSnapshot = await get(statsRef);
                    const currentStats = statsSnapshot.exists() ? statsSnapshot.val() : {};
                    
                    // Update storage stats
                    const storageStats = currentStats.storageStatus || {
                        totalTanks: 0,
                        totalCapacity: 0,
                        totalCurrentVolume: 0,
                        lastUpdate: null
                    };
                    
                    storageStats.totalTanks += 1;
                    storageStats.totalCapacity += tank.maxVolume;
                    storageStats.totalCurrentVolume += tank.currentVolume;
                    storageStats.lastUpdate = tank.lastUpdated;
                    
                    // Update fuel type statistics
                    const fuelTypeStats = currentStats.fuelTypes || {};
                    if (!fuelTypeStats[tank.fuelType]) {
                        fuelTypeStats[tank.fuelType] = {
                            totalCapacity: 0,
                            totalCurrentVolume: 0,
                            tankCount: 0
                        };
                    }
                    fuelTypeStats[tank.fuelType].totalCapacity += tank.maxVolume;
                    fuelTypeStats[tank.fuelType].totalCurrentVolume += tank.currentVolume;
                    fuelTypeStats[tank.fuelType].tankCount += 1;
                    
                    // Save updated stats
                    const updatedStats = {
                        ...currentStats,
                        storageStatus: storageStats,
                        fuelTypes: fuelTypeStats,
                        lastUpdated: new Date().toISOString()
                    };
                    
                    await set(statsRef, updatedStats);
                    console.log('âœ… Fuel management statistics updated');
                    
                } catch (error) {
                    console.error('âŒ Error updating fuel management stats:', error);
                    // Don't throw error here as stats update is not critical
                }
            }

            saveTanks() {
                localStorage.setItem('fuelStorageTanks', JSON.stringify(this.tanks));
            }

            renderTanks() {
                const tableBody = document.getElementById('storageTableBody');
                const emptyState = document.getElementById('storageEmptyState');
                const tableContainer = document.querySelector('.table-container');
                
                if (!tableBody) return;

                if (this.tanks.length === 0) {
                    tableContainer.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }

                tableContainer.style.display = 'block';
                emptyState.style.display = 'none';
                
                // Update Tank ID filter dropdown
                this.updateTankIdFilter();
                
                tableBody.innerHTML = '';
                // Sort by Stock Date (newest first). Fallback to lastUpdated/createdAt when missing.
                const sortedTanks = [...this.tanks].sort((a, b) => {
                    const da = new Date(a.stockDate || a.lastUpdated || a.createdAt || 0).getTime();
                    const db = new Date(b.stockDate || b.lastUpdated || b.createdAt || 0).getTime();
                    return db - da; // descending
                });

                sortedTanks.forEach(tank => {
                    const row = this.createTankRow(tank);
                    tableBody.appendChild(row);
                });
            }

            updateTankIdFilter() {
                const tankIdFilter = document.getElementById('tankIdFilter');
                if (!tankIdFilter) return;
                
                // Get current selected value to preserve it
                const currentValue = tankIdFilter.value;
                
                // Get unique tank IDs from current tanks
                const tankIds = [...new Set(this.tanks.map(tank => tank.tankIdDisplay || tank.tankId).filter(Boolean))];
                tankIds.sort(); // Sort alphabetically
                
                // Clear existing options except "All Tanks"
                tankIdFilter.innerHTML = '<option value="">All Tanks</option>';
                
                // Add tank options
                tankIds.forEach(tankId => {
                    const option = document.createElement('option');
                    option.value = tankId;
                    option.textContent = tankId;
                    tankIdFilter.appendChild(option);
                });
                
                // Restore previous selection if it still exists
                if (currentValue && tankIds.includes(currentValue)) {
                    tankIdFilter.value = currentValue;
                }
            }

            createTankRow(tank) {
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                row.addEventListener('click', () => this.viewTank(tank.id));
                
                const capacityPercentage = tank.capacityPercentage;

                // Compute closing stock as Opening + Reception âˆ’ Distributions up to end of tank's stock date
                const stockKey = tank.tankId || tank.tankIdDisplay;
                const opening = (typeof tank.baselineVolumeAtStockDate === 'number')
                    ? Number(tank.baselineVolumeAtStockDate)
                    : Number(tank.currentVolume || 0);
                const reception = Number(tank.reception || 0);
                
                // Calculate closing stock based on distributions for the previous day of this tank's stock date
                let closingStock = opening + reception;
                let distributionsOnDate = 0;
                
                try {
                    const companyId = window.authManager?.getCurrentUser?.()?.companyId || window.authManager?.currentUser?.companyId;
                    if (companyId && window.firebase) {
                        // Accept cache from either window or local scope
                        const cacheObj = (window._anAllDistributionsCache && window._anAllDistributionsCache.data)
                            ? window._anAllDistributionsCache
                            : (typeof _anAllDistributionsCache !== 'undefined' && _anAllDistributionsCache?.data ? _anAllDistributionsCache : null);
                        const distributions = cacheObj ? cacheObj.data : null;
                        if (distributions) {
                            // Normalize target day as YYYY-MM-DD string (prefer stockDate; fallback to today)
                            const toYMD = d => {
                                const y = d.getFullYear();
                                const m = String(d.getMonth() + 1).padStart(2, '0');
                                const da = String(d.getDate()).padStart(2, '0');
                                return `${y}-${m}-${da}`;
                            };
                            // Determine the previous calendar day relative to the stock date (or yesterday if none)
                            const baseDate = tank.stockDate ? new Date(tank.stockDate) : new Date();
                            const prevDate = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate() - 1, 0, 0, 0, 0);
                            const targetYMD = toYMD(prevDate);
                            
                            const norm = v => (v === undefined || v === null) ? '' : String(v).trim().toLowerCase();
                            const stockKeyNorm = norm(stockKey);
                            Object.values(distributions).forEach(dist => {
                                try {
                                    if (!dist || !dist.fuel) return;
                                    // Build candidate tank identifiers from various possible fields
                                    const candidates = [
                                        dist.equipment?.location,
                                        dist.equipment?.locationName,
                                        dist.tankId,
                                        dist.tankName,
                                        dist.sourceTankName,
                                        dist.tank,
                                        dist.storage?.tankName,
                                        dist.storage?.tank,
                                        dist.fromTankName,
                                        dist.fromTank,
                                    ].map(norm).filter(Boolean);
                                    if (!candidates.length) return;
                                    if (!candidates.includes(stockKeyNorm)) return;

                                    // Resolve distribution day string robustly
                                    let distYMD = null;
                                    const sDate = dist.schedule?.date;
                                    if (typeof sDate === 'string' && sDate.trim()) {
                                        const sd = sDate.trim();
                                        if (/^\d{4}-\d{2}-\d{2}$/.test(sd)) {
                                            distYMD = sd; // already YYYY-MM-DD
                                        } else {
                                            const parsed = new Date(sd);
                                            if (!isNaN(parsed)) distYMD = toYMD(parsed);
                                        }
                                    }
                                    if (!distYMD && dist.timestamp) {
                                        const dt = new Date(dist.timestamp);
                                        if (!isNaN(dt)) distYMD = toYMD(dt);
                                    }
                                    if (!distYMD) return;
                                    if (distYMD === targetYMD) {
                                        const qty = Number(dist.fuel?.quantity ?? dist.fuel?.requestedQuantity) || 0;
                                        distributionsOnDate += qty;
                                    }
                                } catch (_) { /* ignore bad record */ }
                            });
                        }
                    }
                } catch {}
                
                const currentStockValue = Math.max(0, closingStock - distributionsOnDate);
                const ullageFromCurrentStock = Math.max(0, (tank.maxVolume || 0) - (currentStockValue || 0));
                // Compute numeric physical stock safely
                const physicalNum = (typeof tank.physicalClosingStock === 'number' && !isNaN(tank.physicalClosingStock))
                    ? Number(tank.physicalClosingStock)
                    : (Number(String(tank.physicalClosingStock ?? '').replace(/[^0-9.\-]/g, '')) || 0);
                const varianceNum = Number(currentStockValue || 0) - physicalNum;
                
                // Determine progress bar class and status badge
                let progressClass = 'progress-normal';
                let statusClass = 'status-normal';
                
                if (capacityPercentage >= 95) {
                    progressClass = 'progress-full';
                    statusClass = 'status-full';
                } else if (capacityPercentage >= 80) {
                    progressClass = 'progress-normal';
                    statusClass = 'status-normal';
                } else if (capacityPercentage >= 20) {
                    progressClass = 'progress-warning';
                    statusClass = 'status-warning';
                } else {
                    progressClass = 'progress-critical';
                    statusClass = 'status-critical';
                }

                // Determine last update display
                let lastUpdateDisplay = 'Manual';
                let lastUpdateClass = 'text-gray-600';
                
                if (tank.consumptionBasedUpdate && tank.lastVolumeUpdate) {
                    const updateTime = new Date(tank.lastVolumeUpdate);
                    const now = new Date();
                    const diffMinutes = Math.floor((now - updateTime) / (1000 * 60));
                    
                    if (diffMinutes < 60) {
                        lastUpdateDisplay = `${diffMinutes}m ago (Auto)`;
                        lastUpdateClass = 'text-green-600';
                    } else if (diffMinutes < 1440) { // Less than 24 hours
                        const hours = Math.floor(diffMinutes / 60);
                        lastUpdateDisplay = `${hours}h ago (Auto)`;
                        lastUpdateClass = 'text-green-600';
                    } else {
                        lastUpdateDisplay = updateTime.toLocaleDateString() + ' (Auto)';
                        lastUpdateClass = 'text-blue-600';
                    }
                } else if (tank.lastUpdated) {
                    const updateTime = new Date(tank.lastUpdated);
                    lastUpdateDisplay = updateTime.toLocaleDateString();
                    lastUpdateClass = 'text-gray-600';
                }

                // Prepare normalized stock date for filtering (YYYY-MM-DD)
                const stockDateObj = tank.stockDate ? new Date(tank.stockDate) : null;
                const stockYMD = (stockDateObj && !isNaN(stockDateObj))
                    ? `${stockDateObj.getFullYear()}-${String(stockDateObj.getMonth() + 1).padStart(2, '0')}-${String(stockDateObj.getDate()).padStart(2, '0')}`
                    : '';

                row.innerHTML = `
                    <td style="text-align:center;">
                        <input type="checkbox" class="row-select" data-id="${tank.id}" aria-label="Select row" onclick="event.stopPropagation();" />
                    </td>
                    <td>
            <strong style="color: #3b82f6; cursor: pointer;" 
                onclick="event.stopPropagation(); viewTankDistributions('${tank.tankId || tank.tankIdDisplay}', true, '${tank.stockDate || ''}', ${Number(tank.currentVolume || 0)}); switchTab('details');" 
                                title="Click to view distributions for this tank">
                            ${(tank.tankIdDisplay || tank.tankId || '')}
                        </strong>
                    </td>
                    <td class="hidden-col"><span class="bg-purple-100 text-purple-800 px-2 py-1 rounded-full text-xs font-medium">${tank.fuelType}</span></td>
                    <td class="hidden-col">${tank.maxVolume.toLocaleString()}</td>
                    <td title="Opening stock at start of day">${tank.currentVolume.toLocaleString()}</td>
                    <td title="Total distributions applied (previous day)">${distributionsOnDate.toLocaleString()}</td>
                    <td title="Opening + Reception âˆ’ Distributions on ${(function(){ const b=tank.stockDate? new Date(tank.stockDate): new Date(); const p=new Date(b.getFullYear(), b.getMonth(), b.getDate()-1); return p.toLocaleDateString(); })()} = Closing Stock">${currentStockValue.toLocaleString()}</td>
                    <td title="Manual measured stock at end of day">${(typeof tank.physicalClosingStock === 'number' && !isNaN(tank.physicalClosingStock)) ? Number(tank.physicalClosingStock).toLocaleString() : (tank.physicalClosingStock || '-')}</td>
                    <td title="Variance = Closing - Physical" ${varianceNum < 0 ? 'style="color:#b91c1c;font-weight:600;"' : ''}>${varianceNum.toLocaleString()}</td>
                    <td>
                        <div class="progress-bar">
                            <div class="progress-fill ${progressClass}" style="width: ${capacityPercentage}%">
                                ${capacityPercentage.toFixed(1)}%
                            </div>
                        </div>
                    </td>
                    <td data-ymd="${stockYMD}" title="${stockDateObj ? stockDateObj.toLocaleString() : ''}">${stockDateObj ? stockDateObj.toLocaleDateString() : 'N/A'}</td>
                    <td class="hidden-col">${ullageFromCurrentStock.toLocaleString()}</td>
                    <td class="hidden-col"><span class="status-badge ${statusClass}">${tank.status}</span></td>
                    <td data-ymd="${(tank.lastUpdated ? (()=>{const d=new Date(tank.lastUpdated);return isNaN(d)?'':`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;})() : '')}">
                        <span class="text-xs font-medium ${lastUpdateClass}" title="${tank.consumptionBasedUpdate ? 'Automatically updated based on consumption' : 'Manually updated'}">
                            ${lastUpdateDisplay}
                        </span>
                    </td>
                    <td class="hidden-col"><span class="text-purple-700 text-xs">Click row to view</span></td>
                `;

                return row;
            }

            viewTank(tankId) {
                const tank = this.tanks.find(t => t.id === tankId);
                if (!tank) return;

                const modal = document.getElementById('tankDetailsModal');
                const body = document.getElementById('tankDetailsBody');
                const title = document.getElementById('tankDetailsTitle');
                if (!modal || !body || !title) return;

                title.textContent = `Tank Details â€” ${(tank.tankIdDisplay || tank.tankId)}`;
                const stockKey = tank.tankId || tank.tankIdDisplay;
                const currentStockValue = (window._lastStockAfterByTank && ((window._lastStockAfterByTank[stockKey] ?? null) !== null))
                    ? window._lastStockAfterByTank[stockKey]
                    : (tank.currentVolume ?? 0);
                const ullageFromCurrentStock = Math.max(0, (tank.maxVolume || 0) - (currentStockValue || 0));
                const fields = [
                    { label: 'Tank ID', value: (tank.tankIdDisplay || tank.tankId) },
                    { label: 'Location', value: (window._locationDisplayMap && tank.location && window._locationDisplayMap[tank.location]) ? window._locationDisplayMap[tank.location] : (tank.location || '-') },
                    { label: 'Fuel Type', value: tank.fuelType },
                    { label: 'Max Volume (L)', value: (tank.maxVolume ?? 0).toLocaleString() },
                    { label: 'Opening Stock (L)', value: (tank.currentVolume ?? 0).toLocaleString() },
                    { label: 'Reception (L)', value: (Number(tank.reception||0)).toLocaleString() },
                    { label: 'Closing Stock (L)', value: (currentStockValue ?? 0).toLocaleString() },
                    { label: 'Physical Closing Stock (L)', value: (typeof tank.physicalClosingStock === 'number' ? Number(tank.physicalClosingStock).toLocaleString() : (tank.physicalClosingStock || '-')) },
                    { label: 'Capacity %', value: (tank.capacityPercentage ?? 0).toFixed(1) + '%' },
                    { label: 'Stock Date', value: tank.stockDate ? new Date(tank.stockDate).toLocaleString() : 'N/A' },
                    { label: 'Ullage (L)', value: ullageFromCurrentStock.toLocaleString() },
                    { label: 'Status', value: tank.status },
                    { label: 'Last Updated', value: new Date(tank.lastUpdated).toLocaleString() },
                    { label: 'Updated By', value: tank.updatedBy || '-' },
                ];

                body.innerHTML = fields.map(f => `
                    <div style="background:#f8fafc; padding:10px 12px; border:1px solid #e5e7eb; border-radius:8px;">
                        <div style="font-size:12px; color:#6b7280;">${f.label}</div>
                        <div style="font-weight:600; color:#111827;">${f.value}</div>
                    </div>
                `).join('');

                // Close and edit handlers
                const closeBtn = document.getElementById('closeTankDetailsBtn');
                const closeFooter = document.getElementById('tankDetailsCloseFooter');
                const editBtn = document.getElementById('tankDetailsEditBtn');
                const deleteBtn = document.getElementById('deleteTankBtn');
                const hide = () => modal.classList.remove('show');
                if (closeBtn) closeBtn.onclick = hide;
                if (closeFooter) closeFooter.onclick = hide;
                if (editBtn) editBtn.onclick = () => { hide(); this.openEditTank(tank.id); };
                if (deleteBtn) deleteBtn.onclick = async () => {
                    if (!confirm('Are you sure you want to delete this tank record? This action cannot be undone.')) return;
                    try {
                        await this.deleteTankRecord(tank.id);
                        hide();
                        this.showNotification('success', 'Tank record deleted successfully');
                    } catch (e) {
                        console.error('Delete failed', e);
                        this.showNotification('error', 'Failed to delete tank record');
                    }
                };
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) hide();
                }, { once: true });

                modal.classList.add('show');
            }

            showNotification(type, message) {
                const notification = document.createElement('div');
                notification.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 ${
                    type === 'success' ? 'bg-green-500 text-white' : 'bg-red-500 text-white'
                }`;
                notification.innerHTML = `
                    <div class="flex items-center">
                        <i class="fas ${type === 'success' ? 'fa-check-circle' : 'fa-exclamation-circle'} mr-2"></i>
                        ${message}
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 5000);
            }

            async deleteTankRecord(tankId) {
                // Remove locally
                this.tanks = this.tanks.filter(t => t.id !== tankId);
                this.saveTanks();
                this.renderTanks();

                // Attempt Firebase removal
                try {
                    const currentUser = window.authManager?.currentUser;
                    if (!currentUser || !currentUser.companyId) return; // silently skip if no company context
                    const companyId = currentUser.companyId;
                    let db;
                    if (window.getDatabase) {
                        db = window.getDatabase();
                        const tankRef = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatus/${tankId}`);
                        if (window.remove) await window.remove(tankRef);
                    } else if (window.firebase && window.firebase.database) {
                        db = window.firebase.database();
                        await db.ref(`companies/${companyId}/fuelmanagement/storageStatus/${tankId}`).remove();
                    }
                } catch (err) {
                    console.warn('Non-blocking: failed to remove tank from Firebase', err);
                }
            }
        }

        // Initialize the fuel storage manager when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.fuelStorageManager = new FuelStorageManager();
        });

        // Reset all menu items to hidden
        function resetMenuVisibility() {
            document.querySelectorAll('[data-feature]').forEach(item => {
                item.classList.remove('menu-visible');
            });
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                dropdown.classList.remove('menu-visible');
            });
        }

        // Emergency fallback - show basic menu items based on user permissions
        async function showBasicMenu() {
            console.log('ðŸ”§ Emergency fallback: Showing basic menu items with permission check');
            resetMenuVisibility();
            
            try {
                let currentUser = null;
                let companyId = null;
                
                // Get current user
                if (window.authManager && window.authManager.currentUser) {
                    currentUser = window.authManager.currentUser;
                    companyId = currentUser.companyId;
                } else if (firebase.auth().currentUser) {
                    currentUser = firebase.auth().currentUser;
                    // Try to get company ID from localStorage
                    const storedUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
                    companyId = storedUser.companyId;
                } else {
                    console.log('âŒ No authenticated user found - showing minimal access');
                    // Show only home for unauthenticated users
                    const homeItem = document.querySelector('[data-feature="home_view"]');
                    if (homeItem) {
                        homeItem.classList.add('menu-visible');
                    }
                    // Remove loading state
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.classList.remove('menu-loading');
                    }
                    return;
                }
                
                if (!companyId) {
                    console.log('âš ï¸ No company ID found - showing minimal access');
                    // Show only basic items without company context
                    const homeItem = document.querySelector('[data-feature="home_view"]');
                    if (homeItem) {
                        homeItem.classList.add('menu-visible');
                    }
                    // Remove loading state
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.classList.remove('menu-loading');
                    }
                    return;
                }
                
                // Get user's role and basic permissions
                const database = firebase.database();
                
                // Try to get user's role from company data
                const userCompanyRef = database.ref(`companies/${companyId}/users/${currentUser.uid}`);
                const userSnapshot = await userCompanyRef.once('value');
                const userData = userSnapshot.val();
                
                if (!userData) {
                    console.log('âš ï¸ User not found in company - showing minimal access');
                    const homeItem = document.querySelector('[data-feature="home_view"]');
                    if (homeItem) {
                        homeItem.classList.add('menu-visible');
                    }
                    // Remove loading state
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.classList.remove('menu-loading');
                    }
                    return;
                }
                
                const userRole = userData.role || 'viewer';
                console.log('ðŸ‘¤ User role for fallback menu:', userRole);
                
                // Get role permissions
                const roleRef = database.ref(`companies/${companyId}/roles/${userRole}`);
                const roleSnapshot = await roleRef.once('value');
                const roleData = roleSnapshot.val();
                
                const permissions = roleData?.permissions || {};
                console.log('ðŸ” User permissions for fallback menu:', permissions);
                
                // Show menu items based on role permissions
                const menuItems = document.querySelectorAll('#roleBasedMenu li[data-feature]');
                let visibleCount = 0;
                
                menuItems.forEach(menuItem => {
                    const featureAttribute = menuItem.getAttribute('data-feature');
                    const requiredPermission = menuItem.getAttribute('data-requires-permission');
                    const isDropdownContainer = menuItem.classList.contains('menu-dropdown');
                    
                    if (isDropdownContainer) {
                        return; // Handle dropdowns separately
                    }
                    
                    // Check if user has permission for this menu item
                    let hasPermission = false;
                    
                    if (requiredPermission && permissions[requiredPermission] === true) {
                        hasPermission = true;
                    } else if (!requiredPermission && featureAttribute) {
                        // For items without specific permission requirements, check basic access
                        // Always show home, communication, and account settings
                        if (['home_view', 'communication_view', 'account_settings_view'].includes(featureAttribute)) {
                            hasPermission = true;
                        }
                    }
                    
                    if (hasPermission) {
                        menuItem.classList.add('menu-visible');
                        visibleCount++;
                        console.log(`âœ… Permission granted - showing menu item: ${featureAttribute}`);
                    } else {
                        menuItem.classList.remove('menu-visible');
                        console.log(`âŒ Permission denied - hiding menu item: ${featureAttribute}`);
                    }
                });
                
                // Handle dropdown menus - show if they have visible children
                const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
                dropdownMenus.forEach(dropdown => {
                    const dropdownFeature = dropdown.getAttribute('data-feature');
                    const dropdownPermission = dropdown.getAttribute('data-requires-permission');
                    const submenuItems = dropdown.querySelectorAll('.submenu li[data-feature]');
                    let hasVisibleChildren = false;
                    let hasDropdownPermission = false;
                    
                    // Check if dropdown itself has permission
                    if (dropdownPermission && permissions[dropdownPermission] === true) {
                        hasDropdownPermission = true;
                    }
                    
                    // Check for visible children
                    submenuItems.forEach(submenuItem => {
                        if (submenuItem.classList.contains('menu-visible')) {
                            hasVisibleChildren = true;
                        }
                    });
                    
                    if (hasVisibleChildren || hasDropdownPermission) {
                        dropdown.classList.add('menu-visible');
                        console.log(`âœ… Showing dropdown menu: ${dropdownFeature} (has visible children or permission)`);
                    } else {
                        dropdown.classList.remove('menu-visible');
                        console.log(`âŒ Hiding dropdown menu: ${dropdownFeature} (no visible children or permission)`);
                    }
                });
                
                console.log(`ðŸŽ¯ Permission-based fallback menu completed - ${visibleCount} items visible`);
                
                // Remove loading state
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) {
                    sidebar.classList.remove('menu-loading');
                }
                
            } catch (error) {
                console.error('âŒ Error in permission-based fallback menu:', error);
                // Ultimate fallback - show only home
                const homeItem = document.querySelector('[data-feature="home_view"]');
                if (homeItem) {
                    homeItem.classList.add('menu-visible');
                }
                
                // Remove loading state even in error case
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) {
                    sidebar.classList.remove('menu-loading');
                }
            }
        }

        // Feature-based authorization system that takes priority over role permissions
        async function updateMenuWithFeatureAuthorization() {
            console.log('ðŸŽ¯ Starting feature + role-based menu authorization for fuelstor.html...');
            try {
                let currentUser = null;
                let companyId = null;
                let userRole = null;

                if (window.authManager && window.authManager.currentUser) {
                    currentUser = window.authManager.currentUser;
                    companyId = currentUser.companyId;
                    userRole = currentUser.role;
                    console.log('ðŸ‘¤ Using AuthManager - User:', currentUser.email, 'Company ID:', companyId, 'Role:', userRole);
                } else if (firebase.auth().currentUser) {
                    currentUser = firebase.auth().currentUser;
                    console.log('ðŸ‘¤ Using Firebase auth - will search for company and role');
                } else {
                    console.log('âŒ No authenticated user found');
                    await showBasicMenu();
                    return;
                }

                // Find company and role if needed
                if ((!companyId || !userRole) && currentUser) {
                    console.log('ðŸ” Searching for user company and role...');
                    const database = firebase.database();
                    const companiesRef = database.ref('companies');
                    const companiesSnapshot = await companiesRef.once('value');

                    if (companiesSnapshot.exists()) {
                        const companies = companiesSnapshot.val();
                        for (const [cId, company] of Object.entries(companies)) {
                            if (company.status !== 'active') continue;
                            if (company.users && company.users[currentUser.uid]) {
                                companyId = companyId || cId;
                                userRole = userRole || company.users[currentUser.uid].role || company.users[currentUser.uid].userRole;
                                console.log(`âœ… Found user in company: ${companyId} (${company.name}) with role: ${userRole}`);
                                break;
                            }
                        }
                    }
                }

                if (!companyId) {
                    console.error('âŒ No company ID found, cannot determine authorized features');
                    await showBasicMenu();
                    return;
                }

                // STEP 1: Company feature-based authorization
                const authorizedPages = await applyFeatureBasedMenuVisibility(companyId);

                // STEP 2: Role-based filtering within authorized features
                if (userRole) {
                    await applyRoleBasedFiltering(companyId, userRole, authorizedPages || []);
                }
            } catch (error) {
                console.error('âŒ Error in feature-based menu authorization:', error);
                await showBasicMenu();
            }
        }

        // Apply feature-based menu visibility
        async function applyFeatureBasedMenuVisibility(companyId) {
            try {
                console.log('ðŸ”§ Applying feature-based menu visibility for company:', companyId);
                
                // Get platform features
                const database = firebase.database();
                const featuresSnapshot = await database.ref('/platformFeatures').once('value');
                
                if (!featuresSnapshot.exists()) {
                    console.log('âš ï¸ No platform features found');
                    resetMenuVisibility();
                    // Remove loading state
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.classList.remove('menu-loading');
                    }
                    return;
                }
                
                const featuresData = featuresSnapshot.val();
                
                // Get company's selected features
                const companySnapshot = await database.ref(`/companies/${companyId}`).once('value');
                const companyData = companySnapshot.val();
                
                if (!companyData) {
                    console.error('âŒ Company data not found');
                    resetMenuVisibility();
                    // Remove loading state
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.classList.remove('menu-loading');
                    }
                    return;
                }
                
                const subscribedFeatureIds = companyData.selectedFeatures || [];
                console.log('ðŸ¢ Company subscribed features:', subscribedFeatureIds);
                
                if (subscribedFeatureIds.length === 0) {
                    console.log('âš ï¸ Company has no subscribed features');
                    resetMenuVisibility();
                    // Remove loading state
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.classList.remove('menu-loading');
                    }
                    return;
                }
                
                // Collect authorized pages from subscribed features
                const authorizedPages = [];
                subscribedFeatureIds.forEach(featureId => {
                    const feature = featuresData[featureId];
                    if (feature && feature.status === 'active' && feature.authorizedPages) {
                        console.log(`ðŸ“¦ Adding pages from feature "${feature.name}":`, feature.authorizedPages);
                        authorizedPages.push(...feature.authorizedPages);
                    } else {
                        console.log(`âš ï¸ Feature ${featureId} not found or inactive`);
                    }
                });
                
                console.log('ðŸ” All authorized pages:', authorizedPages);
                
                // Reset all menu items first
                resetMenuVisibility();
                
                // Create set of authorized features
                const authorizedFeatures = new Set();
                authorizedPages.forEach(pageInfo => {
                    if (pageInfo.feature) {
                        authorizedFeatures.add(pageInfo.feature);
                    }
                });
                
                console.log('ðŸŽ¯ Authorized features for fuelstor.html:', Array.from(authorizedFeatures));
                
                // Apply menu visibility
                const allMenuItems = document.querySelectorAll('#roleBasedMenu li[data-feature]');
                let visibleCount = 0;
                
                allMenuItems.forEach(menuItem => {
                    const featureAttribute = menuItem.getAttribute('data-feature');
                    const isAuthorized = authorizedFeatures.has(featureAttribute);
                    const isDropdownContainer = menuItem.classList.contains('menu-dropdown');
                    
                    if (isDropdownContainer) {
                        return; // Handle dropdowns separately after all items are processed
                    }
                    
                    if (isAuthorized) {
                        menuItem.classList.add('menu-visible');
                        visibleCount++;
                        console.log(`âœ… Feature authorized - showing menu item: ${featureAttribute}`);
                    } else {
                        menuItem.classList.remove('menu-visible');
                        console.log(`âŒ Feature not authorized - hiding menu item: ${featureAttribute}`);
                    }
                });
                
                // Handle dropdown menus - show if they have visible children
                const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
                dropdownMenus.forEach(dropdown => {
                    const dropdownFeature = dropdown.getAttribute('data-feature');
                    const submenuItems = dropdown.querySelectorAll('.submenu li[data-feature]');
                    let hasVisibleChildren = false;
                    
                    submenuItems.forEach(submenuItem => {
                        if (submenuItem.classList.contains('menu-visible')) {
                            hasVisibleChildren = true;
                        }
                    });
                    
                    if (hasVisibleChildren || authorizedFeatures.has(dropdownFeature)) {
                        dropdown.classList.add('menu-visible');
                        console.log(`âœ… Showing dropdown menu: ${dropdownFeature} (has visible children or directly authorized)`);
                    } else {
                        dropdown.classList.remove('menu-visible');
                        console.log(`âŒ Hiding dropdown menu: ${dropdownFeature} (no visible children and not authorized)`);
                    }
                });
                
                console.log(`ðŸŽ¯ Feature-based menu authorization completed for fuelstor.html - ${visibleCount} items visible`);
                // Return authorized pages for optional role-based filtering
                return authorizedPages;

            } catch (error) {
                console.error('âŒ Error applying feature-based menu visibility:', error);
                resetMenuVisibility();
                return [];
            }
        }

        // Apply role-based filtering within company authorized features
        async function applyRoleBasedFiltering(companyId, userRole, authorizedPages) {
            try {
                console.log('ðŸ‘¤ Applying role-based filtering for role:', userRole);
                const database = firebase.database();
                const permissionsRef = database.ref(`companies/${companyId}/roles/${userRole}/permissions`);
                const permissionsSnapshot = await permissionsRef.once('value');

                if (!permissionsSnapshot.exists()) {
                    console.log(`âš ï¸ No permissions found for role ${userRole} in company ${companyId}`);

                    const allRolesRef = database.ref(`companies/${companyId}/roles`);
                    const allRolesSnapshot = await allRolesRef.once('value');
                    if (allRolesSnapshot.exists()) {
                        const allRoles = allRolesSnapshot.val();
                        if (userRole === 'administrator') {
                            if (allRoles.administrator && allRoles.administrator.permissions) {
                                filterMenuByPermissions(allRoles.administrator.permissions);
                                return;
                            }
                        }

                        const roleKeys = Object.keys(allRoles);
                        const matchingRole = roleKeys.find(key =>
                            key.toLowerCase() === userRole.toLowerCase() ||
                            key.replace(/\s+/g, '').toLowerCase() === userRole.replace(/\s+/g, '').toLowerCase()
                        );
                        if (matchingRole && allRoles[matchingRole].permissions) {
                            filterMenuByPermissions(allRoles[matchingRole].permissions);
                            return;
                        }
                    }

                    if (userRole === 'administrator') {
                        console.log('ðŸ”‘ ADMINISTRATOR FALLBACK - Skipping role filtering (keeping all company features visible)');
                        showSidebarAfterAuth();
                        return;
                    }

                    console.log('âŒ No valid permissions found - filtering out items requiring permissions');
                    hideItemsRequiringPermissions();
                    showSidebarAfterAuth();
                    return;
                }

                const permissions = permissionsSnapshot.val();
                filterMenuByPermissions(permissions);
            } catch (error) {
                console.error('âŒ Error applying role-based filtering:', error);
                showSidebarAfterAuth();
            }
        }

        // Filter currently visible menu items by role permissions
        function filterMenuByPermissions(permissions) {
            console.log('ðŸ” Filtering visible menu items by role permissions...');
            if (!permissions) {
                hideItemsRequiringPermissions();
                showSidebarAfterAuth();
                return;
            }
            const visibleMenuItems = document.querySelectorAll('#roleBasedMenu li.menu-visible[data-requires-permission]');
            visibleMenuItems.forEach(item => {
                const requiresPermission = item.getAttribute('data-requires-permission');
                const has = permissions[requiresPermission];
                const hasView = has === true || (has && has.view === true);
                if (!hasView) {
                    item.classList.remove('menu-visible');
                }
            });

            // Re-check dropdowns
            const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
            dropdownMenus.forEach(dropdown => {
                const childrenVisible = dropdown.querySelectorAll('.submenu li.menu-visible').length > 0;
                const dropdownRequires = dropdown.getAttribute('data-requires-permission');
                if (!childrenVisible) {
                    if (dropdownRequires) {
                        const has = permissions[dropdownRequires];
                        const hasView = has === true || (has && has.view === true);
                        if (!hasView) dropdown.classList.remove('menu-visible');
                    } else {
                        dropdown.classList.remove('menu-visible');
                    }
                }
            });

            ensureHomeIsVisible();
            showSidebarAfterAuth();
        }

        function hideItemsRequiringPermissions() {
            const items = document.querySelectorAll('#roleBasedMenu li.menu-visible[data-requires-permission]');
            items.forEach(item => item.classList.remove('menu-visible'));
            const dropdownMenus = document.querySelectorAll('#roleBasedMenu li.menu-dropdown');
            dropdownMenus.forEach(dropdown => {
                const childrenVisible = dropdown.querySelectorAll('.submenu li.menu-visible').length > 0;
                if (!childrenVisible) dropdown.classList.remove('menu-visible');
            });
            ensureHomeIsVisible();
        }

        function ensureHomeIsVisible() {
            const homeItem = document.querySelector('#roleBasedMenu li[data-feature="home_view"]');
            if (homeItem && !homeItem.classList.contains('menu-visible')) {
                homeItem.classList.add('menu-visible');
            }
        }

        function showSidebarAfterAuth() {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) sidebar.classList.remove('menu-loading');
        }

        // Make updateMenuWithFeatureAuthorization available globally
        window.updateMenuWithFeatureAuthorization = updateMenuWithFeatureAuthorization;

        // Firebase auth state observer to refresh branding on login/logout
        firebase.auth().onAuthStateChanged(async (user) => {
            console.log('ðŸ”¥ Auth state changed:', user ? user.email : 'logged out');
            
            if (user && window.fuelStorageManager) {
                // User logged in - refresh company branding
                try {
                    await window.fuelStorageManager.loadCompanyAndBranding();
                } catch (error) {
                    console.warn('âš ï¸ Error refreshing branding after auth change:', error);
                }
                // Refresh menu authorization
                try {
                    resetMenuVisibility();
                    await updateMenuWithFeatureAuthorization();
                } catch (e) {
                    console.warn('âš ï¸ Menu auth refresh failed, showing basic menu', e);
                    await showBasicMenu();
                } finally {
                    document.querySelector('.sidebar')?.classList.remove('menu-loading');
                }
            } else if (!user) {
                // User logged out - clear branding
                const headerLogo = document.getElementById('headerCompanyLogo');
                const headerLogoPlaceholder = document.getElementById('headerLogoPlaceholder');
                const headerCompanyName = document.getElementById('headerCompanyName');
                
                if (headerCompanyName) headerCompanyName.textContent = '';
                if (headerLogo) headerLogo.style.display = 'none';
                if (headerLogoPlaceholder) headerLogoPlaceholder.style.display = 'flex';
            }
        });

        // Tab Management Functions
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
                tab.style.display = 'none';
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab content
            const targetTab = document.getElementById(tabName + 'Tab');
            if (targetTab) {
                targetTab.classList.add('active');
                targetTab.style.display = 'block';
            }

            // Activate selected tab button
            const targetBtn = document.querySelector(`[data-tab="${tabName}"]`);
            if (targetBtn) {
                targetBtn.classList.add('active');
            }

            // Load data if switching to details tab
            if (tabName === 'details') {
                loadDistributionDetails();
            }
            // Initialize analytics when opened
            if (tabName === 'analytics') {
                initAnalyticsTab();
            }
            if (tabName === 'visualization') {
                initVisualizationTab();
            }
        }

        // Load distribution details grouped by tank
        async function loadDistributionDetails() {
            try {
                const companyId = window.authManager?.getCurrentUser()?.companyId;
                if (!companyId) {
                    console.log('No company ID found for distribution details');
                    showDetailsEmptyState(true);
                    return;
                }

                // Get date filter
                const daysFilter = parseInt(document.getElementById('detailsDateFilter').value) || 30;
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - daysFilter);

                // Load distributions from Firebase
                const distributionsRef = firebase.database().ref(`fuelDistributions/${companyId}`);
                const snapshot = await distributionsRef.once('value');

                if (!snapshot.exists()) {
                    showDetailsEmptyState(true);
                    return;
                }

                const distributions = snapshot.val();
                const tankStats = {};

                // Group distributions by tank location (use consumption date/time from schedule when available)
                Object.values(distributions).forEach(dist => {
                    if (!dist || !dist.equipment || !dist.fuel) return;

                    let consISO = null;
                    try {
                        if (dist.schedule && dist.schedule.date && dist.schedule.time) {
                            consISO = new Date(`${dist.schedule.date}T${dist.schedule.time}`).toISOString();
                        }
                    } catch (e) { /* ignore */ }
                    const effectiveISO = consISO || dist.timestamp;
                    if (!effectiveISO) return;

                    const distDate = new Date(effectiveISO);
                    if (distDate < cutoffDate) return;

                    const tankId = dist.equipment.location || dist.equipment.locationName || 'Unknown';
                    const quantity = parseFloat(dist.fuel.requestedQuantity) || 0;

                    if (!tankStats[tankId]) {
                        tankStats[tankId] = {
                            tankId: tankId,
                            totalDistributions: 0,
                            totalVolume: 0,
                            lastDistribution: null
                        };
                    }

                    tankStats[tankId].totalDistributions++;
                    tankStats[tankId].totalVolume += quantity;
                    
                    if (!tankStats[tankId].lastDistribution || new Date(effectiveISO) > new Date(tankStats[tankId].lastDistribution)) {
                        tankStats[tankId].lastDistribution = effectiveISO;
                    }
                });

                renderDistributionDetails(Object.values(tankStats));

            } catch (error) {
                console.error('Error loading distribution details:', error);
                showDetailsEmptyState(true);
            }
        }

        // Render distribution details table
        function renderDistributionDetails(tankStats) {
            const tbody = document.getElementById('distributionDetailsBody');
            
            if (!tankStats || tankStats.length === 0) {
                showDetailsEmptyState(true);
                return;
            }

            showDetailsEmptyState(false);

            tbody.innerHTML = tankStats.map(tank => `
                <tr>
                    <td style="font-weight: 600; color: #1e293b;">${tank.tankIdDisplay || ((window._tankIdDisplayMap && window._tankIdDisplayMap[tank.tankId]) ? window._tankIdDisplayMap[tank.tankId] : (tank.tankId || ''))}</td>
                    <td style="color: #374151;">${tank.totalDistributions}</td>
                    <td style="font-weight: 500; color: #059669;">${tank.totalVolume.toLocaleString()} L</td>
                    <td style="color: #6b7280; font-size: 0.85rem;">
                        ${tank.lastDistribution ? new Date(tank.lastDistribution).toLocaleDateString() : 'N/A'}
                    </td>
                    <td>
                        <button class="btn btn-sm" onclick="viewTankDistributions('${tank.tankId}', true)" 
                                style="background: #3b82f6; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem;">
                            View Details
                        </button>
                    </td>
                </tr>
            `).join('');
        }

    // =============== Analytics (Charts & Pivot) ===============
    let _anChartInstance = null;
    let _anAllDistributionsCache = null; // cache raw distro by company scope
    let _anStorageStatusCache = null; // cache storage status (tanks) by company scope
    let _anLastChartData = null; // cache last chart for exports
    let _anTankIdToLocation = null; // tankId/display -> friendly location from Add Tank Status
    // Selection filters for displayed series and categories (x-axis labels)
    let _anSelectedSeries = null; // Set<string> or null for all
    let _anSelectedCategories = null; // Set<string> or null for all

        async function initAnalyticsTab() {
            try {
                        await ensureAnalyticsDataLoaded();
                        populateAnalyticsFilters();
                        wireAnalyticsControls();
                        wirePivotControls();
                        await loadSavedReportsOptions?.();
                        showAnalyticsSubTab('charts');
                        renderAnalyticsFromFilters();
            } catch (e) {
                console.warn('Analytics init failed:', e);
            }
        }

        async function ensureAnalyticsDataLoaded() {
            const companyId = window.authManager?.getCurrentUser()?.companyId;
            if (!companyId) throw new Error('Missing company ID');
            const needDistro = !_anAllDistributionsCache || _anAllDistributionsCache.companyId !== companyId;
            const needStorage = !_anStorageStatusCache || _anStorageStatusCache.companyId !== companyId;
            if (!needDistro && !needStorage) return;
            const tasks = [];
            if (needDistro) tasks.push(firebase.database().ref(`fuelDistributions/${companyId}`).once('value'));
            if (needStorage) tasks.push(firebase.database().ref(`companies/${companyId}/fuelmanagement/storageStatus`).once('value'));
            const snaps = await Promise.all(tasks);
            let idx = 0;
            if (needDistro) {
                const snap = snaps[idx++];
                const distributions = snap.exists() ? snap.val() : {};
                _anAllDistributionsCache = { companyId, data: distributions };
            }
            if (needStorage) {
                const snapS = snaps[idx++];
                const storage = snapS?.exists() ? snapS.val() : {};
                _anStorageStatusCache = { companyId, data: storage };
                // Build tank -> location map (storage status only)
                try {
                    _anTankIdToLocation = {};
                    const tanks = Object.values(storage || {});
                    for (const t of tanks) {
                        if (!t) continue;
                        const tid = t.tankId || '';
                        const tdisp = t.tankIdDisplay || tid || '';
                        const locRaw = t.location || t.site || t.area || '';
                        const locLabel = friendlyLocationLabel(locRaw) || locRaw || '';
                        if (tid) _anTankIdToLocation[tid] = locLabel;
                        if (tdisp) _anTankIdToLocation[tdisp] = locLabel;
                    }
                } catch (_) { _anTankIdToLocation = {}; }
            }
        }

        // Helper: resolve a location code to a friendly label, with tank-name fallback
        function friendlyLocationLabel(raw) {
            if (!raw) return raw;
            try {
                const locMap = window._locationDisplayMap || {};
                const tankMap = window._tankIdDisplayMap || {};
                return locMap[raw] || tankMap[raw] || raw;
            } catch (_) { return raw; }
        }

            function populateAnalyticsFilters() {
            // Date defaults: last 30 days
            const end = new Date();
            const start = new Date();
            start.setDate(end.getDate() - 30);
            const fmt = (d) => d.toISOString().slice(0,10);
            document.getElementById('anStart').value = fmt(start);
            document.getElementById('anEnd').value = fmt(end);

            // Fuel types, equipment, equipment types, departments from distributions; locations come ONLY from Add Tank Status
            const dvals = Object.values(_anAllDistributionsCache?.data || {});
            const setFuel = new Set();
            const setEquip = new Map(); // id -> label
            const setEqType = new Set();
            const setDept = new Set();
            const setLoc = new Set();
            const setOperator = new Set();
            const setRequestedBy = new Set();
            const setDistStatus = new Set();
            const setIndexReading = new Set();
            dvals.forEach(d => {
                try {
                    if (!d || !d.fuel || !d.equipment) return;
                    if (d.fuel?.type) setFuel.add(d.fuel.type);
                    if (d.equipment?.type) setEqType.add(d.equipment.type);
                    if (d.authorization?.department) setDept.add(d.authorization.department);
                    if (d.equipment?.operator) setOperator.add(d.equipment.operator);
                    if (d.authorization?.requestedBy) setRequestedBy.add(d.authorization.requestedBy);
                    if (d.status) setDistStatus.add(d.status);
                    const eid = d.equipment.id || d.equipment.name || null;
                    if (eid) setEquip.set(eid, d.equipment.name || d.equipment.id || eid);
                    const idx = d.fuel?.indexReading || d.indexReading || '';
                    if (idx) setIndexReading.add(String(idx));
                } catch (_) {}
            });
            // Locations come strictly from storage status (Add Tank Status)
            try {
                const tanks = Object.values(_anStorageStatusCache?.data || {});
                const setTank = new Set();
                const setTankStatus = new Set();
                const setUpdatedBy = new Set();
                tanks.forEach(t => {
                    const loc = t.location || t.site || t.area; if (loc) setLoc.add(loc);
                    const tid = t.tankIdDisplay || t.tankId; if (tid) setTank.add(tid);
                    if (t.status) setTankStatus.add(t.status);
                    if (t.updatedBy) setUpdatedBy.add(t.updatedBy);
                });
                // fill tank-related selects
                const fillSimple = (id, set) => {
                    const sel = document.getElementById(id); if (!sel) return;
                    const cur = sel.value;
                    sel.innerHTML = `<option value="">All ${sel.title || id}</option>`;
                    Array.from(set).sort().forEach(v => { const opt=document.createElement('option'); opt.value=v; opt.textContent=v; sel.appendChild(opt); });
                    if (cur && Array.from(set).includes(cur)) sel.value = cur;
                };
                fillSimple('anTank', setTank);
                fillSimple('anTankStatus', setTankStatus);
                fillSimple('anUpdatedBy', setUpdatedBy);
            } catch (_) {}

            const fillSelect = (id, values) => {
                const sel = document.getElementById(id);
                if (!sel) return;
                const current = sel.value;
                sel.innerHTML = `<option value="">All ${sel.title || id}</option>`;
                const rawList = Array.from(values);
                if (id === 'anLocation') {
                    const locMap = window._locationDisplayMap || {};
                    const tankMap = window._tankIdDisplayMap || {};
                    const seenByLabel = new Map(); // label -> preferredValue
                    rawList.forEach(v => {
                        const label = friendlyLocationLabel(v) || v;
                        const isPreferred = !!(locMap[v] || tankMap[v]); // treat codes (known keys) as preferred over plain labels
                        if (!seenByLabel.has(label)) {
                            seenByLabel.set(label, v);
                        } else {
                            const existing = seenByLabel.get(label);
                            const existingIsPreferred = !!(locMap[existing] || tankMap[existing]);
                            if (isPreferred && !existingIsPreferred) seenByLabel.set(label, v);
                        }
                    });
                    Array.from(seenByLabel.entries()).sort((a,b)=>String(a[0]).localeCompare(String(b[0]))).forEach(([label, value]) => {
                        const opt = document.createElement('option');
                        opt.value = value; opt.textContent = label; sel.appendChild(opt);
                    });
                    // Try to retain prior selection by code or label
                    if (current) {
                        // by exact value
                        const hasValue = Array.from(seenByLabel.values()).includes(current);
                        if (hasValue) sel.value = current;
                        else {
                            // by label
                            const found = Array.from(seenByLabel.entries()).find(([label]) => label === current);
                            if (found) sel.value = found[1];
                        }
                    }
                } else {
                    rawList.sort().forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v; opt.textContent = v; sel.appendChild(opt);
                    });
                    if (current && rawList.includes(current)) sel.value = current;
                }
            };
            fillSelect('anFuelType', setFuel);
            fillSelect('anEquipment', setEquip);
            fillSelect('anEquipmentType', setEqType);
            fillSelect('anDepartment', setDept);
            fillSelect('anLocation', setLoc);
            // From distributions details
            const fillSimple2 = (id, set) => {
                const sel = document.getElementById(id); if (!sel) return;
                const cur = sel.value;
                sel.innerHTML = `<option value="">All ${sel.title || id}</option>`;
                Array.from(set).sort().forEach(v => { const opt=document.createElement('option'); opt.value=v; opt.textContent=v; sel.appendChild(opt); });
                if (cur && Array.from(set).includes(cur)) sel.value = cur;
            };
            fillSimple2('anOperator', setOperator);
            fillSimple2('anRequestedBy', setRequestedBy);
            fillSimple2('anDistributionStatus', setDistStatus);
            fillSimple2('anIndexReading', setIndexReading);

        }

        function wireAnalyticsControls() {
            const byId = (id) => document.getElementById(id);
            // Auto-run on change of basic controls
            const auto = ['anStart','anEnd','anGranularity','anChartType'];
            auto.forEach(id => { const el = byId(id); if (el) el.onchange = () => renderAnalyticsFromFilters(); });
            // Exports
            const expCsv = byId('anExportChartCsvBtn'); if (expCsv) expCsv.onclick = exportChartCSV;
            const expPng = byId('anExportChartPngBtn'); if (expPng) expPng.onclick = exportChartPNG;
            // Series/category pickers
            const seriesPick = byId('anSeriesPicker');
            if (seriesPick) seriesPick.onchange = () => {
                const vals = Array.from(seriesPick.selectedOptions).map(o=>o.value);
                _anSelectedSeries = vals.length ? new Set(vals) : null; // null = show all
                renderAnalyticsFromFilters();
            };
            const catPick = byId('anCategoryPicker');
            if (catPick) catPick.onchange = () => {
                const vals = Array.from(catPick.selectedOptions).map(o=>o.value);
                _anSelectedCategories = vals.length ? new Set(vals) : null;
                renderAnalyticsFromFilters();
            };
            // Sub-tabs
            document.querySelectorAll('[data-an-tab]')?.forEach(btn => btn.addEventListener('click', () => showAnalyticsSubTab(btn.getAttribute('data-an-tab'))));

            initChartBuilder();
        }

        // Chart builder (Filters/Columns/Categories/Rows/Values) configuration similar to pivot, but drives the chart
        const _chartConfig = {
            rows: ['time'],
            categories: [],
            columns: [],
            filters: [],
            values: [{ measure:'quantity', agg:'sum' }],
            granularity: 'day'
        };

        function initChartBuilder() {
            // Populate add dropdowns
            const setOptions = (sel, options, placeholder) => {
                if (!sel) return;
                sel.innerHTML = '';
                const def = document.createElement('option'); def.value=''; def.textContent = placeholder; sel.appendChild(def);
                options.forEach(o => { const opt=document.createElement('option'); opt.value=o.key; opt.textContent=o.label; sel.appendChild(opt); });
                sel.onchange = () => { if (sel.value) { addToChartArea(sel.dataset.kind, sel.value); sel.value=''; } };
            };
            const fSel = document.getElementById('chartAddFilter'); if (fSel) { fSel.dataset.kind='filters'; setOptions(fSel, PIVOT_FIELDS, 'Add filter fieldâ€¦'); }
            const cSel = document.getElementById('chartAddColumn'); if (cSel) { cSel.dataset.kind='columns'; setOptions(cSel, PIVOT_FIELDS, 'Add column fieldâ€¦'); }
            const gSel = document.getElementById('chartAddCategory'); if (gSel) { gSel.dataset.kind='categories'; setOptions(gSel, PIVOT_FIELDS, 'Add category fieldâ€¦'); }
            const rSel = document.getElementById('chartAddRow'); if (rSel) { rSel.dataset.kind='rows'; setOptions(rSel, PIVOT_FIELDS, 'Add row fieldâ€¦'); }
            const vSel = document.getElementById('chartAddValue'); if (vSel) {
                vSel.dataset.kind='values';
                const measures = PIVOT_MEASURES.map(m => ({ key:m.key, label:m.label }));
                setOptions(vSel, measures, 'Add value (measure)â€¦');
                vSel.onchange = () => { if (vSel.value) { addToChartArea('values', vSel.value); vSel.value=''; } };
            }

            // Drag and drop
            document.querySelectorAll('#chartDropFilters,#chartDropColumns,#chartDropCategories,#chartDropRows,#chartDropValues').forEach(zone => {
                zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.style.background = '#f1f5f9'; });
                zone.addEventListener('dragleave', () => { zone.style.background = '#fff'; });
                zone.addEventListener('drop', (e) => {
                    e.preventDefault(); zone.style.background = '#fff';
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        const area = zone.id.replace('chartDrop','').toLowerCase();
                        if (area === 'values' && data.kind !== 'measure') return;
                        if ((area === 'rows' || area === 'columns' || area === 'filters' || area === 'categories') && data.kind !== 'field') return;
                        addToChartArea(area, data.key);
                    } catch (_) {}
                });
            });

            refreshChartAreasFromConfig();
        }

        function addToChartArea(area, key) {
            if (area === 'rows') { if (!_chartConfig.rows.includes(key)) _chartConfig.rows.push(key); }
            else if (area === 'columns') { if (!_chartConfig.columns.includes(key)) _chartConfig.columns.push(key); }
            else if (area === 'categories') { if (!_chartConfig.categories.includes(key)) _chartConfig.categories.push(key); }
            else if (area === 'filters') { if (!_chartConfig.filters.includes(key)) _chartConfig.filters.push(key); }
            else if (area === 'values') {
                const existing = _chartConfig.values.find(v => v.measure === key);
                if (!existing) _chartConfig.values.push({ measure:key, agg: (PIVOT_MEASURES.find(m=>m.key===key)?.aggs[0] || 'sum') });
            }
            refreshChartAreasFromConfig();
            renderAnalyticsFromFilters();
        }

        function removeFromChartArea(area, key) {
            if (area === 'rows') _chartConfig.rows = _chartConfig.rows.filter(k => k !== key);
            else if (area === 'columns') _chartConfig.columns = _chartConfig.columns.filter(k => k !== key);
            else if (area === 'categories') _chartConfig.categories = _chartConfig.categories.filter(k => k !== key);
            else if (area === 'filters') _chartConfig.filters = _chartConfig.filters.filter(k => k !== key);
            else if (area === 'values') _chartConfig.values = _chartConfig.values.filter(v => v.measure !== key);
            refreshChartAreasFromConfig();
            renderAnalyticsFromFilters();
        }

        function chartChip(title, area, key, isValue=false) {
            const c = document.createElement('span');
            c.className = 'pivot-chip' + (isValue? ' value-chip' : '');
            c.innerHTML = `<span>${title}</span>`;
            const remove = document.createElement('button');
            remove.textContent = 'Ã—'; remove.title = 'Remove';
            remove.onclick = () => removeFromChartArea(area, key);
            c.appendChild(remove);
            if (isValue) {
                const v = _chartConfig.values.find(v => v.measure === key);
                const aggSel = document.createElement('select'); aggSel.className = 'tiny-btn';
                (PIVOT_MEASURES.find(m=>m.key===key)?.aggs || ['sum']).forEach(a => { const opt=document.createElement('option'); opt.value=a; opt.textContent=a.toUpperCase(); aggSel.appendChild(opt); });
                aggSel.value = v.agg; aggSel.onchange = () => { v.agg = aggSel.value; renderAnalyticsFromFilters(); };
                c.appendChild(aggSel);
            }
            return c;
        }

        function refreshChartAreasFromConfig() {
            const map = {
                rows: document.getElementById('chartDropRows'),
                columns: document.getElementById('chartDropColumns'),
                categories: document.getElementById('chartDropCategories'),
                filters: document.getElementById('chartDropFilters'),
                values: document.getElementById('chartDropValues'),
            };
            if (map.rows) { map.rows.innerHTML = ''; _chartConfig.rows.forEach(k => map.rows.appendChild(chartChip(titleCase(k), 'rows', k))); }
            if (map.columns) { map.columns.innerHTML = ''; _chartConfig.columns.forEach(k => map.columns.appendChild(chartChip(titleCase(k), 'columns', k))); }
            if (map.categories) { map.categories.innerHTML = ''; _chartConfig.categories.forEach(k => map.categories.appendChild(chartChip(titleCase(k), 'categories', k))); }
            if (map.filters) { map.filters.innerHTML = ''; _chartConfig.filters.forEach(k => map.filters.appendChild(chartChip(titleCase(k), 'filters', k))); }
            if (map.values) { map.values.innerHTML = ''; _chartConfig.values.forEach(v => map.values.appendChild(chartChip(PIVOT_MEASURES.find(m=>m.key===v.measure)?.label || v.measure, 'values', v.measure, true))); }
        }

        async function renderAnalyticsFromFilters() {
            const startStr = document.getElementById('anStart').value;
            const endStr = document.getElementById('anEnd').value;
            const gran = document.getElementById('anGranularity').value || 'day';
            // Minimal controls for charts: use defaults matching Pivot defaults
            const fuelType = '';
            const equipmentSel = '';
            const eqType = '';
            const dept = '';
            let location = '';
            const tankSel = '';
            const tankStatusSel = '';
            const sourceSel = '';
            const operatorSel = '';
            const requestedBySel = '';
            const distStatusSel = '';
            const indexReadingText = '';
            const updatedBySel = '';
            const chartType = (document.getElementById('anChartType')?.value) || 'line';
            // Use chart builder config
            const measure = (_chartConfig.values[0]?.measure) || 'quantity';
            const agg = (_chartConfig.values[0]?.agg) || 'sum';
            // map old metric behavior for storage snapshot measures
            const metric = measure;

            // Branch: storage-based metrics (snapshot metrics that don't depend on time buckets)
            if (['currentVolume','ullage','capacityPct','openingStock','maxVolume'].includes(measure)) {
                return await renderStorageMetricChart(measure, '', chartType, { location, tank: '', tankStatus: '', updatedBy: '' });
            }

            const start = startStr ? new Date(startStr) : null;
            const end = endStr ? new Date(endStr) : null;
            if (!start || !end || isNaN(start) || isNaN(end) || start > end) {
                return drawAnalyticsChart([], [], [], 'Invalid date range');
            }

            const records = Object.values(_anAllDistributionsCache?.data || {});
            const filtered = records.filter(r => {
                if (!r || !r.timestamp || !r.fuel || !r.equipment) return false;
                const dt = new Date(r.timestamp);
                if (isNaN(dt) || dt < start || dt > new Date(end.getTime()+24*60*60*1000-1)) return false; // inclusive end
                const qty = Number(r.fuel?.quantity ?? r.fuel?.requestedQuantity) || 0;
                if (!(qty > 0)) return false;
                if (fuelType && (r.fuel?.type !== fuelType)) return false;
                if (eqType && (r.equipment?.type !== eqType)) return false;
                if (dept && (r.authorization?.department !== dept)) return false;
                if (location) {
                    // Use tank's Add Tank Status location for filtering
                    const rawTank = r.tankId || r.tankName || r.sourceTankName || r.tank || r.storage?.tankName || r.storage?.tank || r.fromTankName || r.fromTank || '';
                    const recLoc = (_anTankIdToLocation && rawTank) ? (_anTankIdToLocation[rawTank] || '') : '';
                    const recLabel = friendlyLocationLabel(recLoc) || recLoc || '';
                    if (recLabel !== location) return false;
                }
                if (tankSel) {
                    const raw = r.tankId || r.tank || r.tankName || '';
                    const disp = (window._tankIdDisplayMap && window._tankIdDisplayMap[raw]) ? window._tankIdDisplayMap[raw] : raw;
                    if (disp !== tankSel) return false;
                }
                if (sourceSel && r.source && r.source !== sourceSel) return false;
                if (operatorSel && r.equipment?.operator !== operatorSel) return false;
                if (requestedBySel && r.authorization?.requestedBy !== requestedBySel) return false;
                if (distStatusSel && r.status !== distStatusSel) return false;
                if (indexReadingText) {
                    const idxStr = String(r.fuel?.indexReading || r.indexReading || '').toLowerCase();
                    if (!idxStr.includes(indexReadingText.toLowerCase())) return false;
                }
                if (equipmentSel && (r.equipment?.id !== equipmentSel && r.equipment?.name !== equipmentSel)) return false;
                return true;
            });

            // Grouping helpers
            const bucketKey = (d) => {
                const y = d.getFullYear();
                const m = String(d.getMonth()+1).padStart(2,'0');
                const day = String(d.getDate()).padStart(2,'0');
                if (gran === 'month') return `${y}-${m}`;
                if (gran === 'week') {
                    // ISO week approximation
                    const tmp = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                    const dayNum = (tmp.getUTCDay() + 6) % 7; // Mon=0
                    tmp.setUTCDate(tmp.getUTCDate() - dayNum + 3);
                    const week1 = new Date(Date.UTC(tmp.getUTCFullYear(),0,4));
                    const week = 1 + Math.round(((tmp - week1)/86400000 - 3 + ((week1.getUTCDay()+6)%7))/7);
                    return `${tmp.getUTCFullYear()}-W${String(week).padStart(2,'0')}`;
                }
                return `${y}-${m}-${day}`; // day
            };

            // Aggregate with metric support driven by builder rows/columns
            const rowsCfg = Array.isArray(_chartConfig.rows) ? _chartConfig.rows : ['time'];
            const colsCfg = Array.isArray(_chartConfig.columns) ? _chartConfig.columns : [];
            const nonTimeRows = rowsCfg.filter(k => k !== 'time');
            const useTimeOnXAxis = rowsCfg.length === 0 || (rowsCfg.includes('time') && nonTimeRows.length === 0);

            const valueOfField = (r, k) => {
                if (k==='equipment') return r.equipment?.id || r.equipment?.name || 'Unknown';
                if (k==='equipmentType') return r.equipment?.type || 'Unknown';
                if (k==='fuelType') return r.fuel?.type || 'Unknown';
                if (k==='department') return r.authorization?.department || 'Unknown';
                if (k==='location') {
                    const rawTank = r.tankId || r.tankName || r.sourceTankName || r.tank || r.storage?.tankName || r.storage?.tank || r.fromTankName || r.fromTank || '';
                    const loc = (_anTankIdToLocation && rawTank) ? (_anTankIdToLocation[rawTank] || '') : '';
                    const label = friendlyLocationLabel(loc) || loc || 'Unknown';
                    return label || 'Unknown';
                }
                if (k==='tank') {
                    const raw = r.tankId || r.tank || r.tankName || 'Unknown';
                    const map = (window._tankIdDisplayMap || {});
                    return map[raw] || raw;
                }
                if (k==='tankStatus') return r.tankStatus || 'Unknown';
                if (k==='source') return r.source || 'Unknown';
                if (k==='operator') return r.equipment?.operator || r.driver || 'Unknown';
                if (k==='requestedBy') return r.authorization?.requestedBy || 'Unknown';
                if (k==='distributionStatus') return r.status || r.distributionStatus || 'Unknown';
                if (k==='indexReading') return String(r.fuel?.indexReading || r.indexReading || 'Unknown');
                if (k==='updatedBy') return r.updatedBy || 'Unknown';
                if (k==='stockDate') return r.stockDate || 'Unknown';
                if (k==='lastUpdated') return r.lastUpdated || 'Unknown';
                if (k==='maxVolume') return String(r.maxVolume || 'Unknown');
                return null;
            };

            // Series map: seriesKey -> aggregator maps keyed by xLabel
            const seriesMap = new Map(); // key -> {label, data:Map(xLabel->sum), count:Map(xLabel->n), min:Map, max:Map}
            const xLabelSet = new Set();
            filtered.forEach(r => {
                const dt = new Date(r.timestamp);
                const xLabel = useTimeOnXAxis ? bucketKey(dt) : (nonTimeRows.map(k => valueOfField(r,k)).filter(Boolean).join(' / ') || 'All');
                const sKey = colsCfg.length ? colsCfg.map(k => valueOfField(r,k)).filter(Boolean).join(' / ') : 'Total';
                const qty = Number(r.fuel?.quantity ?? r.fuel?.requestedQuantity) || 0;
                if (!seriesMap.has(sKey)) seriesMap.set(sKey, { label: sKey, data: new Map(), count: new Map(), min: new Map(), max: new Map() });
                const s = seriesMap.get(sKey);
                const val = (measure==='count') ? 1 : qty;
                s.data.set(xLabel, (s.data.get(xLabel) || 0) + val);
                s.count.set(xLabel, (s.count.get(xLabel) || 0) + 1);
                s.min.set(xLabel, Math.min(s.min.has(xLabel) ? s.min.get(xLabel) : Infinity, val));
                s.max.set(xLabel, Math.max(s.max.has(xLabel) ? s.max.get(xLabel) : -Infinity, val));
                xLabelSet.add(xLabel);
            });

            // Build x-axis labels: time buckets or categorical from rows (excluding time)
            let labels = [];
            if (useTimeOnXAxis) {
                const cursor = new Date(start);
                const pushKey = () => labels.push(bucketKey(cursor));
                const step = () => {
                    if (gran === 'month') { cursor.setMonth(cursor.getMonth()+1, 1); }
                    else if (gran === 'week') { cursor.setDate(cursor.getDate()+7); }
                    else { cursor.setDate(cursor.getDate()+1); }
                };
                // Normalize start to bucket start (for nicer label continuity)
                if (gran === 'month') cursor.setDate(1);
                if (gran === 'week') { const day = (cursor.getDay()+6)%7; cursor.setDate(cursor.getDate()-day); }
                while (cursor <= end) { pushKey(); step(); }
            } else {
                labels = Array.from(xLabelSet);
                labels.sort((a,b)=> String(a).localeCompare(String(b)));
            }

            // Prepare datasets
            const palette = ['#3b82f6','#10b981','#ef4444','#f59e0b','#8b5cf6','#14b8a6','#f43f5e','#22c55e'];
            const valueFor = (s, l) => {
                if (agg === 'count') return s.count.get(l) || 0;
                if (agg === 'avg') { const sum = s.data.get(l) || 0; const c = s.count.get(l) || 0; return c ? sum/c : 0; }
                if (agg === 'min') { const v = s.min.get(l); return v==null || v===Infinity ? 0 : v; }
                if (agg === 'max') { const v = s.max.get(l); return v==null || v===-Infinity ? 0 : v; }
                return s.data.get(l) || 0; // sum
            };
            let datasets = Array.from(seriesMap.values()).map((s,idx) => {
                const color = palette[idx % palette.length];
                return {
                    label: s.label,
                    data: labels.map(l => Math.round((valueFor(s,l) || 0) * 100) / 100),
                    borderColor: color,
                    backgroundColor: color + ((chartType==='area' || chartType==='stackedArea') ? '33' : '66'),
                    tension: 0.25,
                    fill: chartType==='area' || chartType==='stackedArea',
                    pointRadius: 2,
                };
            });

            // Deduplicate identical x-axis labels by summing values across duplicates
            if (labels.length) {
                const unique = Array.from(new Set(labels));
                if (unique.length !== labels.length) {
                    const indexGroups = new Map(); // label -> indices
                    labels.forEach((lbl, i) => {
                        if (!indexGroups.has(lbl)) indexGroups.set(lbl, []);
                        indexGroups.get(lbl).push(i);
                    });
                    datasets = datasets.map(ds => ({
                        ...ds,
                        data: unique.map(ul => (indexGroups.get(ul) || []).reduce((sum, idx) => sum + (Number(ds.data[idx])||0), 0))
                    }));
                    labels = unique;
                }
            }

            const totals = labels.map((_,i) => datasets.reduce((sum,ds)=>sum+(Number(ds.data[i])||0),0));
            const hasData = totals.some(v => v>0);
            const kpiEl = document.getElementById('anKpiTotal');
            if (kpiEl) {
                const total = Math.round(totals.reduce((a,b)=>a+b,0) * 100) / 100;
                const suffix = (measure==='count' || agg==='count') ? 'distributions' : 'L';
                kpiEl.style.display = 'block';
                kpiEl.textContent = `Total: ${total.toLocaleString()} ${suffix}`;
            }
            // Apply display selections (series/categories)
            ({ labels, datasets } = applyDisplaySelections(labels, datasets));
            const newTotals = labels.map((_,i) => datasets.reduce((sum,ds)=>sum+(Number(ds.data[i])||0),0));
            _anLastChartData = { labels, datasets, totals: newTotals, chartType, metric: measure };
            // Update pickers to reflect available choices
            updateDisplayPickers(datasets.map(d=>d.label), labels);
            drawAnalyticsChart(labels, datasets, newTotals, hasData ? null : 'No data to display for current filters');
        }

        function drawAnalyticsChart(labels, datasets, totals, emptyMsg) {
            const empty = document.getElementById('analyticsEmptyState');
            const canvas = document.getElementById('consumptionChart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (_anChartInstance) { _anChartInstance.destroy(); _anChartInstance = null; }
            if (emptyMsg) {
                empty.style.display = 'block';
                // draw empty background
                _anChartInstance = new Chart(ctx, { type:'line', data:{ labels:[], datasets:[] }, options:{ plugins:{ legend:{display:false} } } });
                return;
            } else {
                empty.style.display = 'none';
            }
            const typeSel = (document.getElementById('anChartType')?.value) || 'line';
            let chartType = 'line';
            let stacked = false;
            if (typeSel==='line' || typeSel==='area') chartType = 'line';
            else if (typeSel==='bar' || typeSel==='stackedBar') chartType = 'bar';
            else if (typeSel==='pie') chartType = 'pie';
            else if (typeSel==='doughnut') chartType = 'doughnut';
            if (typeSel==='stackedBar' || typeSel==='stackedArea') stacked = true;

            let data;
            if (chartType==='pie' || chartType==='doughnut') {
                // If caller provided a single dataset aligned to labels, use it as-is (storage pies)
                if (datasets && datasets.length === 1 && Array.isArray(datasets[0].data) && Array.isArray(labels) && datasets[0].data.length === labels.length) {
                    data = { labels, datasets };
                } else {
                    const pieLabels = datasets.map(ds => ds.label);
                    const pieData = datasets.map(ds => (ds.data || []).reduce((a,b)=>a + Number(b||0), 0));
                    const pieColors = datasets.map(ds => ds.borderColor || '#3b82f6');
                    data = { labels: pieLabels, datasets: [{ label: 'Total', data: pieData, backgroundColor: pieColors }] };
                }
            } else {
                data = { labels, datasets };
            }
            const metric = _anLastChartData?.metric || 'quantity';
            const yTitle = (metric==='capacityPct') ? 'Percentage (%)' : (metric==='count' ? 'Count' : 'Liters');
            const isTankMetric = ['currentVolume','ullage','capacityPct','openingStock','maxVolume'].includes(metric);
            const xScale = {
                stacked,
                title: { display: true, text: isTankMetric ? 'Tank' : 'Period' }
            };
            // When x-axis represents dates/periods, show labels vertically for better readability
            if (!isTankMetric) {
                xScale.ticks = { maxRotation: 90, minRotation: 90 };
            }
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode:'index', intersect:false },
                plugins: {
                    legend: { position: 'top' },
                    tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${Number((ctx.parsed?.y ?? ctx.raw) || 0).toLocaleString()}` } }
                },
                scales: (chartType==='pie' || chartType==='doughnut') ? {} : {
                    y: { stacked, beginAtZero:true, title:{ display:true, text: yTitle } },
                    x: xScale
                }
            };

            _anChartInstance = new Chart(ctx, { type: chartType, data, options });
        }

        // Render storage snapshot metrics (Current Stock, Ullage, Capacity %)
    async function renderStorageMetricChart(metric, splitDim, chartType, { location, tank, tankStatus, updatedBy }) {
            const tanksObj = _anStorageStatusCache?.data || {};
            const tanks = Object.values(tanksObj || {});
            if (!tanks.length) {
                _anLastChartData = { labels: [], datasets: [], totals: [], chartType, metric };
                return drawAnalyticsChart([], [], [], 'No storage data to display');
            }
            // Ensure we have the latest computed stock-after map
            try {
                if (!window._lastStockAfterByTank || typeof window._lastStockAfterByTank !== 'object') {
                    await computeLastStockAfterTransactions();
                }
            } catch (_) {}
            // Optional simple filter by location if available on tank
            let filtered = tanks;
            if (location) {
                filtered = filtered.filter(t => {
                    const loc = t.location || t.site || t.area || '';
                    if (loc === location) return true;
                    const label = friendlyLocationLabel(loc);
                    return label === location;
                });
            }
            if (tank) {
                filtered = filtered.filter(t => (t.tankIdDisplay || t.tankId || '') === tank);
            }
            if (tankStatus) {
                filtered = filtered.filter(t => (t.status || '') === tankStatus);
            }
            if (updatedBy) {
                filtered = filtered.filter(t => (t.updatedBy || '') === updatedBy);
            }
            if (!filtered.length) {
                _anLastChartData = { labels: [], datasets: [], totals: [], chartType, metric };
                return drawAnalyticsChart([], [], [], 'No storage data matches filters');
            }

            const valueOf = (t) => {
                const tid = t.tankId || t.tankIdDisplay || '';
                // Prefer computed stock based on distributions/transfers if available
                const computedStock = (window._lastStockAfterByTank && tid) ? Number(window._lastStockAfterByTank[tid] || 0) : undefined;
                if (metric==='currentVolume' || metric==='currentStock') return computedStock!=null ? computedStock : Number(t.currentVolume || 0);
                if (metric==='ullage') {
                    const baseStock = computedStock!=null ? computedStock : Number(t.currentVolume || 0);
                    const maxV = Number(t.maxVolume || 0);
                    return Math.max(0, maxV - baseStock);
                }
                if (metric==='capacityPct') {
                    const baseStock = computedStock!=null ? computedStock : Number(t.currentVolume || 0);
                    const maxV = Number(t.maxVolume || 0);
                    return maxV>0 ? (baseStock / maxV) * 100 : 0;
                }
                if (metric==='openingStock') {
                    return Number(t.currentVolume || 0); // opening as recorded; computedStock is closing
                }
                if (metric==='maxVolume') {
                    return Number(t.maxVolume || 0);
                }
                return 0;
            };

            // For pie/doughnut: labels are tanks, single dataset
            const palette = ['#3b82f6','#10b981','#ef4444','#f59e0b','#8b5cf6','#14b8a6','#f43f5e','#22c55e'];
            if (chartType==='pie' || chartType==='doughnut') {
                const labels = filtered.map(t => t.tankIdDisplay || t.tankId || 'Tank');
                const data = filtered.map(t => Math.round(valueOf(t) * 100) / 100);
                const datasets = [{ label: metric==='capacityPct' ? 'Capacity %' : (metric==='ullage' ? 'Ullage (L)' : 'Closing Stock (L)'), data, backgroundColor: labels.map((_,i)=>palette[i % palette.length]) }];
                // Apply category filter for pie/doughnut (series not applicable as single dataset)
                const filteredByPickers = applyDisplaySelections(labels, datasets);
                const outLabels = filteredByPickers.labels;
                const outDatasets = filteredByPickers.datasets;
                const totals = outDatasets[0]?.data || [];
                _anLastChartData = { labels: outLabels, datasets: outDatasets, totals, chartType, metric };
                updateDisplayPickers(outDatasets.map(d=>d.label), outLabels);
                return drawAnalyticsChart(outLabels, outDatasets, totals, null);
            }

            // For bar/line/area: x-axis are tanks, single series dataset
            let labels = filtered.map(t => t.tankIdDisplay || t.tankId || 'Tank');
            const values = filtered.map(t => Math.round(valueOf(t) * 100) / 100);
            const color = '#3b82f6';
            let datasets = [{ label: metric==='capacityPct' ? 'Capacity %' : (metric==='ullage' ? 'Ullage (L)' : 'Closing Stock (L)'), data: values, borderColor: color, backgroundColor: color + '66', tension: 0.25, fill: chartType==='area' || chartType==='stackedArea', pointRadius: 2 }];
            // Apply category filter (series not applicable for single series)
            ({ labels, datasets } = applyDisplaySelections(labels, datasets));
            const totals = values;
            const kpiEl = document.getElementById('anKpiTotal');
            if (kpiEl) {
                if (metric==='capacityPct') {
                    const avg = values.length ? (values.reduce((a,b)=>a+b,0)/values.length) : 0;
                    kpiEl.style.display = 'block';
                    kpiEl.textContent = `Average: ${Math.round(avg*100)/100}%`;
                } else {
                    const total = Math.round(values.reduce((a,b)=>a+b,0) * 100) / 100;
                    kpiEl.style.display = 'block';
                    kpiEl.textContent = `Total: ${total.toLocaleString()} L`;
                }
            }
            _anLastChartData = { labels, datasets, totals, chartType, metric };
            updateDisplayPickers(datasets.map(d=>d.label), labels);
            return drawAnalyticsChart(labels, datasets, totals, null);
        }

        // Helpers to filter displayed series/categories and to update the pickers
        function applyDisplaySelections(labels, datasets) {
            // Filter series
            let outDatasets = datasets;
            if (_anSelectedSeries && outDatasets && outDatasets.length) {
                outDatasets = outDatasets.filter(ds => _anSelectedSeries.has(ds.label));
            }
            // Filter categories (x-axis labels)
            let outLabels = labels;
            if (_anSelectedCategories && Array.isArray(outLabels)) {
                const keep = new Set(Array.from(_anSelectedCategories));
                const indexMap = outLabels.map((l,idx)=> keep.has(String(l)) ? idx : -1).filter(i=>i>=0);
                outLabels = outLabels.filter(l => keep.has(String(l)));
                outDatasets = (outDatasets||[]).map(ds => ({
                    ...ds,
                    data: indexMap.map(i => ds.data[i])
                }));
            }
            return { labels: outLabels, datasets: outDatasets };
        }

        function updateDisplayPickers(seriesLabels, categoryLabels) {
            const seriesPick = document.getElementById('anSeriesPicker');
            const catPick = document.getElementById('anCategoryPicker');
            // Update Series picker
            if (seriesPick) {
                const prev = new Set(Array.from(seriesPick.selectedOptions).map(o=>o.value));
                seriesPick.innerHTML = '';
                (seriesLabels||[]).forEach(lbl => {
                    const opt = document.createElement('option');
                    opt.value = lbl; opt.textContent = lbl;
                    if ((_anSelectedSeries && _anSelectedSeries.has(lbl)) || (!_anSelectedSeries && prev.has(lbl))) opt.selected = true;
                    seriesPick.appendChild(opt);
                });
            }
            // Update Category picker
            if (catPick) {
                const prev = new Set(Array.from(catPick.selectedOptions).map(o=>o.value));
                catPick.innerHTML = '';
                (categoryLabels||[]).forEach(lbl => {
                    const opt = document.createElement('option');
                    opt.value = String(lbl); opt.textContent = String(lbl);
                    if ((_anSelectedCategories && _anSelectedCategories.has(String(lbl))) || (!_anSelectedCategories && prev.has(String(lbl)))) opt.selected = true;
                    catPick.appendChild(opt);
                });
            }
        }

        // ================= Visualization Tab (Pivot-style Analysis Sets) =================
        let _vzInitialized = false;
        const _vzSets = new Map(); // id -> { cfg, chart, wrap, selectedValues, selectedValues2, _lastAgg }
        let _vzSeq = 0;

        async function initVisualizationTab(){
            if (_vzInitialized) return; // run once
            try {
                await ensureAnalyticsDataLoaded();
            } catch(e){ console.warn('Visualization init: ensureAnalyticsDataLoaded failed', e); }
            const addBtn = document.getElementById('vzAddSetBtn');
            const clearBtn = document.getElementById('vzClearSetsBtn');
            if (addBtn) addBtn.onclick = () => addVizAnalysisSet();
            if (clearBtn) clearBtn.onclick = () => { if (confirm('Remove all analysis sets?')){ _vzSets.forEach((v)=>{ try{ v.chart?.destroy(); }catch(_){ } }); _vzSets.clear(); document.getElementById('vzSetsContainer').innerHTML=''; } };
            // Create first set automatically for convenience
            addVizAnalysisSet();
            _vzInitialized = true;
        }

        function addVizAnalysisSet(){
            const container = document.getElementById('vzSetsContainer'); if(!container) return;
            const id = 'vz'+(++_vzSeq);
            const cfg = { groupBy:'day', groupBy2:'', chartType:'bar', start:'', end:'' };
            const wrap = document.createElement('div');
            wrap.className = 'analysis-set border border-slate-300 rounded-md p-2 bg-white shadow-sm flex flex-col gap-2 w-full';
            wrap.dataset.vzSet = id;
            wrap.innerHTML = `
                <div class='flex items-center justify-between'>
                    <h3 class='text-[11px] font-semibold text-slate-700'>Visualization Set</h3>
                    <div class='flex gap-1'>
                        <button data-act='refresh' class='text-[10px] px-2 py-0.5 rounded bg-slate-100 hover:bg-slate-200 text-slate-600'><i class="fa fa-rotate"></i></button>
                        <button data-act='remove' class='text-[10px] px-2 py-0.5 rounded bg-red-100 hover:bg-red-200 text-red-600'><i class="fa fa-times"></i></button>
                    </div>
                </div>
                <div class='flex flex-wrap gap-2 items-end text-[10px] bg-slate-50/60 rounded-md p-2 border border-slate-200'>
                    <label class='flex flex-col gap-0.5'>Group
                        <select data-filt='groupBy' class='border rounded px-1 py-0.5 bg-white'>
                            <option value='day'>Day</option>
                            <option value='tank'>Tank</option>
                            <option value='location'>Location</option>
                            <option value='fuelType'>Fuel Type</option>
                            <option value='equipmentType'>Equipment Type</option>
                            <option value='equipment'>Equipment</option>
                            <option value='operator'>Operator</option>
                            <option value='department'>Department</option>
                            <option value='source'>Source</option>
                            <option value='distributionStatus'>Status</option>
                            <option value='updatedBy'>Updated By</option>
                        </select>
                    </label>
                    <label class='flex flex-col gap-0.5'>Group 2
                        <select data-filt='groupBy2' class='border rounded px-1 py-0.5 bg-white'>
                            <option value=''>-- None --</option>
                            <option value='day'>Day</option>
                            <option value='tank'>Tank</option>
                            <option value='location'>Location</option>
                            <option value='fuelType'>Fuel Type</option>
                            <option value='equipmentType'>Equipment Type</option>
                            <option value='equipment'>Equipment</option>
                            <option value='operator'>Operator</option>
                            <option value='department'>Department</option>
                            <option value='source'>Source</option>
                            <option value='distributionStatus'>Status</option>
                            <option value='updatedBy'>Updated By</option>
                        </select>
                    </label>
                    <label class='flex flex-col gap-0.5'>Chart
                        <select data-filt='chartType' class='border rounded px-1 py-0.5 bg-white'>
                            <option value='bar'>Bar</option>
                            <option value='line'>Line</option>
                            <option value='pie'>Pie</option>
                            <option value='doughnut'>Doughnut</option>
                        </select>
                    </label>
                    <div class='flex flex-col gap-0.5 relative' data-role='valueFilter'>
                        <label class='text-[10px]'>Filter Values</label>
                        <button type='button' data-act='toggle-value-dropdown' class='border rounded px-1 py-0.5 bg-white text-left text-[10px] hover:bg-slate-50 flex items-center justify-between gap-1' style='min-width:140px;'>
                            <span data-role='valueFilterLabel'>All</span>
                            <i class='fa fa-chevron-down' style='font-size:8px;'></i>
                        </button>
                        <div data-role='valueDropdown' class='hidden absolute top-full left-0 mt-1 bg-white border border-slate-300 rounded shadow-lg z-50 max-h-[200px] overflow-auto' style='min-width:180px;'>
                            <div class='p-1 text-[9px] text-slate-500 border-b flex items-center justify-between'>
                                <span>Select values to show:</span>
                                <button type='button' data-act='toggle-all-values' class='text-[9px] px-1 py-0.5 rounded bg-slate-100 hover:bg-slate-200 text-slate-600'>All/None</button>
                            </div>
                            <div data-role='valueCheckboxes' class='p-1'></div>
                        </div>
                    </div>
                    <div class='flex flex-col gap-0.5 relative' data-role='valueFilter2'>
                        <label class='text-[10px]'>Filter Values 2</label>
                        <button type='button' data-act='toggle-value2-dropdown' class='border rounded px-1 py-0.5 bg-white text-left text-[10px] hover:bg-slate-50 flex items-center justify-between gap-1' style='min-width:140px;'>
                            <span data-role='valueFilter2Label'>All</span>
                            <i class='fa fa-chevron-down' style='font-size:8px;'></i>
                        </button>
                        <div data-role='valueDropdown2' class='hidden absolute top-full left-0 mt-1 bg-white border border-slate-300 rounded shadow-lg z-50 max-h-[200px] overflow-auto' style='min-width:180px;'>
                            <div class='p-1 text-[9px] text-slate-500 border-b flex items-center justify-between'>
                                <span>Select values to show:</span>
                                <button type='button' data-act='toggle-all-values2' class='text-[9px] px-1 py-0.5 rounded bg-slate-100 hover:bg-slate-200 text-slate-600'>All/None</button>
                            </div>
                            <div data-role='valueCheckboxes2' class='p-1'></div>
                        </div>
                    </div>
                    <label class='flex flex-col gap-0.5'>Start
                        <input data-filt='start' type='date' class='border rounded px-1 py-0.5 bg-white'/>
                    </label>
                    <label class='flex flex-col gap-0.5'>End
                        <input data-filt='end' type='date' class='border rounded px-1 py-0.5 bg-white'/>
                    </label>
                    <div class='flex items-center gap-1 ml-auto'>
                        <button data-act='preset' data-range='7d' class='px-2 py-0.5 rounded bg-slate-200 hover:bg-slate-300 text-slate-700'>7d</button>
                        <button data-act='preset' data-range='30d' class='px-2 py-0.5 rounded bg-slate-200 hover:bg-slate-300 text-slate-700'>30d</button>
                        <button data-act='preset' data-range='clear' class='px-2 py-0.5 rounded bg-slate-100 hover:bg-slate-200 text-slate-600'>Clear</button>
                        <button data-act='apply' class='px-3 py-0.5 rounded bg-indigo-500 hover:bg-indigo-600 text-white font-semibold'>Apply</button>
                    </div>
                </div>
                <div class='text-[10px] text-slate-500 italic -mt-1 mb-1' data-role='summary'>day</div>
                <div class='flex flex-wrap gap-2 items-stretch'>
                    <div class='flex flex-col border border-slate-200 rounded-md p-2 flex-1 min-w-[340px]' data-role='tableBox'>
                        <h4 class='text-[10px] font-semibold text-slate-600 mb-1'>TABLE</h4>
                        <div class='overflow-auto'>
                            <table class='w-full text-[10px] border-collapse'>
                                <thead><tr><th class='text-left px-1 py-0.5' data-col='groupHdr'>DAY</th><th class='text-right px-1 py-0.5'>Records</th><th class='text-right px-1 py-0.5'>Qty (L)</th><th class='text-right px-1 py-0.5'>Avg (L)</th></tr></thead>
                                <tbody></tbody>
                                <tfoot><tr><td class='px-1 py-0.5 font-semibold'>Totals</td><td class='text-right px-1 py-0.5 font-semibold' data-ft-rec></td><td class='text-right px-1 py-0.5 font-semibold' data-ft-qty></td><td></td></tr></tfoot>
                            </table>
                        </div>
                    </div>
                    <div class='flex flex-col border border-slate-200 rounded-md p-2 flex-1 min-w-[320px]' data-role='chartBox'>
                        <h4 class='text-[10px] font-semibold text-slate-600 mb-1'>CHART</h4>
                        <div style='flex:1;min-height:160px;display:flex;'>
                            <canvas></canvas>
                        </div>
                    </div>
                </div>`;
            container.appendChild(wrap);

            const ctx = wrap.querySelector('canvas').getContext('2d');
            const chart = new Chart(ctx,{ type:'bar', data:{ labels:[], datasets:[{ label:'Quantity (L)', data:[], backgroundColor:'#f39c12', borderColor:'#d97706', borderWidth:1 }] }, options:{ responsive:true, maintainAspectRatio:false, scales:{ y:{ beginAtZero:true, ticks:{ font:{ size:8 }, color:'#334155' } }, x:{ ticks:{ font:{ size:8 }, color:'#334155' } } }, plugins:{ legend:{ labels:{ font:{ size:8 }, color:'#334155' } } } }});
            const entry = { id, cfg, chart, wrap, selectedValues:[], selectedValues2:[], overrides:null, _lastAgg:null };
            _vzSets.set(id, entry);

            // Event delegation for this set
            wrap.addEventListener('click', e=>{
                const b = e.target.closest('button[data-act]'); if(!b) return;
                const act = b.getAttribute('data-act');
                if (act==='remove'){ try{ entry.chart.destroy(); }catch(_){ } _vzSets.delete(id); wrap.remove(); return; }
                if (act==='refresh'){ refreshVizSet(id); return; }
                if (act==='apply'){ applyVizFilters(id); return; }
                if (act==='preset'){ applyVizPresetRange(id, b.getAttribute('data-range')); return; }
                if (act==='toggle-value-dropdown'){ toggleVizValueDropdown(id); return; }
                if (act==='toggle-value2-dropdown'){ toggleVizValue2Dropdown(id); return; }
                if (act==='toggle-all-values'){ toggleVizAllValues(id); return; }
                if (act==='toggle-all-values2'){ toggleVizAllValues2(id); return; }
            });
            // Change handlers for group selects to reset value selections
            wrap.querySelector('select[data-filt="groupBy"]').addEventListener('change', ()=>{ entry.selectedValues=[]; populateVizValueFilterOptions(id); applyVizFilters(id); });
            wrap.querySelector('select[data-filt="groupBy2"]').addEventListener('change', ()=>{ entry.selectedValues2=[]; populateVizValueFilterOptions2(id); applyVizFilters(id); });

            populateVizValueFilterOptions(id);
            populateVizValueFilterOptions2(id);
            refreshVizSet(id);
        }

        function getVizDataset(start, end){
            const all = getAnalyticsRawRecords();
            let s=null,e=null;
            if(start){ const d=new Date(start); if(!isNaN(d)) s=new Date(d.getFullYear(),d.getMonth(),d.getDate()); }
            if(end){ const d=new Date(end); if(!isNaN(d)) e=new Date(d.getFullYear(),d.getMonth(),d.getDate(),23,59,59,999); }
            return all.filter(r=>{
                if(!r.date) return false;
                if(s && r.date < s) return false;
                if(e && r.date > e) return false;
                // Only count rows with a measurable quantity or stock metric
                const q = Number(r.quantity != null ? r.quantity : (r.currentStock!=null ? r.currentStock : r.currentVolume));
                return q > 0;
            });
        }

        function computeVizPivot(primary, secondary, opts){
            // Reuse logic pattern from distribution pivot; dataset is derived from analytics raw records
            const dataset = getVizDataset(opts?.start, opts?.end);
            const selRows = Array.isArray(opts?.selectedValues)? opts.selectedValues:[];
            const selCols = Array.isArray(opts?.selectedValues2)? opts.selectedValues2:[];
            const filterRows = selRows.length>0;
            const filterCols = selCols.length>0;
            if(!secondary || secondary===primary){
                // 1D aggregate
                const groups = {};
                dataset.forEach(r=>{
                    const { key } = vizDimKey(r, primary);
                    if(filterRows && !selRows.includes(String(key))) return;
                    if(!groups[key]) groups[key]={ key, records:0, quantity:0 };
                    groups[key].records += 1;
                    groups[key].quantity += valueForRecord(r);
                });
                let rows = Object.values(groups);
                if(primary==='day'){ rows.sort((a,b)=> new Date(a.key)-new Date(b.key)); }
                else rows.sort((a,b)=> b.quantity-a.quantity);
                const totals = rows.reduce((acc,r)=>{acc.records+=r.records;acc.quantity+=r.quantity;return acc;},{records:0,quantity:0});
                return { mode:'1d', rows, totals };
            }
            // 2D
            const matrix = {}; const colSet = new Set(); const rowMeta={};
            dataset.forEach(r=>{
                const { key:rKey, sortVal:rSort } = vizDimKey(r, primary);
                const { key:cKey } = vizDimKey(r, secondary);
                if(filterRows && !selRows.includes(String(rKey))) return;
                if(filterCols && !selCols.includes(String(cKey))) return;
                if(!matrix[rKey]) matrix[rKey] = {};
                if(!matrix[rKey][cKey]) matrix[rKey][cKey] = { records:0, quantity:0 };
                matrix[rKey][cKey].records += 1;
                matrix[rKey][cKey].quantity += valueForRecord(r);
                colSet.add(cKey);
                if(!rowMeta[rKey]) rowMeta[rKey]={ sortVal:rSort };
                else if(typeof rSort==='number' && (typeof rowMeta[rKey].sortVal!=='number' || rSort < rowMeta[rKey].sortVal)) rowMeta[rKey].sortVal = rSort;
            });
            let rowKeys = Object.keys(matrix);
            if(primary==='day'){ rowKeys.sort((a,b)=> (rowMeta[a].sortVal||0)-(rowMeta[b].sortVal||0)); }
            else {
                rowKeys.sort((a,b)=>{
                    const qa = Object.values(matrix[a]).reduce((s,c)=>s+c.quantity,0);
                    const qb = Object.values(matrix[b]).reduce((s,c)=>s+c.quantity,0);
                    return qb-qa;
                });
            }
            const colKeys = Array.from(colSet);
            if(colKeys.length>50) colKeys.splice(50);
            const rowTotals = {}; const colTotals = {}; let grand={records:0,quantity:0};
            rowKeys.forEach(rk=>{
                rowTotals[rk]={records:0,quantity:0};
                colKeys.forEach(ck=>{ const cell = matrix[rk][ck]; if(!cell) return; rowTotals[rk].records+=cell.records; rowTotals[rk].quantity+=cell.quantity; if(!colTotals[ck]) colTotals[ck]={records:0,quantity:0}; colTotals[ck].records+=cell.records; colTotals[ck].quantity+=cell.quantity; grand.records+=cell.records; grand.quantity+=cell.quantity; });
            });
            return { mode:'2d', primary, secondary, rowKeys, colKeys, matrix, rowTotals, colTotals, grand };
        }

        function valueForRecord(r){
            // Prefer distribution quantity else currentStock/currentVolume/openingStock
            if (typeof r.quantity === 'number') return Number(r.quantity)||0;
            if (typeof r.currentStock === 'number') return Number(r.currentStock)||0;
            if (typeof r.currentVolume === 'number') return Number(r.currentVolume)||0;
            if (typeof r.openingStock === 'number') return Number(r.openingStock)||0;
            return 0;
        }

        function vizDimKey(r, dim){
            let key; let sortVal;
            switch(dim){
                case 'day': { const d=r.date; key = d.toISOString().slice(0,10); sortVal = new Date(d.getFullYear(),d.getMonth(),d.getDate()).getTime(); break; }
                case 'tank': key = r.tank || 'Unknown Tank'; break;
                case 'location': key = r.location || 'Unknown Location'; break;
                case 'fuelType': key = r.fuelType || 'Unknown Fuel'; break;
                case 'equipmentType': key = r.equipmentType || 'Unknown Type'; break;
                case 'equipment': key = r.equipment || 'Unknown Equipment'; break;
                case 'operator': key = r.operator || 'Unknown Operator'; break;
                case 'department': key = r.department || 'Unknown Department'; break;
                case 'source': key = r.source || 'Unknown Source'; break;
                case 'distributionStatus': key = r.distributionStatus || 'Unknown Status'; break;
                case 'updatedBy': key = r.updatedBy || 'Unknown'; break;
                default: key = 'Other';
            }
            return { key, sortVal };
        }

        function refreshVizSet(id){
            const entry = _vzSets.get(id); if(!entry) return;
            entry._lastAgg = computeVizPivot(entry.cfg.groupBy, entry.cfg.groupBy2, { start: entry.cfg.start, end: entry.cfg.end, selectedValues: entry.selectedValues, selectedValues2: entry.selectedValues2 });
            buildVizTable(entry);
            applyVizChart(entry);
        }

        function buildVizTable(entry){
            const { wrap, _lastAgg, cfg } = entry; if(!_lastAgg) return;
            const tbody = wrap.querySelector('tbody'); const thead = wrap.querySelector('thead');
            if(_lastAgg.mode==='2d'){
                if(thead){ thead.innerHTML = `<tr><th data-col='groupHdr' class='px-1 py-0.5 text-left sticky left-0 bg-white z-10'>${(cfg.groupBy||'ROW').toUpperCase()}</th>${_lastAgg.colKeys.map(ck=>`<th class='px-1 py-0.5 text-right'>${ck}</th>`).join('')}<th class='px-1 py-0.5 text-right'>TOTAL</th></tr>`; }
                tbody.innerHTML = _lastAgg.rowKeys.map(rk=>{
                    const rowTotal = _lastAgg.rowTotals[rk];
                    return `<tr class='odd:bg-slate-50' data-row-key='${rk}'><td class='px-1 py-0.5 sticky left-0 bg-white z-10'>${rk}</td>${_lastAgg.colKeys.map(ck=>{ const cell=_lastAgg.matrix[rk][ck]; if(!cell) return `<td class='text-right px-1 py-0.5 text-slate-300'>-</td>`; return `<td class='text-right px-1 py-0.5'>${cell.quantity.toFixed(2)}</td>`; }).join('')}<td class='text-right px-1 py-0.5 font-semibold'>${rowTotal.quantity.toFixed(2)}</td></tr>`;
                }).join('');
                // footer
                const ftQty = wrap.querySelector('[data-ft-qty]'); if(ftQty) ftQty.textContent = (_lastAgg.grand.quantity||0).toFixed(2);
                const ftRec = wrap.querySelector('[data-ft-rec]'); if(ftRec) ftRec.textContent = (_lastAgg.grand.records||0);
            } else {
                const rows = _lastAgg.rows || [];
                tbody.innerHTML = rows.map(r=>{
                    const avg = r.records ? (r.quantity/r.records) : 0;
                    return `<tr class='odd:bg-slate-50'><td class='px-1 py-0.5'>${r.key}</td><td class='text-right px-1 py-0.5'>${r.records}</td><td class='text-right px-1 py-0.5'>${r.quantity.toFixed(2)}</td><td class='text-right px-1 py-0.5'>${avg.toFixed(2)}</td></tr>`;
                }).join('');
                const ftQty = wrap.querySelector('[data-ft-qty]'); if(ftQty) ftQty.textContent = rows.reduce((a,r)=>a+r.quantity,0).toFixed(2);
                const ftRec = wrap.querySelector('[data-ft-rec]'); if(ftRec) ftRec.textContent = rows.reduce((a,r)=>a+r.records,0);
            }
        }

        function applyVizChart(entry){
            const { chart, _lastAgg, cfg, wrap } = entry; if(!_lastAgg || !chart) return;
            if(_lastAgg.mode==='2d'){
                const rowKeys = _lastAgg.rowKeys.slice(0,30);
                const colKeys = _lastAgg.colKeys;
                chart.data.labels = rowKeys;
                const palette = [ '#2563eb','#f59e0b','#10b981','#ef4444','#6366f1','#0d9488','#d946ef','#f97316','#059669','#dc2626','#4f46e5','#0891b2','#c026d3','#fb7185','#7c3aed','#65a30d','#9333ea','#ea580c','#15803d','#be123c' ];
                chart.data.datasets = colKeys.map((ck,i)=>({ label: ck, data: rowKeys.map(rk=>{ const cell=_lastAgg.matrix[rk][ck]; return cell? cell.quantity:0; }), backgroundColor: palette[i % palette.length], borderColor: palette[i % palette.length], borderWidth:1, tension:0.25, fill: cfg.chartType==='line'? false:true }));
                if(['pie','doughnut'].includes(chart.config.type)) chart.config.type='bar';
                chart.update();
            } else {
                const rows = _lastAgg.rows.slice(0,30);
                chart.data.labels = rows.map(r=>String(r.key));
                chart.data.datasets[0].data = rows.map(r=>r.quantity);
                // If non pie/doughnut include records dataset
                if(!(cfg.chartType==='pie'||cfg.chartType==='doughnut')){
                    if(!chart.data.datasets[1]) chart.data.datasets.push({ label:'Records', data: rows.map(r=>r.records), backgroundColor:'#334155', borderColor:'#1e293b', borderWidth:1 });
                    else chart.data.datasets[1].data = rows.map(r=>r.records);
                } else if(chart.data.datasets[1]) chart.data.datasets.splice(1,1);
                // Adjust chart type if needed
                if(chart.config.type !== cfg.chartType && !(['pie','doughnut'].includes(cfg.chartType) && ['pie','doughnut'].includes(chart.config.type))){
                    try { chart.config.type = cfg.chartType; } catch(_){ }
                }
                chart.update();
            }
            // Update table header group label
            const hdr = wrap.querySelector('[data-col="groupHdr"]'); if(hdr) hdr.textContent = (entry.cfg.groupBy||'GROUP').toUpperCase();
        }

        function applyVizFilters(id){
            const entry=_vzSets.get(id); if(!entry) return;
            const wrap=entry.wrap;
            entry.cfg.groupBy = wrap.querySelector('select[data-filt="groupBy"]').value || 'day';
            const prev2 = entry.cfg.groupBy2;
            entry.cfg.groupBy2 = wrap.querySelector('select[data-filt="groupBy2"]').value || '';
            entry.cfg.chartType = wrap.querySelector('select[data-filt="chartType"]').value || 'bar';
            entry.cfg.start = wrap.querySelector('input[data-filt="start"]').value || '';
            entry.cfg.end = wrap.querySelector('input[data-filt="end"]').value || '';
            if(prev2 !== entry.cfg.groupBy2){ entry.selectedValues2=[]; populateVizValueFilterOptions2(id); }
            refreshVizSet(id);
            const summary = wrap.querySelector('[data-role="summary"]'); if(summary) summary.textContent = `${entry.cfg.groupBy}${(entry.cfg.start||entry.cfg.end)?` (${entry.cfg.start||'...'} to ${entry.cfg.end||'...'})`:''}`;
        }

        function applyVizPresetRange(id, range){
            const entry=_vzSets.get(id); if(!entry) return; const wrap=entry.wrap;
            const s=wrap.querySelector('input[data-filt="start"]'); const e=wrap.querySelector('input[data-filt="end"]'); if(!s||!e) return;
            if(range==='clear'){ s.value=''; e.value=''; }
            else {
                const today=new Date(); const endStr=today.toISOString().slice(0,10); let past=new Date(); if(range==='7d') past.setDate(today.getDate()-6); if(range==='30d') past.setDate(today.getDate()-29); const startStr=past.toISOString().slice(0,10); s.value=startStr; e.value=endStr; }
            applyVizFilters(id);
        }

        // ----- Value filter controls -----
        function populateVizValueFilterOptions(id){
            const entry=_vzSets.get(id); if(!entry) return;
            const agg = computeVizPivot(entry.cfg.groupBy, '', { start: entry.cfg.start, end: entry.cfg.end });
            const values = (agg.rows||[]).map(r=>String(r.key));
            const wrap=entry.wrap; const box=wrap.querySelector('[data-role="valueCheckboxes"]'); if(!box) return;
            box.innerHTML = values.map(v=>`<label class='flex items-center gap-1 px-1 py-0.5 hover:bg-slate-50'><input type='checkbox' value="${v.replace(/"/g,'&quot;')}" ${entry.selectedValues.length===0||entry.selectedValues.includes(v)?'checked':''}/> <span>${v}</span></label>`).join('');
            updateVizValueFilterLabel(entry);
            box.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', ()=>{ entry.selectedValues = Array.from(box.querySelectorAll('input:checked')).map(i=>i.value); refreshVizSet(id); updateVizValueFilterLabel(entry); }));
        }
        function populateVizValueFilterOptions2(id){
            const entry=_vzSets.get(id); if(!entry) return; if(!entry.cfg.groupBy2) { entry.selectedValues2=[]; updateVizValueFilter2Label(entry); return; }
            const agg = computeVizPivot(entry.cfg.groupBy, entry.cfg.groupBy2, { start: entry.cfg.start, end: entry.cfg.end, selectedValues: entry.selectedValues });
            const values = agg.colKeys || [];
            const wrap=entry.wrap; const box=wrap.querySelector('[data-role="valueCheckboxes2"]'); if(!box) return;
            box.innerHTML = values.map(v=>`<label class='flex items-center gap-1 px-1 py-0.5 hover:bg-slate-50'><input type='checkbox' value="${v.replace(/"/g,'&quot;')}" ${entry.selectedValues2.length===0||entry.selectedValues2.includes(v)?'checked':''}/> <span>${v}</span></label>`).join('');
            updateVizValueFilter2Label(entry);
            box.querySelectorAll('input[type=checkbox]').forEach(cb=> cb.addEventListener('change', ()=>{ entry.selectedValues2 = Array.from(box.querySelectorAll('input:checked')).map(i=>i.value); refreshVizSet(id); updateVizValueFilter2Label(entry); }));
        }
        function updateVizValueFilterLabel(entry){
            const lab = entry.wrap.querySelector('[data-role="valueFilterLabel"]'); if(!lab) return;
            lab.textContent = entry.selectedValues.length===0 ? 'All' : `${entry.selectedValues.length} selected`;
        }
        function updateVizValueFilter2Label(entry){
            const lab = entry.wrap.querySelector('[data-role="valueFilter2Label"]'); if(!lab) return;
            lab.textContent = (!entry.cfg.groupBy2 || entry.selectedValues2.length===0) ? 'All' : `${entry.selectedValues2.length} selected`;
        }
        function toggleVizValueDropdown(id){ const entry=_vzSets.get(id); if(!entry)return; const dd=entry.wrap.querySelector('[data-role="valueDropdown"]'); if(dd) dd.classList.toggle('hidden'); }
        function toggleVizValue2Dropdown(id){ const entry=_vzSets.get(id); if(!entry)return; const dd=entry.wrap.querySelector('[data-role="valueDropdown2"]'); if(dd) dd.classList.toggle('hidden'); }
        function toggleVizAllValues(id){ const entry=_vzSets.get(id); if(!entry)return; const box=entry.wrap.querySelector('[data-role="valueCheckboxes"]'); if(!box) return; const inputs=[...box.querySelectorAll('input[type=checkbox]')]; const allChecked=inputs.every(i=>i.checked); inputs.forEach(i=> i.checked=!allChecked); entry.selectedValues = allChecked? [] : inputs.map(i=>i.value); refreshVizSet(id); updateVizValueFilterLabel(entry); }
        function toggleVizAllValues2(id){ const entry=_vzSets.get(id); if(!entry)return; const box=entry.wrap.querySelector('[data-role="valueCheckboxes2"]'); if(!box) return; const inputs=[...box.querySelectorAll('input[type=checkbox]')]; const allChecked=inputs.every(i=>i.checked); inputs.forEach(i=> i.checked=!allChecked); entry.selectedValues2 = allChecked? [] : inputs.map(i=>i.value); refreshVizSet(id); updateVizValueFilter2Label(entry); }


        // ---------- Analytics: Saved Reports and Export for Charts ----------
        async function getReportsRef() {
            const user = window.authManager?.getCurrentUser?.();
            if (!user) return null;
            const companyId = user.companyId || 'default';
            return firebase.database().ref(`analyticsReports/${companyId}`);
        }

        async function loadSavedReportsOptions() {
            const sel = document.getElementById('anSavedReports');
            const ref = await getReportsRef();
            if (!sel || !ref) return;
            const snap = await ref.once('value');
            const reports = snap.exists() ? snap.val() : {};
            sel.innerHTML = '';
            Object.keys(reports).forEach(id => {
                const opt = document.createElement('option');
                opt.value = id; opt.textContent = reports[id]?.name || id;
                sel.appendChild(opt);
            });
        }

        function getCurrentChartConfigFromUI() {
            return {
                start: document.getElementById('anStart')?.value || '',
                end: document.getElementById('anEnd')?.value || '',
                granularity: document.getElementById('anGranularity')?.value || 'day',
                measure: document.getElementById('anMeasure')?.value || 'quantity',
                agg: document.getElementById('anAgg')?.value || 'sum',
                chartType: document.getElementById('anChartType')?.value || 'line',
                splitBy: document.getElementById('anSplitBy')?.value || '',
                fuelType: document.getElementById('anFuelType')?.value || '',
                equipment: document.getElementById('anEquipment')?.value || '',
                equipmentType: document.getElementById('anEquipmentType')?.value || '',
                department: document.getElementById('anDepartment')?.value || '',
                location: document.getElementById('anLocation')?.value || '',
                tank: document.getElementById('anTank')?.value || '',
                tankStatus: document.getElementById('anTankStatus')?.value || '',
                source: document.getElementById('anSource')?.value || '',
                operator: document.getElementById('anOperator')?.value || '',
                requestedBy: document.getElementById('anRequestedBy')?.value || '',
                distributionStatus: document.getElementById('anDistributionStatus')?.value || '',
                indexReading: document.getElementById('anIndexReading')?.value || '',
                updatedBy: document.getElementById('anUpdatedBy')?.value || '',
            };
        }

        async function saveCurrentReport() {
            const name = (document.getElementById('anReportName')?.value || '').trim();
            if (!name) return alert('Please enter a report name');
            const ref = await getReportsRef();
            if (!ref) return alert('Not authenticated');
            const config = getCurrentChartConfigFromUI();
            const key = ref.push().key;
            await ref.child(key).set({ name, config, updatedAt: Date.now() });
            await loadSavedReportsOptions();
            const sel = document.getElementById('anSavedReports'); if (sel) sel.value = key;
            alert('Report saved');
        }

        async function loadSelectedReport() {
            const sel = document.getElementById('anSavedReports');
            const id = sel?.value;
            const ref = await getReportsRef();
            if (!id || !ref) return;
            const snap = await ref.child(id).once('value');
            if (!snap.exists()) return;
            const { config } = snap.val();
            const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v ?? ''; };
            setVal('anStart', config.start);
            setVal('anEnd', config.end);
            setVal('anGranularity', config.granularity);
            setVal('anMeasure', config.measure);
            setVal('anAgg', config.agg);
            setVal('anChartType', config.chartType);
            setVal('anSplitBy', config.splitBy);
            setVal('anFuelType', config.fuelType);
            setVal('anEquipment', config.equipment);
            setVal('anEquipmentType', config.equipmentType);
            setVal('anDepartment', config.department);
            setVal('anLocation', config.location);
            setVal('anTank', config.tank);
            setVal('anTankStatus', config.tankStatus);
            setVal('anSource', config.source);
            setVal('anOperator', config.operator);
            setVal('anRequestedBy', config.requestedBy);
            setVal('anDistributionStatus', config.distributionStatus);
            setVal('anIndexReading', config.indexReading);
            setVal('anUpdatedBy', config.updatedBy);
            renderAnalyticsFromFilters();
        }

        async function deleteSelectedReport() {
            const sel = document.getElementById('anSavedReports');
            const id = sel?.value;
            const ref = await getReportsRef();
            if (!id || !ref) return;
            if (!confirm('Delete selected report?')) return;
            await ref.child(id).remove();
            await loadSavedReportsOptions();
        }

        function exportChartCSV() {
            if (!_anLastChartData) return;
            const { labels, datasets, chartType, metric } = _anLastChartData;
            if (!datasets || datasets.length===0) return;
            if (chartType==='pie' || chartType==='doughnut') {
                const header = ['Series', 'Total'];
                const rows = datasets.map(ds => [ds.label, (ds.data||[]).reduce((a,b)=>a+Number(b||0),0)]);
                return exportCSV([header, ...rows], `chart_${metric}_${Date.now()}.csv`);
            }
            const header = ['Series', ...labels];
            const rows = datasets.map(ds => [ds.label, ...ds.data]);
            exportCSV([header, ...rows], `chart_${metric}_${Date.now()}.csv`);
        }

        function exportChartPNG() {
            const canvas = document.getElementById('consumptionChart');
            if (!canvas) return;
            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = `chart_${Date.now()}.png`;
            a.click();
        }

        // ---------- Analytics: Sub-tabs and Pivot Engine ----------
        function showAnalyticsSubTab(name) {
            // Toggle buttons
            document.querySelectorAll('[data-an-tab]').forEach(btn => btn.classList.remove('active'));
            const btn = document.querySelector(`[data-an-tab="${name}"]`);
            if (btn) btn.classList.add('active');

            // Toggle panels
            const charts = document.getElementById('anChartsPanel');
            const pivot = document.getElementById('anPivotPanel');
            if (charts) charts.style.display = name === 'charts' ? 'block' : 'none';
            if (pivot) pivot.style.display = name === 'pivot' ? 'block' : 'none';
        }

        // ---------- Analytics: Raw records for pivot/chart ----------
        function getAnalyticsRawRecords() {
            if (!_anAllDistributionsCache || !_anAllDistributionsCache.data) return [];
            const records = Object.values(_anAllDistributionsCache.data || {});
            const out = [];
            for (const r of records) {
                if (!r || !r.timestamp || !r.fuel || !r.equipment) continue;
                const d = new Date(r.timestamp);
                if (isNaN(d)) continue;
                const qty = Number(r.fuel?.quantity ?? r.fuel?.requestedQuantity) || 0;
                if (!(qty > 0)) continue;
                // Resolve location strictly from storage status via tank identifier
                const rawTankForLoc = r.tankName || r.sourceTankName || r.tank || r.storage?.tankName || r.storage?.tank || r.fromTankName || r.fromTank || '';
                const locFromMap = (_anTankIdToLocation && rawTankForLoc) ? (_anTankIdToLocation[rawTankForLoc] || '') : '';
                const loc = friendlyLocationLabel(locFromMap) || locFromMap || '';
                const eqId = r.equipment?.id || r.equipment?.name || '';
                // Prefer a friendly mapping if the value is a coded tank ID
                const rawTank = r.tankName || r.sourceTankName || r.tank || r.storage?.tankName || r.storage?.tank || r.fromTankName || r.fromTank || '';
                const tankName = (window._tankIdDisplayMap && window._tankIdDisplayMap[rawTank]) ? window._tankIdDisplayMap[rawTank] : rawTank;
                out.push({
                    date: d,
                    equipment: eqId,
                    equipmentType: r.equipment?.type || '',
                    department: r.authorization?.department || '',
                    location: loc,
                    tank: tankName,
                    source: 'distribution',
                    fuelType: r.fuel?.type || '',
                    quantity: qty,
                    // Extra distribution detail columns (from tank details tab)
                    distributionId: r.id || r.key || '',
                    operator: r.equipment?.operator || '',
                    indexReading: r.fuel?.indexReading || r.indexReading || '',
                    requestedBy: r.authorization?.requestedBy || '',
                    distributionStatus: r.status || 'COMPLETED'
                });
            }
            // Add storage snapshot records (one per tank) for pivoting storage metrics
            if (_anStorageStatusCache && _anStorageStatusCache.data) {
                const tanks = Object.values(_anStorageStatusCache.data || {});
                for (const t of tanks) {
                    if (!t) continue;
                    const when = t.lastUpdated ? new Date(t.lastUpdated) : new Date();
                    // compute latest stock-after if available
                    let computedStock = undefined;
                    try {
                        if (!window._lastStockAfterByTank || typeof window._lastStockAfterByTank !== 'object') {
                            // compute once; this is inside analytics path so tolerate async lag
                            // note: cannot await in non-async function; charts path already awaits compute; pivot/raw may fall back safely
                        }
                        const tid = t.tankId || t.tankIdDisplay || '';
                        if (tid && window._lastStockAfterByTank) computedStock = Number(window._lastStockAfterByTank[tid] || 0);
                    } catch (_) {}
                    out.push({
                        date: when,
                        equipment: '',
                        equipmentType: '',
                        department: '',
                        location: friendlyLocationLabel(t.location || t.site || t.area || ''),
                        tank: t.tankIdDisplay || t.tankId || '',
                        source: 'storage',
                        fuelType: '',
                        quantity: undefined,
                        // Opening vs closing semantics
                        openingStock: Number(t.currentVolume || 0),
                        currentStock: computedStock!=null ? computedStock : Number(t.currentVolume || 0),
                        // Keep legacy field for pivot compatibility (maps to Closing Stock below)
                        currentVolume: computedStock!=null ? computedStock : Number(t.currentVolume || 0),
                        ullage: (()=>{ const maxV=Number(t.maxVolume||0); const base = computedStock!=null?computedStock:Number(t.currentVolume||0); return Math.max(0, maxV - base); })(),
                        capacityPct: (()=>{ const maxV=Number(t.maxVolume||0); const base = computedStock!=null?computedStock:Number(t.currentVolume||0); return maxV>0 ? (base/maxV)*100 : 0; })(),
                        tankStatus: t.status || '',
                        maxVolume: Number(t.maxVolume || 0),
                        updatedBy: t.updatedBy || '',
                        stockDate: t.stockDate || '',
                        lastUpdated: t.lastUpdated || ''
                    });
                }
            }
            return out;
        }

        function timeBucket(date, granularity) {
            const y = date.getFullYear();
            const m = (date.getMonth()+1).toString().padStart(2,'0');
            const d = date.getDate().toString().padStart(2,'0');
            if (granularity === 'month') return `${y}-${m}`;
            if (granularity === 'week') {
                const tmp = new Date(date);
                const dayNum = (date.getDay() + 6) % 7; // Mon=0
                tmp.setDate(date.getDate() - dayNum + 3);
                const firstThursday = new Date(tmp.getFullYear(),0,4);
                const weekNo = 1 + Math.round(((tmp - firstThursday) / 86400000 - 3 + ((firstThursday.getDay()+6)%7)) / 7);
                return `${tmp.getFullYear()}-W${weekNo.toString().padStart(2,'0')}`;
            }
            return `${y}-${m}-${d}`; // day
        }

        // Pivot configuration and UI (Excel-like)
        const PIVOT_FIELDS = [
            { key:'time', label:'Time' },
            { key:'equipment', label:'Equipment' },
            { key:'equipmentType', label:'Equipment Type' },
            { key:'department', label:'Department' },
            { key:'location', label:'Location' },
            { key:'fuelType', label:'Fuel Type' },
            { key:'tank', label:'Tank' },
            { key:'tankStatus', label:'Tank Status' },
            { key:'source', label:'Source' },
            // Distribution Details columns
            { key:'operator', label:'Operator' },
            { key:'requestedBy', label:'Requested By' },
            { key:'distributionStatus', label:'Distribution Status' },
            { key:'indexReading', label:'Index Reading' },
            // Storage Status columns
            { key:'updatedBy', label:'Updated By' },
            { key:'stockDate', label:'Stock Date' },
            { key:'lastUpdated', label:'Last Updated' },
            { key:'maxVolume', label:'Max Volume (L)' },
        ];
        const PIVOT_MEASURES = [
            { key:'quantity', label:'Quantity (L)', aggs:['sum','avg','min','max'] },
            { key:'count', label:'Count', aggs:['count'] },
            // currentVolume holds the computed closing stock in analytics records for compatibility
            { key:'currentVolume', label:'Closing Stock (L)', aggs:['sum','avg','min','max'] },
            // expose opening stock explicitly for analysis
            { key:'openingStock', label:'Opening Stock (L)', aggs:['sum','avg','min','max'] },
            { key:'ullage', label:'Ullage (L)', aggs:['sum','avg','min','max'] },
            { key:'capacityPct', label:'Capacity %', aggs:['avg','sum','min','max'] },
            { key:'maxVolume', label:'Max Volume (L)', aggs:['sum','avg','min','max'] },
        ];
        const SHOW_AS = [
            { key:'none', label:'No calculation' },
            { key:'pctGrand', label:'% of Grand Total' },
            { key:'pctRow', label:'% of Row Total' },
            { key:'pctCol', label:'% of Column Total' },
        ];
        let _pivotConfig = { 
            rows: ['time'], 
            columns: [], 
            filters: [], 
            values: [{ measure:'quantity', agg:'sum', showAs:'none' }], 
            granularity: 'day',
            startDate: null,
            endDate: null
        };

        function initPivotUI() {
            // left lists removed; we rely on the dropdowns above each area
            // dropdowns (in addition to drag & drop)
            const fill = (sel, options, placeholder, kind) => {
                if (!sel) return;
                sel.innerHTML = '';
                const def = document.createElement('option'); def.value=''; def.textContent = placeholder; sel.appendChild(def);
                options.forEach(o => { const opt=document.createElement('option'); opt.value=o.key; opt.textContent=o.label; sel.appendChild(opt); });
                sel.onchange = () => {
                    const val = sel.value;
                    if (!val) return;
                    if (kind === 'rows') addToPivotArea('rows', val);
                    if (kind === 'columns') addToPivotArea('columns', val);
                    if (kind === 'filters') addToPivotArea('filters', val);
                    if (kind === 'values') addToPivotArea('values', val);
                    sel.value = '';
                };
            };
            fill(document.getElementById('pivotAddRow'), PIVOT_FIELDS, 'Add row fieldâ€¦', 'rows');
            fill(document.getElementById('pivotAddColumn'), PIVOT_FIELDS, 'Add column fieldâ€¦', 'columns');
            fill(document.getElementById('pivotAddFilter'), PIVOT_FIELDS, 'Add filter fieldâ€¦', 'filters');
            fill(document.getElementById('pivotAddValue'), PIVOT_MEASURES, 'Add value (measure)â€¦', 'values');
            // dropzones
            setupPivotDnD();
            // granularity
            const granSel = document.getElementById('anPivotGranularity');
            if (granSel) {
                granSel.value = _pivotConfig.granularity;
                granSel.onchange = () => { _pivotConfig.granularity = granSel.value; buildPivot(); };
            }
            
            // date range controls
            const startDateEl = document.getElementById('anPivotStartDate');
            const endDateEl = document.getElementById('anPivotEndDate');
            const preset30El = document.getElementById('anPivotPresetLast30');
            const presetMonthEl = document.getElementById('anPivotPresetThisMonth');
            
            // Set default dates (last 30 days)
            const today = new Date();
            const last30 = new Date();
            last30.setDate(today.getDate() - 30);
            const formatDate = (d) => d.toISOString().slice(0, 10);
            
            if (startDateEl) {
                startDateEl.value = _pivotConfig.startDate || formatDate(last30);
                startDateEl.onchange = () => { 
                    _pivotConfig.startDate = startDateEl.value; 
                    buildPivot(); 
                };
            }
            if (endDateEl) {
                endDateEl.value = _pivotConfig.endDate || formatDate(today);
                endDateEl.onchange = () => { 
                    _pivotConfig.endDate = endDateEl.value; 
                    buildPivot(); 
                };
            }
            
            // Preset buttons
            if (preset30El) {
                preset30El.onclick = () => {
                    const end = new Date();
                    const start = new Date();
                    start.setDate(end.getDate() - 30);
                    if (startDateEl) startDateEl.value = formatDate(start);
                    if (endDateEl) endDateEl.value = formatDate(end);
                    _pivotConfig.startDate = formatDate(start);
                    _pivotConfig.endDate = formatDate(end);
                    buildPivot();
                };
            }
            if (presetMonthEl) {
                presetMonthEl.onclick = () => {
                    const now = new Date();
                    const start = new Date(now.getFullYear(), now.getMonth(), 1);
                    const end = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    if (startDateEl) startDateEl.value = formatDate(start);
                    if (endDateEl) endDateEl.value = formatDate(end);
                    _pivotConfig.startDate = formatDate(start);
                    _pivotConfig.endDate = formatDate(end);
                    buildPivot();
                };
            }
            
            // Initialize config dates if not set
            if (!_pivotConfig.startDate) _pivotConfig.startDate = formatDate(last30);
            if (!_pivotConfig.endDate) _pivotConfig.endDate = formatDate(today);
            
            // initial render
            refreshPivotAreasFromConfig();
            buildPivot();
        }

        function makeDraggableFieldChip(text, key, kind) {
            const div = document.createElement('div');
            div.className = 'pivot-field';
            div.draggable = true;
            div.dataset.fieldKey = key;
            div.dataset.fieldKind = kind; // 'field' or 'measure'
            div.textContent = text;
            div.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ key, kind }));
            });
            return div;
        }

        function setupPivotDnD() {
            document.querySelectorAll('.pivot-drop').forEach(zone => {
                zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.style.background = '#f1f5f9'; });
                zone.addEventListener('dragleave', () => { zone.style.background = '#fff'; });
                zone.addEventListener('drop', (e) => {
                    e.preventDefault(); zone.style.background = '#fff';
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        const area = zone.getAttribute('data-dropzone');
                        if (!area) return;
                        if (area === 'values' && data.kind !== 'measure') return;
                        if ((area === 'rows' || area === 'columns' || area === 'filters') && data.kind !== 'field') return;
                        addToPivotArea(area, data.key);
                    } catch (_) {}
                });
            });
        }

        function addToPivotArea(area, key) {
            if (area === 'rows') { if (!_pivotConfig.rows.includes(key)) _pivotConfig.rows.push(key); }
            else if (area === 'columns') { if (!_pivotConfig.columns.includes(key)) _pivotConfig.columns.push(key); }
            else if (area === 'filters') { if (!_pivotConfig.filters.includes(key)) _pivotConfig.filters.push(key); }
            else if (area === 'values') {
                const existing = _pivotConfig.values.find(v => v.measure === key);
                if (!existing) _pivotConfig.values.push({ measure:key, agg: (PIVOT_MEASURES.find(m=>m.key===key)?.aggs[0] || 'sum'), showAs:'none' });
            }
            refreshPivotAreasFromConfig();
            buildPivot();
        }

        function removeFromPivotArea(area, key) {
            if (area === 'rows') _pivotConfig.rows = _pivotConfig.rows.filter(k => k !== key);
            else if (area === 'columns') _pivotConfig.columns = _pivotConfig.columns.filter(k => k !== key);
            else if (area === 'filters') _pivotConfig.filters = _pivotConfig.filters.filter(k => k !== key);
            else if (area === 'values') _pivotConfig.values = _pivotConfig.values.filter(v => v.measure !== key);
            refreshPivotAreasFromConfig();
            buildPivot();
        }

        function chip(title, area, key, isValue=false) {
            const c = document.createElement('span');
            c.className = 'pivot-chip' + (isValue? ' value-chip' : '');
            c.innerHTML = `<span>${title}</span>`;
            const remove = document.createElement('button');
            remove.textContent = 'Ã—';
            remove.title = 'Remove';
            remove.onclick = () => removeFromPivotArea(area, key);
            c.appendChild(remove);
            if (isValue) {
                const v = _pivotConfig.values.find(v => v.measure === key);
                const aggSel = document.createElement('select');
                aggSel.className = 'tiny-btn';
                (PIVOT_MEASURES.find(m=>m.key===key)?.aggs || ['sum']).forEach(a => {
                    const opt = document.createElement('option'); opt.value=a; opt.textContent=a.toUpperCase(); aggSel.appendChild(opt);
                });
                aggSel.value = v.agg; aggSel.onchange = () => { v.agg = aggSel.value; buildPivot(); };
                c.appendChild(aggSel);
                const showSel = document.createElement('select'); showSel.className='tiny-btn';
                SHOW_AS.forEach(s => { const opt=document.createElement('option'); opt.value=s.key; opt.textContent=s.label; showSel.appendChild(opt); });
                showSel.value = v.showAs; showSel.onchange = () => { v.showAs = showSel.value; buildPivot(); };
                c.appendChild(showSel);
            }
            return c;
        }

        function refreshPivotAreasFromConfig() {
            const map = {
                rows: document.getElementById('pivotDropRows'),
                columns: document.getElementById('pivotDropColumns'),
                filters: document.getElementById('pivotDropFilters'),
                values: document.getElementById('pivotDropValues'),
            };
            if (map.rows) {
                map.rows.innerHTML = '';
                _pivotConfig.rows.forEach(k => map.rows.appendChild(chip(titleCase(k), 'rows', k)));
            }
            if (map.columns) {
                map.columns.innerHTML = '';
                _pivotConfig.columns.forEach(k => map.columns.appendChild(chip(titleCase(k), 'columns', k)));
            }
            if (map.filters) {
                map.filters.innerHTML = '';
                _pivotConfig.filters.forEach(k => map.filters.appendChild(chip(titleCase(k), 'filters', k)));
            }
            if (map.values) {
                map.values.innerHTML = '';
                _pivotConfig.values.forEach(v => map.values.appendChild(chip(PIVOT_MEASURES.find(m=>m.key===v.measure)?.label || v.measure, 'values', v.measure, true)));
            }
        }

        function buildPivot() {
            let records = getAnalyticsRawRecords();
            
            // Apply date filtering if dates are set
            if (_pivotConfig.startDate || _pivotConfig.endDate) {
                const startDate = _pivotConfig.startDate ? new Date(_pivotConfig.startDate) : null;
                const endDate = _pivotConfig.endDate ? new Date(_pivotConfig.endDate) : null;
                
                records = records.filter(r => {
                    if (!r.date) return false;
                    const recordDate = new Date(r.date);
                    if (isNaN(recordDate)) return false;
                    
                    if (startDate && recordDate < startDate) return false;
                    if (endDate) {
                        // Make end date inclusive by adding 24 hours - 1 millisecond
                        const endOfDay = new Date(endDate.getTime() + 24 * 60 * 60 * 1000 - 1);
                        if (recordDate > endOfDay) return false;
                    }
                    return true;
                });
            }
            
            const gran = (document.getElementById('anPivotGranularity')?.value) || _pivotConfig.granularity || 'day';
            // Build distinct ordered keys for columns
            const colKeySet = new Set();
            const rowKeySet = new Set();
            const makeKey = (r, fields) => fields.map(f => f==='time' ? timeBucket(r.date, gran) : (r[f] || '')).join(' | ');
            for (const r of records) {
                const rk = makeKey(r, _pivotConfig.rows);
                const ck = makeKey(r, _pivotConfig.columns);
                rowKeySet.add(rk);
                colKeySet.add(ck);
            }
            const rowKeys = [...rowKeySet].sort();
            const colKeys = [...colKeySet].sort();
            const hasColumnDims = (_pivotConfig.columns && _pivotConfig.columns.length > 0);

            // Aggregate measures per cell
            const cellMap = new Map(); // rk -> ck -> measure -> { sum,count,min,max }
            const ensureCell = (rk, ck, measure) => {
                if (!cellMap.has(rk)) cellMap.set(rk, new Map());
                const row = cellMap.get(rk);
                if (!row.has(ck)) row.set(ck, new Map());
                const col = row.get(ck);
                if (!col.has(measure)) col.set(measure, { sum:0, count:0, min:Infinity, max:-Infinity, values: [] });
                return col.get(measure);
            };
            for (const r of records) {
                const rk = makeKey(r, _pivotConfig.rows);
                const ck = makeKey(r, _pivotConfig.columns);
                for (const v of _pivotConfig.values) {
                    const measure = v.measure;
                    const agg = ensureCell(rk, ck, measure);
                    let val = 0;
                    if (measure === 'count') {
                        val = 1;
                    } else if (measure === 'quantity') {
                        val = Number(r.quantity || 0);
                    } else if (measure === 'currentVolume') {
                        val = Number(r.currentVolume || 0);
                    } else if (measure === 'ullage') {
                        val = Number(r.ullage || 0);
                    } else if (measure === 'capacityPct') {
                        val = Number(r.capacityPct || 0);
                    }
                    agg.count += 1;
                    agg.sum += val;
                    agg.min = Math.min(agg.min, val);
                    agg.max = Math.max(agg.max, val);
                    agg.values.push(r);
                }
            }

            // Precompute totals for Show As
            const totals = {}; // measure -> { grand, perRow, perCol }
            for (const v of _pivotConfig.values) {
                const m = v.measure;
                let grand = 0; const perRow = new Map(); const perCol = new Map();
                for (const rk of rowKeys) {
                    let rowTotal = 0;
                    for (const ck of colKeys) {
                        const agg = cellMap.get(rk)?.get(ck)?.get(m);
                        if (!agg) continue;
                        rowTotal += agg.sum; // base on sum for totals
                        perCol.set(ck, (perCol.get(ck)||0) + agg.sum);
                    }
                    perRow.set(rk, rowTotal);
                    grand += rowTotal;
                }
                totals[m] = { grand, perRow, perCol };
            }

            // Build table
            const thead = document.getElementById('anPivotHead');
            const tbody = document.getElementById('anPivotBody');
            const tfoot = document.getElementById('anPivotFoot');
            if (!thead || !tbody || !tfoot) return;
            thead.innerHTML = ''; tbody.innerHTML = ''; tfoot.innerHTML = '';

            const values = _pivotConfig.values;
            // Flat header: Rows label + (for each colKey and for each value) a column
            const headRow = document.createElement('tr');
            const rowHdr = document.createElement('th');
            rowHdr.textContent = _pivotConfig.rows.length ? _pivotConfig.rows.map(titleCase).join(' / ') : 'All';
            headRow.appendChild(rowHdr);
            const colHeaderLabels = colKeys.length ? colKeys : [''];
            for (const ck of colHeaderLabels) {
                for (const v of values) {
                    const th = document.createElement('th');
                    const valTitle = (PIVOT_MEASURES.find(m=>m.key===v.measure)?.label || v.measure) + ' (' + v.agg.toUpperCase() + (v.showAs!=='none'? ' | ' + SHOW_AS.find(s=>s.key===v.showAs)?.label : '') + ')';
                    if (hasColumnDims) {
                        th.textContent = (ck || 'Total') + (values.length>1? (' / ' + valTitle) : '');
                        if (values.length===1) th.title = valTitle;
                    } else {
                        // No column dimensions: show only the measure title as header
                        th.textContent = valTitle;
                    }
                    headRow.appendChild(th);
                }
            }
            if (hasColumnDims) {
                const thGrand = document.createElement('th'); thGrand.textContent = 'Total'; headRow.appendChild(thGrand);
            }
            thead.appendChild(headRow);

            // Body
            for (const rk of rowKeys) {
                const tr = document.createElement('tr');
                const tdLabel = document.createElement('td'); tdLabel.textContent = rk || 'All'; tr.appendChild(tdLabel);
                for (const ck of colHeaderLabels) {
                    for (const v of values) {
                        const td = document.createElement('td');
                        const agg = cellMap.get(rk)?.get(ck)?.get(v.measure);
                        let val = 0;
                        if (agg) {
                            if (v.agg==='count') val = agg.count;
                            else if (v.agg==='avg') val = agg.count? agg.sum/agg.count : 0;
                            else if (v.agg==='min') val = agg.min===Infinity? 0 : agg.min;
                            else if (v.agg==='max') val = agg.max===-Infinity? 0 : agg.max;
                            else val = agg.sum;
                            // Show As
                            if (v.showAs==='pctGrand') val = totals[v.measure].grand ? (val / totals[v.measure].grand) * 100 : 0;
                            if (v.showAs==='pctRow') val = totals[v.measure].perRow.get(rk) ? (val / totals[v.measure].perRow.get(rk)) * 100 : 0;
                            if (v.showAs==='pctCol') val = totals[v.measure].perCol.get(ck) ? (val / totals[v.measure].perCol.get(ck)) * 100 : 0;
                        }
                        td.textContent = formatNumber(val);
                        tr.appendChild(td);
                    }
                }
                // Row total (only when there are column dimensions)
                if (hasColumnDims) {
                    const tdTotal = document.createElement('td');
                    const firstVal = values[0];
                    let rowTotal = totals[firstVal.measure].perRow.get(rk) || 0;
                    if (firstVal.agg==='avg') {
                        // average of all cells average isn't straightforward; using sum/ count approximation per row
                    }
                    if (firstVal.showAs==='pctGrand') rowTotal = totals[firstVal.measure].grand ? (rowTotal / totals[firstVal.measure].grand) * 100 : 0;
                    if (firstVal.showAs==='pctRow') rowTotal = 100;
                    if (firstVal.showAs==='pctCol') {
                        // Not well-defined for row total; use % of grand for now
                        rowTotal = totals[firstVal.measure].grand ? (rowTotal / totals[firstVal.measure].grand) * 100 : 0;
                    }
                    tdTotal.textContent = formatNumber(rowTotal);
                    tr.appendChild(tdTotal);
                }
                tbody.appendChild(tr);
            }

            // Footer totals
            const footRow = document.createElement('tr');
            const ftLabel = document.createElement('th'); ftLabel.textContent = 'Grand Total'; footRow.appendChild(ftLabel);
            for (const ck of colHeaderLabels) {
                for (const v of values) {
                    const th = document.createElement('th');
                    let colTotal = totals[v.measure].perCol.get(ck) || 0;
                    if (v.showAs==='pctGrand') colTotal = totals[v.measure].grand ? (colTotal / totals[v.measure].grand) * 100 : 0;
                    if (v.showAs==='pctRow') {
                        // Not well-defined for column total; use % of grand for now
                        colTotal = totals[v.measure].grand ? (colTotal / totals[v.measure].grand) * 100 : 0;
                    }
                    if (v.showAs==='pctCol') colTotal = 100;
                    th.textContent = formatNumber(colTotal);
                    footRow.appendChild(th);
                }
            }
            if (hasColumnDims) {
                const ftGrand = document.createElement('th');
                const first = values[0];
                let grand = totals[first.measure].grand || 0;
                if (first.showAs==='pctGrand') grand = 100;
                if (first.showAs==='pctRow' || first.showAs==='pctCol') grand = 100; // simplified
                ftGrand.textContent = formatNumber(grand);
                footRow.appendChild(ftGrand);
            }
            tfoot.appendChild(footRow);
        }

        function titleCase(s){return s? s.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase()):''}
        function titleForMetric(m){
            return m==='count'? 'Count' : m==='avg'? 'Average (L)' : m==='min'? 'Min (L)' : m==='max'? 'Max (L)' : 'Total (L)';
        }
        function valueForMetric(metric, cell){
            if (metric==='count') return cell.count;
            if (metric==='avg') return cell.count? cell.sum/cell.count : 0;
            if (metric==='min') return cell.min===Infinity? 0 : cell.min;
            if (metric==='max') return cell.max===-Infinity? 0 : cell.max;
            return cell.sum;
        }
        function metricTotal(metric, agg){
            if (metric==='count') return agg.count||0;
            if (metric==='avg') return agg.count? agg.sum/agg.count : 0;
            if (metric==='min') return agg.min===Infinity? 0 : agg.min;
            if (metric==='max') return agg.max===-Infinity? 0 : agg.max;
            return agg.sum||0;
        }
        function formatNumber(n){
            if (typeof n !== 'number' || !isFinite(n)) return '0';
            return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
        }

        function openDrilldown(rowLabel, colLabel, values) {
            const body = document.getElementById('anDrillBody');
            if (!body) return;
            body.innerHTML = '';
            for (const r of values) {
                const tr = document.createElement('tr');
                const d = r.date instanceof Date ? r.date : new Date(r.date);
                const cells = [
                    isNaN(d) ? '' : d.toISOString().split('T')[0],
                    r.equipment||'', r.equipmentType||'', r.department||'', r.location||'', r.tank||'', r.fuelType||'', formatNumber(Number(r.quantity||0))
                ];
                for (const c of cells) {
                    const td = document.createElement('td');
                    td.textContent = c;
                    tr.appendChild(td);
                }
                body.appendChild(tr);
            }
            const title = document.getElementById('anDrillTitle');
            if (title) title.textContent = `${rowLabel||'All'} ${colLabel? ' | '+colLabel: ''}`;
            const modal = document.getElementById('anDrillModal');
            if (modal){ modal.classList.add('show'); }
        }

        function exportCSV(rows, filename) {
            const csv = rows.map(r => r.map(v => {
                if (v==null) return '';
                const s = String(v).replace(/"/g,'""');
                return s.includes(',') || s.includes('"') || s.includes('\n') ? `"${s}"` : s;
            }).join(',')).join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
        }

        function exportPivotCSV() {
            // Recompute using current table DOM for simplicity
            const thead = document.getElementById('anPivotHead');
            const tbody = document.getElementById('anPivotBody');
            if (!thead || !tbody) return;
            const headerCells = [...thead.querySelectorAll('tr:last-child th')].map(th => th.textContent || '');
            const rows = [[...headerCells]];
            tbody.querySelectorAll('tr').forEach(tr => {
                const cells = [...tr.querySelectorAll('td')].map(td => td.textContent || '');
                rows.push(cells);
            });
            exportCSV(rows, `pivot_${Date.now()}.csv`);
        }

        function exportRawCSV() {
            const records = getAnalyticsRawRecords();
            const header = [
                'Date','Source','Equipment','Equipment Type','Department','Location','Tank','Fuel Type',
                'Quantity (L)','Opening Stock (L)','Closing Stock (L)','Ullage (L)','Capacity %','Tank Status','Max Volume (L)',
                // Distribution Details extras
                'Distribution ID','Operator','Index Reading','Requested By','Distribution Status',
                // Storage Status extras
                'Updated By','Stock Date','Last Updated'
            ];
            const rows = records.map(r => [
                (r.date instanceof Date ? r.date : new Date(r.date)).toISOString().split('T')[0],
                r.source || 'distribution',
                r.equipment || '',
                r.equipmentType || '',
                r.department || '',
                r.location || '',
                r.tank || '',
                r.fuelType || '',
                r.quantity!=null ? Number(r.quantity||0) : '',
                r.openingStock!=null ? Number(r.openingStock||0) : (r.currentVolume!=null ? Number(r.currentVolume||0) : ''),
                r.currentStock!=null ? Number(r.currentStock||0) : '',
                r.ullage!=null ? Number(r.ullage||0) : '',
                r.capacityPct!=null ? Number(r.capacityPct||0) : '',
                r.tankStatus || '',
                r.maxVolume!=null ? Number(r.maxVolume||0) : '',
                // Distribution details
                r.distributionId || '',
                r.operator || '',
                r.indexReading || '',
                r.requestedBy || '',
                r.distributionStatus || '',
                // Storage status
                r.updatedBy || '',
                r.stockDate || '',
                r.lastUpdated || ''
            ]);
            exportCSV([header, ...rows], `analytics_raw_${Date.now()}.csv`);
        }

        function wirePivotControls() {
            const expBtn = document.getElementById('anExportPivotBtn');
            const expRawBtn = document.getElementById('anExportRawBtn');
            if (expBtn) expBtn.onclick = exportPivotCSV;
            if (expRawBtn) expRawBtn.onclick = exportRawCSV;
            // sub-tab buttons are wired elsewhere; initialize the new pivot UI
            initPivotUI();
        }

        // Wire pivot controls on load (UI exists in DOM)
        document.addEventListener('DOMContentLoaded', () => {
            wirePivotControls();
        });

        // Show/hide details empty state
        function showDetailsEmptyState(show) {
            const emptyState = document.getElementById('detailsEmptyState');
            const table = document.querySelector('#detailsTab .table-container');
            
            if (show) {
                emptyState.style.display = 'flex';
                table.style.display = 'none';
            } else {
                emptyState.style.display = 'none';
                table.style.display = 'block';
            }
        }

        // View individual tank distributions
        async function viewTankDistributions(tankId, dailyOnly=false, explicitStockDate=null, openingStockForDay=null) {
            // Store the selected tank ID for filtering
            // Store on both window and local variable to ensure refresh works reliably
            window.selectedTankId = tankId;
            window._tankDailyOnly = !!dailyOnly;
            try { selectedTankId = tankId; } catch (_) {}

            // If user is requesting a daily view with a stock date, shift to the previous calendar day
            // and (best-effort) fetch the opening stock for that previous day to keep running stock accurate
            let effectiveStockISO = explicitStockDate || null;
            if (dailyOnly && explicitStockDate) {
                try {
                    const base = new Date(explicitStockDate);
                    if (!isNaN(base.getTime())) {
                        // Compute previous day at the same local time as provided
                        const prev = new Date(base.getFullYear(), base.getMonth(), base.getDate() - 1, base.getHours(), base.getMinutes(), base.getSeconds(), base.getMilliseconds());
                        effectiveStockISO = prev.toISOString();

                        // Attempt to read daily snapshot for opening stock on previous day (YYYY-MM-DD)
                        const y = prev.getFullYear();
                        const m = String(prev.getMonth() + 1).padStart(2, '0');
                        const d = String(prev.getDate()).padStart(2, '0');
                        const dateKey = `${y}-${m}-${d}`;
                        try {
                            const companyId = window.authManager?.getCurrentUser()?.companyId;
                            if (companyId && (window.getDatabase || (window.firebase && window.firebase.database))) {
                                let snap;
                                if (window.getDatabase && window.ref && window.get) {
                                    const db = window.getDatabase();
                                    const refPath = window.ref(db, `companies/${companyId}/fuelmanagement/storageStatusDaily/${tankId}/${dateKey}`);
                                    snap = await window.get(refPath);
                                    if (snap && snap.exists && snap.exists()) {
                                        const v = snap.val();
                                        if (v && typeof v.currentVolume === 'number') {
                                            window._openingStockForDay = Number(v.currentVolume) || 0;
                                        } else {
                                            // Clear so downstream falls back to tank meta
                                            try { delete window._openingStockForDay; } catch(_) { window._openingStockForDay = null; }
                                        }
                                    }
                                } else {
                                    const db = window.firebase.database();
                                    const refPath = db.ref(`companies/${companyId}/fuelmanagement/storageStatusDaily/${tankId}/${dateKey}`);
                                    const v8snap = await refPath.once('value');
                                    if (v8snap && v8snap.exists()) {
                                        const v = v8snap.val();
                                        if (v && typeof v.currentVolume === 'number') {
                                            window._openingStockForDay = Number(v.currentVolume) || 0;
                                        } else {
                                            try { delete window._openingStockForDay; } catch(_) { window._openingStockForDay = null; }
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // Non-blocking: if snapshot lookup fails, clear so default baseline is used
                            try { delete window._openingStockForDay; } catch(_) { window._openingStockForDay = null; }
                            console.warn('Prev-day opening stock lookup failed:', e);
                        }
                    }
                } catch (e) {
                    console.warn('Failed to compute previous day for tank distributions:', e);
                }
            } else if (openingStockForDay!=null) {
                // Preserve provided baseline only when we are not shifting the date
                window._openingStockForDay = Number(openingStockForDay) || 0;
            }

            if (effectiveStockISO) window._explicitStockDate = effectiveStockISO;

            // Switch to details tab
            switchTab('details');
            // Default the tank-specific range to All to honor the user's request
            try { const sel = document.getElementById('tankDetailsDateFilter'); if (sel) sel.value = 'all'; } catch(_){ }
            
            // Load distributions for this specific tank using the effective (previous-day) stock date when applicable
            await loadTankSpecificDistributions(tankId, dailyOnly, effectiveStockISO || explicitStockDate || null);
        }

        // Load distributions for a specific tank
    async function loadTankSpecificDistributions(tankId, dailyOnly=false, explicitStockDate=null) {
            try {
                // Clear any stale cached calc context for this tank before reload
                if (window._tankDistCalcContext && window._tankDistCalcContext[tankId]) {
                    try { delete window._tankDistCalcContext[tankId]; } catch (_) {}
                }
                const companyId = window.authManager?.getCurrentUser()?.companyId;
                if (!companyId) {
                    console.log('No company ID found for tank distributions');
                    showTankDistributionsEmptyState(true, tankId);
                    return;
                }

                // Get date filter
                const daysFilter = parseInt(document.getElementById('detailsDateFilter').value) || 30;
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - daysFilter);

                // Load distributions and transfers from Firebase
                const distributionsRef = firebase.database().ref(`fuelDistributions/${companyId}`);
                const transfersRef = firebase.database().ref(`companies/${companyId}/fuelmanagement/transfers`);
                const [snapshot, transfersSnap] = await Promise.all([
                    distributionsRef.once('value'),
                    transfersRef.once('value')
                ]);

                if (!snapshot.exists()) {
                    showTankDistributionsEmptyState(true, tankId);
                    return;
                }

                const distributions = snapshot.val();
                const transfers = transfersSnap.exists() ? transfersSnap.val() : {};
                const tankDistributions = [];
                const tankTransfers = [];

                // Gather tank meta for accurate stock calculations
                let tankMeta = null;
                try {
                    if (window.fuelStorageManager && Array.isArray(window.fuelStorageManager.tanks)) {
                        tankMeta = window.fuelStorageManager.tanks.find(t => (t.tankId || t.tankIdDisplay) === tankId) || null;
                    }
                } catch (e) { /* ignore */ }
                const maxVolume = tankMeta?.maxVolume ? Number(tankMeta.maxVolume) : 0;
                const startStock = tankMeta?.currentVolume ? Number(tankMeta.currentVolume) : 0;
                let stockDate = tankMeta?.stockDate ? new Date(tankMeta.stockDate) : null;
                if (dailyOnly && explicitStockDate) {
                    try { stockDate = new Date(explicitStockDate); } catch { /* keep existing */ }
                }
                if (dailyOnly && window._explicitStockDate) {
                    try { stockDate = new Date(window._explicitStockDate); } catch { }
                }
                // If dailyOnly is requested, compute the day window from the tank's stockDate
                const stockDayStart = stockDate ? new Date(stockDate.getFullYear(), stockDate.getMonth(), stockDate.getDate(), 0, 0, 0, 0) : null;
                const stockDayEnd = stockDate ? new Date(stockDate.getFullYear(), stockDate.getMonth(), stockDate.getDate(), 23, 59, 59, 999) : null;

                // Precompute consumption before the visible window but after stockDate (if present)
                let preWindowConsumption = 0;
                if (!dailyOnly) {
                    Object.values(distributions).forEach(dist => {
                        if (!dist || !dist.equipment || !dist.fuel) return;
                        const distTankIdAll = dist.equipment.location || dist.equipment.locationName || '';
                        if (!(distTankIdAll === tankId || distTankIdAll.toLowerCase() === tankId.toLowerCase())) return;
                        // Use consumption date/time from schedule when available
                        let consISO = null;
                        try {
                            if (dist.schedule && dist.schedule.date && dist.schedule.time) {
                                consISO = new Date(`${dist.schedule.date}T${dist.schedule.time}`).toISOString();
                            }
                        } catch (e) { /* ignore */ }
                        const effective = consISO || dist.timestamp;
                        if (!effective) return;
                        const dt = new Date(effective);
                        if (stockDate && dt < stockDate) return; // only after stock date
                        if (dt >= cutoffDate) return; // only before current window
                        const qtyAll = Number(dist.fuel?.quantity ?? dist.fuel?.requestedQuantity) || 0;
                        preWindowConsumption += qtyAll;
                    });
                }

                // Filter distributions for this specific tank
                Object.values(distributions).forEach(dist => {
                    if (!dist || !dist.equipment || !dist.fuel) return;

                    // Use consumption date/time from schedule when available
                    let consISO = null;
                    try {
                        if (dist.schedule && dist.schedule.date && dist.schedule.time) {
                            consISO = new Date(`${dist.schedule.date}T${dist.schedule.time}`).toISOString();
                        }
                    } catch (e) { /* ignore */ }
                    const effectiveISO = consISO || dist.timestamp;
                    if (!effectiveISO) return;
                    const distDate = new Date(effectiveISO);
                    if (dailyOnly && stockDayStart && stockDayEnd) {
                        if (!(distDate >= stockDayStart && distDate <= stockDayEnd)) return;
                    } else {
                        const tankDfSel = document.getElementById('tankDetailsDateFilter');
                        const tankDf = tankDfSel?.value || '30';
                        if (tankDf !== 'all' && distDate < cutoffDate) return;
                    }

                    const distTankId = dist.equipment.location || dist.equipment.locationName || '';
                    
                    // Match tank by ID (flexible matching)
                    if (distTankId === tankId || 
                        distTankId.toLowerCase() === tankId.toLowerCase() ||
                        dist.equipment.locationName === tankId) {
                        // Determine a stable id for rendering/mapping
                        const distKey = (function(){
                            try {
                                return Object.keys(distributions).find(key => distributions[key] === dist) || undefined;
                            } catch (e) { return undefined; }
                        })();
                        
                        tankDistributions.push({
                            id: dist.id || distKey || `dist-${Date.now()}-${Math.random().toString(36).slice(2,8)}`,
                            // For distributions, timestamp should reflect consumption date/time
                            timestamp: effectiveISO,
                            equipmentId: dist.equipment.id || 'N/A',
                            equipmentType: dist.equipment.type || 'N/A',
                            operator: dist.equipment.operator || 'N/A',
                            quantity: Number(dist.fuel?.quantity ?? dist.fuel?.requestedQuantity) || 0,
                            equipmentLocation: dist.equipment.location || dist.equipment.locationName || '',
                            indexReading: dist.fuel.indexReading || 'N/A',
                            requestedBy: dist.authorization?.requestedBy || 'N/A',
                            department: dist.authorization?.department || 'N/A',
                            status: dist.status || 'COMPLETED',
                            _kind: 'distribution'
                        });
                    }
                });

                // Collect transfers for this specific tank (incoming/outgoing)
                Object.entries(transfers || {}).forEach(([key, tr]) => {
                    if (!tr || !tr.transferDate || !tr.transferQuantity) return;
                    const dt = new Date(tr.transferDate);
                    if (dailyOnly && stockDayStart && stockDayEnd) {
                        if (!(dt >= stockDayStart && dt <= stockDayEnd)) return;
                    } else {
                        const tankDfSel = document.getElementById('tankDetailsDateFilter');
                        const tankDf = tankDfSel?.value || '30';
                        if (tankDf !== 'all' && dt < cutoffDate) return;
                    }
                    const qty = Number(tr.transferQuantity) || 0;
                    const src = (tr.sourceTank || '').trim();
                    const dst = (tr.destinationTank || '').trim();
                    const tid = (tankId || '').trim();
                    if (!src && !dst) return;
                    // Case-insensitive comparison to avoid mismatch
                    if (src && src.toLowerCase() === tid.toLowerCase()) {
                        tankTransfers.push({
                            id: tr.id || key || `tr-${Date.now()}-${Math.random().toString(36).slice(2,8)}`,
                            fbKey: key,
                            timestamp: tr.transferDate,
                            quantity: -qty,
                            direction: 'out',
                            otherTank: dst || 'â€”',
                            indexReading: tr.sourceIndexReading || 'N/A',
                            requestedBy: tr.requestedBy || 'N/A',
                            department: tr.department || 'N/A',
                            status: tr.status || 'COMPLETED',
                            _kind: 'transfer'
                        });
                    } else if (dst && dst.toLowerCase() === tid.toLowerCase()) {
                        tankTransfers.push({
                            id: tr.id || key || `tr-${Date.now()}-${Math.random().toString(36).slice(2,8)}`,
                            fbKey: key,
                            timestamp: tr.transferDate,
                            quantity: +qty,
                            direction: 'in',
                            otherTank: src || 'â€”',
                            indexReading: tr.destinationIndexReading || 'N/A',
                            requestedBy: tr.requestedBy || 'N/A',
                            department: tr.department || 'N/A',
                            status: tr.status || 'COMPLETED',
                            _kind: 'transfer'
                        });
                    }
                });

                // Merge distributions and transfers into a single event list
                // and de-duplicate in case of duplicate Firebase events or reloads
                const merged = [...tankDistributions, ...tankTransfers];
                const seen = new Map();
                for (const ev of merged) {
                    const key = ev.fbKey || ev.id || `${ev._kind}-${ev.timestamp}-${ev.quantity}-${ev.direction || ''}-${ev.otherTank || ''}`;
                    if (!seen.has(key)) {
                        seen.set(key, ev);
                    }
                }
                const events = Array.from(seen.values());
                // Sort by timestamp (newest first)
                events.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Stash calc context for render
                window._tankDistCalcContext = window._tankDistCalcContext || {};
                window._tankDistCalcContext[tankId] = {
                    startStock: (dailyOnly && (window._openingStockForDay!=null)) ? Number(window._openingStockForDay) : startStock,
                    stockDate: stockDate ? stockDate.toISOString() : null,
                    preWindowConsumption,
                    cutoffDate: cutoffDate.toISOString(),
                    maxVolume // keep for reference if needed elsewhere
                };

                renderTankDistributions(tankId, events);

            } catch (error) {
                console.error('Error loading tank distributions:', error);
                showTankDistributionsEmptyState(true, tankId);
            }
        }

        // Global variable for selected tank
        let selectedTankId = null;
        
        // Function to show distribution summary view
        function showDistributionSummary() {
            document.getElementById('distributionSummaryView').style.display = 'block';
            document.getElementById('tankDistributionsView').style.display = 'none';
            selectedTankId = null;
            window._tankDailyOnly = false;
            
            // Sync the date filter
            const summaryFilter = document.getElementById('detailsDateFilter');
            const tankFilter = document.getElementById('tankDetailsDateFilter');
            summaryFilter.value = tankFilter.value;
            
            // Reload summary data
            loadDistributionDetails();
        }
        
        // Function to refresh tank-specific distributions
        function refreshTankDistributions() {
            const tId = (typeof selectedTankId !== 'undefined' && selectedTankId) ? selectedTankId : window.selectedTankId;
            if (tId) {
                const dailyOnly = !!window._tankDailyOnly;
                const explicitStockDate = window._explicitStockDate || null;
                loadTankSpecificDistributions(tId, dailyOnly, explicitStockDate);
            }
        }

        // Function to render tank-specific distributions
    function renderTankDistributions(tankId, distributions) {
            selectedTankId = tankId;
            
            // Show tank distributions view and hide summary
            document.getElementById('distributionSummaryView').style.display = 'none';
            document.getElementById('tankDistributionsView').style.display = 'block';
            
            // Sync date filters
            const summaryFilter = document.getElementById('detailsDateFilter');
            const tankFilter = document.getElementById('tankDetailsDateFilter');
            tankFilter.value = summaryFilter.value;
            
            const tbody = document.getElementById('tankDistributionsBody');
            
            if (distributions.length === 0) {
                showTankDistributionsEmptyState(true, tankId);
                return;
            }
            
            showTankDistributionsEmptyState(false, tankId);
            
            // Compute running "stock after" per distribution using precomputed context
            const ctx = (window._tankDistCalcContext && window._tankDistCalcContext[tankId]) || null;
            const startStock = ctx?.startStock ?? 0;
            const stockDate = ctx?.stockDate ? new Date(ctx.stockDate) : null;
            const preWindowConsumption = ctx?.preWindowConsumption || 0;
            const dailyOnly = !!window._tankDailyOnly;

            // Sort a copy ascending by time for proper running calculation from earliest to latest
            const asc = [...distributions].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            let runningStock = null;
            // Baseline: for daily view (stock date day), start from opening stock; else subtract pre-window consumption
            runningStock = dailyOnly
                ? Math.max(0, Number(startStock) || 0)
                : Math.max(0, (Number(startStock) || 0) - (preWindowConsumption || 0));

            // Map id->stockAfter in ascending order, respecting stockDate cutoff if present
            const stockAfterById = {};
            for (const d of asc) {
                const dt = new Date(d.timestamp);
                if (stockDate && dt < stockDate) {
                    // Skip consumption before stock date for running calc
                    continue;
                }
                const qtyRaw = Number(d.quantity) || 0;
                // Interpret quantities: distributions subtract; transfers use signed qty from events (+in, -out)
                const qty = (d._kind === 'transfer') ? qtyRaw : qtyRaw; // tankTransfers already set sign; distributions are positive consumption
                if (runningStock == null) {
                    // If we don't have maxVolume, fall back to cumulative from 0 (still provides relative info)
                    runningStock = 0;
                }
                // For distributions (qty positive), subtract; for transfer in (qty positive), add; for transfer out (qty negative), subtract => equivalent to runningStock - distQty + transferQty
                runningStock = Math.max(0, runningStock - (d._kind === 'distribution' ? qty : 0) + (d._kind === 'transfer' ? qty : 0));
                stockAfterById[d.id] = Math.round(runningStock * 100) / 100;
            }

            // Render rows in the original (newest-first) order but display computed stockAfter
            tbody.innerHTML = distributions.map(dist => {
                const stockAfter = stockAfterById.hasOwnProperty(dist.id) ? `${stockAfterById[dist.id]} L` : 'â€”';
                let transferCell = '';
                if (dist._kind === 'transfer') {
                    const isIn = dist.direction === 'in' || (Number(dist.quantity) > 0);
                    const label = isIn ? `Reception from ${dist.otherTank}` : `Transfer to ${dist.otherTank}`;
                    const color = isIn ? 'style="color:#059669;font-weight:600;"' : 'style="color:#b91c1c;font-weight:600;"';
                    const deleteBtn = `<button class="delete-transfer-btn" data-key="${dist.fbKey || dist.id}" title="Delete transfer" style="margin-left:8px; background:none; border:none; color:#dc2626; cursor:pointer;"><i class="fa fa-trash"></i></button>`;
                    transferCell = `<td ${color}><div style="display:flex; align-items:center; justify-content:space-between; gap:8px;"><span>${label}</span>${deleteBtn}</div></td>`;
                } else {
                    transferCell = '<td style="color:#64748b;">â€”</td>';
                }
                return `
                <tr>
                    <td class="hidden-col">${dist.id}</td>
                    <td>${new Date(dist.timestamp).toLocaleString()}</td>
                    <td>
                        <div class="equipment-info">
                            <strong>${dist.equipmentId || 'â€”'}</strong>
                        </div>
                    </td>
                    <td class="hidden-col">${dist.operator}</td>
                    <td class="quantity-cell">
                        <span class="quantity-badge">${dist.quantity} L</span>
                    </td>
                    <td>${stockAfter}</td>
                    ${transferCell}
                    <td>${dist.indexReading || 'N/A'}</td>
                    <td class="hidden-col">${dist.requestedBy}</td>
                    <td>${dist.department}</td>
                    <td class="hidden-col">
                        <span class="status-badge status-${dist.status.toLowerCase()}">${dist.status}</span>
                    </td>
                </tr>`;
            }).join('');

            // Wire up delete buttons for transfer rows
            try {
                tbody.querySelectorAll('.delete-transfer-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const key = btn.getAttribute('data-key');
                        if (!key) return;
                        await deleteTransferFromStorage(key);
                    });
                });
            } catch (e) { console.warn('Failed to attach delete handlers:', e); }
        }

        // Delete a transfer directly from storage details view
        async function deleteTransferFromStorage(transferKey) {
            try {
                if (!confirm('Are you sure you want to delete this transfer?')) return;
                const companyId = window.authManager?.getCurrentUser()?.companyId;
                if (!companyId || !transferKey) {
                    alert('Missing company or transfer key.');
                    return;
                }
                // Prefer v8 compat if available
                if (window.getDatabase && window.ref && window.remove) {
                    const db = window.getDatabase();
                    const pathRef = window.ref(db, `companies/${companyId}/fuelmanagement/transfers/${transferKey}`);
                    await window.remove(pathRef);
                } else if (window.firebase && window.firebase.database) {
                    await window.firebase.database().ref(`companies/${companyId}/fuelmanagement/transfers/${transferKey}`).remove();
                } else {
                    alert('Firebase not initialized.');
                    return;
                }
                // Refresh computed stocks and current view
                try { await computeLastStockAfterTransactions(); } catch (_) {}
                try { if (typeof refreshTankDistributions === 'function') refreshTankDistributions(); } catch (_) {}
            } catch (error) {
                console.error('Failed to delete transfer from storage view:', error);
                alert('Failed to delete transfer. See console for details.');
            }
        }

        // Function to show/hide tank distributions empty state
        function showTankDistributionsEmptyState(show, tankId = '') {
            const emptyState = document.getElementById('tankDistributionsEmptyState');
            const table = document.getElementById('tankDistributionsTable');
            
            if (show) {
                emptyState.style.display = 'block';
                table.style.display = 'none';
                document.getElementById('tankEmptyTitle').textContent = `No Distributions Found for Tank: ${tankId}`;
                document.getElementById('tankEmptyMessage').textContent = 
                    `No fuel distributions found for tank "${tankId}" in the selected period.`;
            } else {
                emptyState.style.display = 'none';
                table.style.display = 'table';
            }
        }

        // Function to update tank volumes based on distribution consumption
        async function updateTankVolumesBasedOnConsumption() {
            try {
                const companyId = window.authManager?.getCurrentUser()?.companyId;
                if (!companyId) {
                    console.log('No company ID found for volume updates');
                    return;
                }

                console.log('ðŸ”„ Updating tank volumes based on consumption...');

                // Get all tanks and distributions
                const tanksRef = firebase.database().ref(`companies/${companyId}/fuelmanagement/storageStatus`);
                const distributionsRef = firebase.database().ref(`fuelDistributions/${companyId}`);

                const [tanksSnapshot, distributionsSnapshot] = await Promise.all([
                    tanksRef.once('value'),
                    distributionsRef.once('value')
                ]);

                if (!tanksSnapshot.exists()) {
                    console.log('No tanks found for volume updates');
                    return;
                }

                const tanks = tanksSnapshot.val();
                const distributions = distributionsSnapshot.val() || {};

                // Calculate consumption for each tank
                const tankConsumption = {};
                
                Object.values(distributions).forEach(dist => {
                    if (!dist || !dist.equipment || !dist.fuel || !dist.timestamp) return;
                    
                    const tankId = dist.equipment.location || dist.equipment.locationName || '';
                    const quantity = parseFloat(dist.fuel.quantity) || 0;
                    const distDate = new Date(dist.timestamp);
                    
                    if (!tankConsumption[tankId]) {
                        tankConsumption[tankId] = {
                            totalConsumed: 0,
                            lastDistribution: null,
                            distributions: []
                        };
                    }
                    
                    tankConsumption[tankId].totalConsumed += quantity;
                    tankConsumption[tankId].distributions.push({
                        date: distDate,
                        quantity: quantity,
                        id: dist.id || Object.keys(distributions).find(key => distributions[key] === dist)
                    });
                    
                    if (!tankConsumption[tankId].lastDistribution || distDate > tankConsumption[tankId].lastDistribution) {
                        tankConsumption[tankId].lastDistribution = distDate;
                    }
                });

                // Update tank volumes
                const updates = {};
                let updatedCount = 0;

                Object.entries(tanks).forEach(([tankKey, tank]) => {
                    if (!tank || !tank.tankId) return;
                    
                    const tankId = tank.tankId || tank.tankIdDisplay;
                    const consumption = tankConsumption[tankId];
                    
                    // If there's no consumption data or no stockDate, do not override manual currentVolume
                    if (!tank.stockDate || !consumption) return;
                    
                    const stockDate = new Date(tank.stockDate);
                    const distsAfterStock = consumption.distributions.filter(d => d.date >= stockDate);
                    if (distsAfterStock.length === 0) return; // Nothing to consume since stock date

                    // Baseline starting stock should be the volume at stock date (set when user saved the tank)
                    const baseline = typeof tank.baselineVolumeAtStockDate === 'number' 
                        ? tank.baselineVolumeAtStockDate 
                        : (typeof tank.currentVolume === 'number' ? tank.currentVolume : 0);

                    const consumptionAfterStock = distsAfterStock.reduce((sum, d) => sum + (Number(d.quantity) || 0), 0);
                    let newCurrentVolume = Math.max(0, baseline - consumptionAfterStock);
                    
                    // Only update if there's a meaningful change
                    if (Math.abs(newCurrentVolume - (tank.currentVolume || 0)) > 0.01) {
                        const capacityPercentage = tank.maxVolume > 0 ? (newCurrentVolume / tank.maxVolume) * 100 : 0;
                        const ullage = (tank.maxVolume || 0) - newCurrentVolume;
                        
                        // Determine new status
                        let status = 'Normal';
                        if (capacityPercentage >= 95) {
                            status = 'Full';
                        } else if (capacityPercentage >= 80) {
                            status = 'High';
                        } else if (capacityPercentage >= 50) {
                            status = 'Normal';
                        } else if (capacityPercentage >= 20) {
                            status = 'Low';
                        } else {
                            status = 'Critical';
                        }
                        
                        updates[`companies/${companyId}/fuelmanagement/storageStatus/${tankKey}`] = {
                            ...tank,
                            currentVolume: Math.round(newCurrentVolume * 100) / 100, // Round to 2 decimal places
                            capacityPercentage: Math.round(capacityPercentage * 100) / 100,
                            ullage: Math.round(ullage * 100) / 100,
                            status: status,
                            lastUpdated: new Date().toISOString(),
                            updatedBy: window.authManager?.currentUser?.email || 'System Auto-Update',
                            lastVolumeUpdate: new Date().toISOString(),
                            consumptionBasedUpdate: true
                        };
                        
                        updatedCount++;
                        console.log(`ðŸ“Š Tank ${tankId}: ${tank.currentVolume || 0}L â†’ ${newCurrentVolume}L (consumed since stock date: ${consumptionAfterStock}L)`);
                    }
                });

                // Apply updates to Firebase
                if (Object.keys(updates).length > 0) {
                    await firebase.database().ref().update(updates);
                    console.log(`âœ… Updated ${updatedCount} tank volumes based on consumption`);
                    
                    // Refresh local data and UI
                    if (window.fuelStorageManager) {
                        await window.fuelStorageManager.loadTanksFromFirebase();
                        window.fuelStorageManager.renderTanks();
                    }
                    
                    return updatedCount;
                } else {
                    console.log('ðŸ“Š All tank volumes are already up to date');
                    return 0;
                }

            } catch (error) {
                console.error('âŒ Error updating tank volumes:', error);
                throw error;
            }
        }

        // Compute per-tank last stock after the last transaction (Distributions - consumption, Transfers +/-) and cache it for UI rendering
        async function computeLastStockAfterTransactions() {
            try {
                const companyId = window.authManager?.getCurrentUser()?.companyId;
                if (!companyId) return;

                // Use tanks already loaded in memory if available
                const tanks = (window.fuelStorageManager && Array.isArray(window.fuelStorageManager.tanks))
                    ? window.fuelStorageManager.tanks
                    : [];

                if (!tanks.length) return;

                const distributionsRef = firebase.database().ref(`fuelDistributions/${companyId}`);
                const [distSnap, transfersSnap] = await Promise.all([
                    distributionsRef.once('value'),
                    firebase.database().ref(`companies/${companyId}/fuelmanagement/transfers`).once('value')
                ]);
                const distributions = distSnap.exists() ? distSnap.val() : {};
                const transfers = transfersSnap.exists() ? transfersSnap.val() : {};

                const lastStockMap = {};

                // Build a quick list of distributions grouped by tankId
                const distByTank = {};
                Object.values(distributions).forEach(dist => {
                    if (!dist || !dist.equipment || !dist.fuel || !dist.timestamp) return;
                    const tankId = dist.equipment.location || dist.equipment.locationName || '';
                    if (!tankId) return;
                    const qty = Number(dist.fuel?.quantity ?? dist.fuel?.requestedQuantity) || 0;
                    const dt = new Date(dist.timestamp);
                    if (!distByTank[tankId]) distByTank[tankId] = [];
                    distByTank[tankId].push({ dt, qty });
                });

                // Build transfer delta grouped by tankId: outgoing (-qty) for source, incoming (+qty) for destination
                const transferByTank = {};
                Object.values(transfers || {}).forEach(tr => {
                    if (!tr || !tr.transferQuantity || !tr.transferDate) return;
                    const qty = Number(tr.transferQuantity) || 0;
                    const dt = new Date(tr.transferDate);
                    const src = tr.sourceTank || '';
                    const dst = tr.destinationTank || '';
                    if (src) {
                        if (!transferByTank[src]) transferByTank[src] = [];
                        transferByTank[src].push({ dt, qty: -qty });
                    }
                    if (dst) {
                        if (!transferByTank[dst]) transferByTank[dst] = [];
                        transferByTank[dst].push({ dt, qty: +qty });
                    }
                });

                tanks.forEach(tank => {
                    const tid = tank.tankId || tank.tankIdDisplay || '';
                    if (!tid) return;

                    const baseline = (typeof tank.baselineVolumeAtStockDate === 'number')
                        ? tank.baselineVolumeAtStockDate
                        : (typeof tank.currentVolume === 'number' ? tank.currentVolume : 0);

                    // If we don't have a stock date, fall back to currentVolume plus net transfers (no reliable baseline timeline)
                    if (!tank.stockDate) {
                        const netTransfersAllTime = (transferByTank[tid] || [])
                            .reduce((sum, x) => sum + (Number(x.qty) || 0), 0);
                        lastStockMap[tid] = Math.max(0, (Number(tank.currentVolume) || 0) + netTransfersAllTime);
                        return;
                    }

                    const stockDate = new Date(tank.stockDate);
                    const list = distByTank[tid] || [];
                    // Sum all consumption after the stock date
                    const consumed = list
                        .filter(x => x.dt >= stockDate)
                        .reduce((sum, x) => sum + (x.qty || 0), 0);

                    // Net transfers after stock date (incoming positive, outgoing negative)
                    const transferList = transferByTank[tid] || [];
                    const netTransfers = transferList
                        .filter(x => x.dt >= stockDate)
                        .reduce((sum, x) => sum + (Number(x.qty) || 0), 0);

                    const lastStock = Math.max(0, (Number(baseline) || 0) - consumed + netTransfers);
                    lastStockMap[tid] = Math.round(lastStock * 100) / 100;
                });

                window._lastStockAfterByTank = lastStockMap;
                // Trigger re-render if manager is present
                if (window.fuelStorageManager) {
                    window.fuelStorageManager.renderTanks();
                }
            } catch (e) {
                console.warn('âš ï¸ Failed to compute last stock after transactions:', e);
            }
        }

        // Function to auto-update volumes and recompute current stock when distributions or transfers change
        async function scheduleVolumeUpdates() {
            try {
                // Update volumes immediately
                await updateTankVolumesBasedOnConsumption();
                // Also compute last-stock-after-transactions once
                await computeLastStockAfterTransactions();
                
                // Set up periodic updates every 5 minutes
                setInterval(async () => {
                    try {
                        await updateTankVolumesBasedOnConsumption();
                        await computeLastStockAfterTransactions();
                    } catch (error) {
                        console.error('âŒ Scheduled volume update failed:', error);
                    }
                }, 5 * 60 * 1000); // 5 minutes

                // Real-time listeners for immediate UI updates when data changes
                const companyId = window.authManager?.getCurrentUser()?.companyId;
                if (companyId && window.firebase && window.firebase.database) {
                    const distRef = firebase.database().ref(`fuelDistributions/${companyId}`);
                    const transfersRef = firebase.database().ref(`companies/${companyId}/fuelmanagement/transfers`);
                    distRef.on('value', async () => {
                        await computeLastStockAfterTransactions();
                        // If a specific tank details view is open, refresh it to reflect distribution updates
                        try { if (typeof refreshTankDistributions === 'function') refreshTankDistributions(); } catch (_) {}
                    });
                    transfersRef.on('value', async () => {
                        await computeLastStockAfterTransactions();
                        // If a specific tank details view is open, refresh it to reflect transfer additions/edits/deletions
                        try { if (typeof refreshTankDistributions === 'function') refreshTankDistributions(); } catch (_) {}
                    });
                }
                
            } catch (error) {
                console.error('âŒ Error setting up volume updates:', error);
            }
        }

        // Enhanced initialization - use feature-based authorization by default
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize table filtering
            initializeTableFilters();
            
            // Wait for auth manager to be ready
            setTimeout(async () => {
                try {
                    resetMenuVisibility();
                    await updateMenuWithFeatureAuthorization();
                    
                    // Initialize automatic volume updates based on consumption
                    setTimeout(async () => {
                        try {
                            await scheduleVolumeUpdates();
                        } catch (error) {
                            console.error('âŒ Error initializing volume updates:', error);
                        }
                    }, 2000);
                    
                } catch (error) {
                    console.error('âŒ Error initializing feature-based menu:', error);
                    await showBasicMenu();
                } finally {
                    document.querySelector('.sidebar')?.classList.remove('menu-loading');
                }
            }, 800);

            // Initialize tab functionality
            switchTab('storage'); // Default to storage tab
        });

        // Table filtering functionality
        function initializeTableFilters() {
            const filterInputs = document.querySelectorAll('.column-filter');
            
            filterInputs.forEach(input => {
                input.addEventListener('input', applyTableFilters);
                input.addEventListener('change', applyTableFilters);
            });
        }

        function applyTableFilters() {
            const table = document.getElementById('storageTable');
            const tbody = document.getElementById('storageTableBody');
            const rows = tbody.querySelectorAll('tr');
            const filterInputs = document.querySelectorAll('.column-filter');
            
            // Get all filter values
            const filters = {};
            filterInputs.forEach(input => {
                const column = parseInt(input.dataset.column);
                const value = input.value.toLowerCase().trim();
                if (value) {
                    filters[column] = {
                        value: value,
                        type: input.type
                    };
                }
            });

            // Filter rows
            let visibleRows = 0;
            rows.forEach(row => {
                let shouldShow = true;
                const cells = row.querySelectorAll('td');
                
                // Check each filter
                Object.keys(filters).forEach(columnIndex => {
                    const filter = filters[columnIndex];
                    const cell = cells[columnIndex];
                    
                    if (!cell) return;
                    
                    const cellText = cell.textContent.toLowerCase().trim();
                    
                    switch (filter.type) {
                        case 'text':
                            if (!cellText.includes(filter.value)) {
                                shouldShow = false;
                            }
                            break;
                            
                        case 'number':
                            const cellNumber = parseFloat(cellText.replace(/[^\d.-]/g, ''));
                            const filterNumber = parseFloat(filter.value);
                            if (isNaN(cellNumber) || isNaN(filterNumber) || cellNumber < filterNumber) {
                                shouldShow = false;
                            }
                            break;
                            
                        case 'date':
                            // Prefer normalized attribute when available (set on Stock Date column)
                            const filterDate = new Date(filter.value);
                            const filterDateStr = formatDateForComparison(filterDate);
                            let cellDateStr = '';

                            // If this is the Stock Date column (index 7) or Last Update (index 10), try reading data-ymd
                            const ymdAttr = cell.getAttribute && cell.getAttribute('data-ymd');
                            if (ymdAttr) {
                                cellDateStr = ymdAttr;
                            } else {
                                // Fallback to parsing visible text
                                const cellDate = extractDateFromCell(cellText);
                                if (cellDate) {
                                    cellDateStr = formatDateForComparison(cellDate);
                                }
                            }

                            if (!filterDateStr || !cellDateStr || cellDateStr !== filterDateStr) {
                                shouldShow = false;
                            }
                            break;
                            
                        default: // select elements
                            if (!cellText.includes(filter.value)) {
                                shouldShow = false;
                            }
                            break;
                    }
                });

                // Show/hide row
                if (shouldShow) {
                    row.style.display = '';
                    visibleRows++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Update empty state visibility
            const emptyState = document.getElementById('storageEmptyState');
            const tableContainer = document.querySelector('.table-container');
            const filterStatus = document.getElementById('filterStatus');
            
            // Update filter status
            const totalRows = rows.length;
            const hasActiveFilters = Object.keys(filters).length > 0;
            
            if (hasActiveFilters) {
                filterStatus.textContent = `Showing ${visibleRows} of ${totalRows} records`;
                filterStatus.style.display = 'block';
            } else {
                filterStatus.style.display = 'none';
            }
            
            if (visibleRows === 0 && rows.length > 0) {
                // Show "no results" message for filtered state
                tableContainer.style.display = 'none';
                emptyState.style.display = 'block';
                emptyState.innerHTML = `
                    <i class="fas fa-search"></i>
                    <h3>No Matching Records</h3>
                    <p>No tanks match the current filter criteria. Try adjusting your filters.</p>
                `;
            } else if (rows.length === 0) {
                // Show original empty state
                tableContainer.style.display = 'none';
                emptyState.style.display = 'block';
                emptyState.innerHTML = `
                    <i class="fas fa-oil-can"></i>
                    <h3>No Tank Records</h3>
                    <p>Start by adding fuel tank status information.</p>
                `;
            } else {
                // Show table
                tableContainer.style.display = 'block';
                emptyState.style.display = 'none';
            }
        }

        // Helper function to extract date from cell text
        function extractDateFromCell(cellText) {
            // Skip empty or N/A cells
            if (!cellText || cellText === 'n/a' || cellText === 'N/A') {
                return null;
            }
            
            // Try to match various date formats
            const datePatterns = [
                /(\d{4}-\d{2}-\d{2})/,  // YYYY-MM-DD
                /(\d{1,2}\/\d{1,2}\/\d{4})/,  // M/D/YYYY or MM/DD/YYYY
                /(\d{2}\/\d{2}\/\d{4})/,  // MM/DD/YYYY
                /(\d{2}-\d{2}-\d{4})/,   // MM-DD-YYYY
                /(\d{1,2}-\d{1,2}-\d{4})/,   // M-D-YYYY
                /(\d{4}\/\d{2}\/\d{2})/,  // YYYY/MM/DD
                /(\d{1,2}\.\d{1,2}\.\d{4})/  // M.D.YYYY or MM.DD.YYYY (European format)
            ];
            
            for (const pattern of datePatterns) {
                const match = cellText.match(pattern);
                if (match) {
                    const dateStr = match[1];
                    let date;
                    
                    // Handle different formats
                    if (dateStr.includes('/')) {
                        // For MM/DD/YYYY or M/D/YYYY format
                        const parts = dateStr.split('/');
                        if (parts.length === 3) {
                            const month = parseInt(parts[0]);
                            const day = parseInt(parts[1]);
                            const year = parseInt(parts[2]);
                            date = new Date(year, month - 1, day);
                        }
                    } else if (dateStr.includes('.')) {
                        // For MM.DD.YYYY format (European)
                        const parts = dateStr.split('.');
                        if (parts.length === 3) {
                            const month = parseInt(parts[0]);
                            const day = parseInt(parts[1]);
                            const year = parseInt(parts[2]);
                            date = new Date(year, month - 1, day);
                        }
                    } else {
                        // For other formats, try direct parsing
                        date = new Date(dateStr);
                    }
                    
                    if (date && !isNaN(date.getTime())) {
                        return date;
                    }
                }
            }
            
            // Fallback: try direct parsing of the text
            const fallbackDate = new Date(cellText);
            if (!isNaN(fallbackDate.getTime())) {
                return fallbackDate;
            }
            
            return null;
        }

        // Helper function to check if date is valid
        function isValidDate(date) {
            return date instanceof Date && !isNaN(date.getTime());
        }

        // Helper function to format date for comparison (YYYY-MM-DD)
        function formatDateForComparison(date) {
            if (!isValidDate(date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Clear all filters function
        function clearAllFilters() {
            const filterInputs = document.querySelectorAll('.column-filter');
            filterInputs.forEach(input => {
                input.value = '';
            });
            applyTableFilters();
        }
    </script>
</body>
</html>
