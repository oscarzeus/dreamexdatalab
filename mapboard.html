<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Environmental Monitoring Map - Dreamex Datalab HSE</title>
    <!-- Firebase v8 CDN (match other pages) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet.draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <meta name="robots" content="noindex, nofollow">
    <style>
        /* === Core Variables / Layout (derived from accessdaily.html) === */
        :root { --primary-color:#2c3e50; --secondary-color:#3498db; --accent-color:#3498db; --text-color:#333; --bg-color:#f5f6fa; --sidebar-width:250px; --blue:#3498db; --green:#2ecc71; --orange:#e67e22; --red:#e74c3c; --purple:#9b59b6; --font-family:'Inter',system-ui,-apple-system,sans-serif; --base-font-size:.9rem; --font-scale:1; --bg-primary:#ffffff; --bg-secondary:#f8f9fa; --text-primary:#333; --text-secondary:#666; --border-color:#e0e0e0; --spacing-unit:.9rem; --padding-sm:.45rem; --padding-md:.75rem; --padding-lg:1.2rem; --transition-speed:.2s; }
        *{margin:0;padding:0;box-sizing:border-box;} body{font-family:var(--font-family);font-size:var(--base-font-size);line-height:1.4;color:var(--text-primary);background:#f8f9fa;}
        .app-container{display:flex;min-height:100vh;}
        .sidebar{width:var(--sidebar-width);background:var(--primary-color);color:#fff;padding:1rem;position:fixed;height:100vh;overflow-y:auto;transition:transform .3s ease;}
        .sidebar.collapsed{transform:translateX(-100%);} .logo h2{text-align:center;padding:1rem 0;border-bottom:1px solid rgba(255,255,255,.1);font-size:1.05rem;}
        .menu{list-style:none;margin-top:1.5rem;} .menu li{margin-bottom:.45rem;} .menu a{color:#fff;text-decoration:none;display:flex;align-items:center;padding:.65rem .9rem;border-radius:6px;font-size:.78rem;gap:.55rem;letter-spacing:.25px;transition:background .25s;} .menu a:hover,.menu a.active{background:var(--secondary-color);} .menu-dropdown .submenu{display:none;list-style:none;margin-left:1.2rem;margin-top:.35rem;} .menu-dropdown:hover .submenu{display:block;}
        /* Feature-based visibility */
        [data-feature]:not(.menu-visible){display:none !important;} .menu-dropdown:not(.menu-visible){display:none !important;} 
        
        /* Hide ALL menu items by default during loading */
        .sidebar.menu-loading .menu-item, .sidebar.menu-loading .menu-dropdown, .sidebar.menu-loading li[data-feature], .sidebar.menu-loading [data-feature] {display:none !important;} .menu-loading [data-feature]{display:none !important;} .menu-loading .menu-dropdown{display:none !important;}
        .main-content{flex:1;margin-left:var(--sidebar-width);padding:.45rem;width:calc(100% - var(--sidebar-width));box-sizing:border-box;display:flex;flex-direction:column;transition:margin-left .3s ease,width .3s ease;}
        .main-content.sidebar-collapsed{margin-left:0;width:100%;}
        /* Top Nav */
        .top-nav{display:flex;justify-content:space-between;align-items:center;padding:.5rem .75rem;background:#fff;box-shadow:0 2px 5px rgba(0,0,0,.1);margin-bottom:.35rem;position:fixed;top:.25rem;right:.5rem;left:calc(var(--sidebar-width) + .5rem);height:50px;min-height:50px;z-index:100;transition:left .3s ease;}
        .top-nav.sidebar-collapsed{left:.5rem;}
        .top-nav-left{display:flex;align-items:center;gap:1rem;font-size:.8rem;font-weight:600;color:var(--text-secondary);} .sidebar-toggle-btn{background:none;border:none;cursor:pointer;font-size:1.15rem;padding:.45rem;color:#666;border-radius:6px;display:flex;align-items:center;justify-content:center;} .sidebar-toggle-btn:hover{background:rgba(0,0,0,.06);}
        #headerCompanyLogo{width:44px;height:44px;border-radius:6px;object-fit:cover;display:none;background:#fff;border:1px solid #d0d7de;box-shadow:0 1px 2px rgba(0,0,0,.08);} #headerCompanyLogo.visible{display:block;} #headerCompanyName{font-size:.8rem;font-weight:600;letter-spacing:.5px;color:var(--primary-color);max-width:220px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
        .top-nav-right{display:flex;align-items:center;gap:1.2rem;margin-left:auto;}
        .notifications{position:relative;display:flex;align-items:center;} .notification-btn{background:none;border:none;cursor:pointer;position:relative;font-size:1.1rem;padding:.45rem;display:flex;align-items:center;justify-content:center;} .notification-badge{position:absolute;top:-5px;right:-5px;background:var(--accent-color);color:#fff;border-radius:50%;padding:.15rem .45rem;font-size:.6rem;}
        .notification-dropdown{display:none;position:absolute;right:0;top:100%;width:280px;background:#fff;border-radius:6px;box-shadow:0 4px 18px rgba(0,0,0,.12);z-index:1000;}
        .notification-dropdown.show{display:block;} .notification-list{max-height:280px;overflow-y:auto;}
        .profile-btn{background:none;border:none;cursor:pointer;padding:.25rem;display:flex;align-items:center;position:relative;} 
        .profile-btn img{width:40px;height:40px;border-radius:50%;object-fit:cover;}
        .avatar-initials{width:40px;height:40px;border-radius:50%;background:#3498db;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;font-size:14px;font-family:Arial,sans-serif;}
        .profile-dropdown{display:none;position:absolute;top:100%;right:0;background:#fff;border-radius:6px;box-shadow:0 4px 18px rgba(0,0,0,.12);min-width:200px;z-index:1000;} .profile-dropdown.show{display:block;} .profile-dropdown ul{list-style:none;margin:0;padding:0;} .profile-dropdown ul li a{display:flex;align-items:center;padding:12px 16px;color:#333;text-decoration:none;font-size:.78rem;gap:.6rem;transition:background .2s;} .profile-dropdown ul li a:hover{background:#f5f7fa;}

        /* Page Header */
        .page-header{background:linear-gradient(135deg,var(--primary-color),var(--secondary-color));color:#fff;padding:.55rem .75rem;border-radius:0;margin:.35rem 0 .5rem 0;display:flex;align-items:center;justify-content:space-between;box-shadow:0 10px 28px rgba(0,0,0,.18),0 6px 16px rgba(0,0,0,.14);font-size:.9rem;}
        .page-header i{font-size:1rem;}
        /* Add New Button */
        .btn-add-new{background:none;border:none;color:#fff;padding:.4rem;font-size:1.2rem;font-weight:600;cursor:pointer;transition:all 0.2s ease;display:flex;align-items:center;justify-content:center;text-decoration:none;}
        .btn-add-new:hover{color:rgba(255,255,255,0.8);transform:scale(1.1);}
        .btn-add-new i{font-size:1.2rem;}
        html, body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            width: 100%;
        }
        .board-container {
            max-width: 100%;
            margin: 0 auto;
            margin-top: 45px;
            padding: 20px;
            box-sizing: border-box;
        }

        .board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .board-title {
            font-size: 24px;
            color: #2c3e50;
        }

        .board-actions {
            display: flex;
            gap: 10px;
        }

        .filters-container {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .filter-group {
            flex: 1;
            min-width: 200px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #2c3e50;
        }

        .filter-chips {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .filter-chip.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }

        .map-container {
            position: relative;
            width: 100%;
            max-width: calc(100vw - 40px);
            margin: 0 auto 2rem auto;
            padding-left: 60px;
            box-sizing: border-box;
        }

        #map {
            width: 100%;
            height: 600px;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
        }

        .map-toolbar {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 50px;
            box-sizing: border-box;
        }

        .toolbar-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .toolbar-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 4px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .toolbar-btn:hover {
            background: #f5f6fa;
            color: #3498db;
        }

        .toolbar-btn.active {
            background: #3498db;
            color: white;
        }

        .toolbar-submenu {
            position: absolute;
            left: 100%;
            top: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 10px;
            display: none;
            min-width: 150px;
            z-index: 1001;
        }

        .toolbar-btn:hover .toolbar-submenu {
            display: block;
        }

        .submenu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            color: #2c3e50;
        }

        .submenu-item:hover {
            background: #f5f6fa;
            color: #3498db;
        }

        .drawing-controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 10px;
            display: none;
            z-index: 1000;
        }

        .drawing-controls.active {
            display: flex;
            gap: 10px;
        }

        .color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .measure-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: none;
            z-index: 1000;
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
        }

        .measure-point {
            width: 8px;
            height: 8px;
            background: #3498db;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .measure-label {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: -20px;
            white-space: nowrap;
        }

        .drawing-cursor {
            cursor: crosshair !important;
        }

        .measuring-cursor {
            cursor: cell !important;
        }

        .toolbar-btn.measuring::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background: #2ecc71;
            border-radius: 50%;
        }

        .measurement-segment {
            stroke-dasharray: 5, 5;
            animation: dash 20s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }

        .mouse-position {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            pointer-events: none;
        }

        .coordinate-grid {
            stroke: rgba(0, 0, 0, 0.1);
            stroke-width: 1;
            stroke-dasharray: 2, 2;
        }

        .drawing-tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
        }

        .toolbar-divider {
            width: 100%;
            height: 1px;
            background: #e9ecef;
            margin: 5px 0;
        }

        .toolbar-tooltip {
            position: absolute;
            left: 55px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .toolbar-btn:hover .toolbar-tooltip {
            opacity: 1;
        }

        .parameter-legend {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .parameter-legend h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .status-normal { background-color: #2ecc71; }
        .status-warning { background-color: #f1c40f; }
        .status-critical { background-color: #e74c3c; }
        .status-noise { background-color: #3498db; }
        .status-soil { background-color: #e67e22; }
        .status-water { background-color: #2980b9; }
        .status-heat { background-color: #c0392b; }
        .status-vibration { background-color: #8e44ad; }
        .status-light { background-color: #f39c12; }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .empty-state i {
            font-size: 3rem;
            color: #95a5a6;
            margin-bottom: 1rem;
        }

        .empty-state h3 {
            margin: 0;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .empty-state p {
            color: #7f8c8d;
            margin: 0;
        }

        @media (max-width: 768px) {
            .board-header {
                flex-direction: column;
                gap: 1rem;
            }

            .board-actions {
                width: 100%;
                justify-content: stretch;
            }

            .filters-container {
                flex-direction: column;
            }

            .filter-group {
                width: 100%;
            }

            #map {
                height: 400px;
            }

            .board-container {
                padding: 10px;
            }

            .map-container {
                padding-left: 0;
                margin-bottom: 1rem;
                max-width: 100%;
            }

            .map-toolbar {
                position: relative;
                transform: none;
                top: auto;
                left: auto;
                margin-bottom: 1rem;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
            }
        }

        .layer-control-panel {
            position: absolute;
            top: 0;
            right: -400px;  /* Increased width */
            width: 400px;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            box-shadow: -2px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            border-left: 1px solid rgba(0, 0, 0, 0.1);
        }

        .layer-control-panel.active {
            right: 0;
        }

        .layer-control-panel h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .layer-control-panel h3 i {
            font-size: 1.2rem;
            color: #3498db;
        }

        .layer-group {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .layer-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .layer-group-header span {
            font-size: 1.1em;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .layer-item {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .layer-item:hover {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .layer-main-controls {
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            align-items: center;
            gap: 12px;
        }

        .layer-visibility {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .layer-opacity {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            -webkit-appearance: none;
        }

        .layer-opacity::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .layer-parameters {
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            display: none;
        }

        .layer-parameters.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .parameter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 0.9em;
            color: #495057;
        }

        .parameter-toggle {
            display: flex;
            align-items: center;
            padding: 4px 0;
        }

        .parameter-toggle input[type="checkbox"] {
            margin-right: 8px;
        }

        .layer-toggle {
            padding: 6px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-toggle:hover {
            background: #e9ecef;
            color: #3498db;
        }

        .layer-toggle.active {
            transform: rotate(180deg);
            color: #3498db;
        }

        /* Add new style specifically for base map items */
        .layer-group:first-child .layer-item {
            padding: 4px 0;  /* even more compact for base maps */
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;  /* Push items to opposite ends */
            gap: 8px;
        }

        .basemap-input {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .basemap-input:hover {
            background: #e9ecef;
        }

        .basemap-input input[type="radio"] {
            width: 16px;
            height: 16px;
        }

        .basemap-input label {
            font-size: 0.95em;
            color: #495057;
            cursor: pointer;
        }

        .layer-main-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .layer-parameters {
            margin-left: 32px;
            font-size: 0.9em;
            color: #666;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .layer-parameters.active {
            max-height: 500px;
            margin-top: 8px;
        }

        .parameter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 4px 0;
        }

        .parameter-label {
            color: #34495e;
            flex: 1;
        }

        .parameter-value {
            padding: 2px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            font-family: monospace;
            min-width: 80px;
            text-align: right;
        }

        .layer-toggle {
            background: none;
            border: none;
            color: #3498db;
            cursor: pointer;
            padding: 4px;
            margin-left: auto;
            transition: transform 0.3s;
        }

        .layer-toggle.active {
            transform: rotate(180deg);
        }

        .close-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: #2c3e50;
            padding: 5px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .close-panel:hover {
            background: #f0f2f5;
            color: #e74c3c;
        }

        .parameter-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 2px 0;
            font-size: 0.85em;
        }

        .parameter-toggle input[type="checkbox"] {
            width: 14px;
            height: 14px;
        }

        .parameter-toggle label {
            cursor: pointer;
            flex: 1;
            color: #566573;
        }

        .parameter-toggle:hover label {
            color: #3498db;
        }

        .map-parameter-label {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            pointer-events: none;
            z-index: 650;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <nav class="sidebar menu-loading" id="sideNav">
            <div class="logo"><h2>Dreamex Datalab</h2></div>
            <ul class="menu" id="roleBasedMenu">
                <li class="menu-item" data-feature="home_view" data-requires-permission="home_view">
                    <a href="index.html"><i class="fas fa-home"></i> Home</a>
                </li>
                <li class="menu-dropdown" data-feature="health_view" data-requires-permission="health_view">
                    <a href="#"><i class="fas fa-medkit"></i> Health</a>
                    <ul class="submenu">
                        <li data-feature="health_assessment_view" data-requires-permission="health_assessment_view">
                            <a href="health-assessment.html">Assessment</a>
                        </li>
                        <li data-feature="health_consultation_view" data-requires-permission="health_consultation_view">
                            <a href="health-consultation.html">Consultation</a>
                        </li>
                        <li data-feature="medical_folder_view" data-requires-permission="medical_folder_view">
                            <a href="medical-folder.html">Medical Folder</a>
                        </li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="safety_view" data-requires-permission="safety_view">
                    <a href="#"><i class="fas fa-shield-alt"></i> Safety</a>
                    <ul class="submenu">
                        <li data-feature="training_view" data-requires-permission="training_view"><a href="trainingboard.html">Training</a></li>
                        <li data-feature="risk_view" data-requires-permission="risk_view"><a href="riskboard.html">Risk Management</a></li>
                        <li data-feature="jsa_view" data-requires-permission="jsa_view"><a href="jsaboard.html">Job Safety Analysis</a></li>
                        <li data-feature="ptw_view" data-requires-permission="ptw_view"><a href="ptwboard.html">Permit to Work</a></li>
                        <li data-feature="incident_view" data-requires-permission="incident_view"><a href="incidentboard.html">Incident Reports</a></li>
                        <li data-feature="inspection_view" data-requires-permission="inspection_view"><a href="inspectionboard.html">Inspection</a></li>
                        <li data-feature="audit_view" data-requires-permission="audit_view"><a href="auditboard.html">Audit</a></li>
                        <li data-feature="mapboard_view" data-requires-permission="mapboard_view"><a href="mapboard.html" class="active">Environmental Map</a></li>
                        <li data-feature="security_view" data-requires-permission="security_view"><a href="secur.html">Security Site Map</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="fuel_management" data-requires-permission="fuel_management">
                    <a href="#"><i class="fas fa-gas-pump"></i> Fuel Management</a>
                    <ul class="submenu">
                        <li data-feature="vessel_offloading" data-requires-permission="vessel_offloading"><a href="vessel-offloading.html">Vessel Offloading</a></li>
                        <li data-feature="fuel_storage" data-requires-permission="fuel_storage"><a href="fuel-storage-status.html">Fuel Storage Status</a></li>
                        <li data-feature="tank_transfer" data-requires-permission="tank_transfer"><a href="tank-transfer.html">Tank-to-Tank Transfer</a></li>
                        <li data-feature="truck_loading" data-requires-permission="truck_loading"><a href="fuel-truck-loading.html">Fuel Truck Loading</a></li>
                        <li data-feature="quality_analysis" data-requires-permission="quality_analysis"><a href="fuel-quality-analysis.html">Fuel Quality Analysis</a></li>
                        <li data-feature="fuel_distribution" data-requires-permission="fuel_distribution"><a href="fueldistrib.html">Fuel Distribution</a></li>
                        <li data-feature="fuel_consumption_analysis" data-requires-permission="fuel_consumption_analysis"><a href="fuelanalys.html">Consumption Analysis</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="environment_view" data-requires-permission="environment_view">
                    <a href="#"><i class="fas fa-leaf"></i> Environment</a>
                    <ul class="submenu">
                        <li data-feature="water_view" data-requires-permission="water_view"><a href="waterboard.html">Water Quality</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="security_view" data-requires-permission="security_view">
                    <a href="#"><i class="fas fa-lock"></i> Security</a>
                    <ul class="submenu">
                        <li data-feature="access_view" data-requires-permission="access_view"><a href="accessboard.html">Access Request</a></li>
                        <li data-feature="access_daily_view" data-requires-permission="access_daily_view"><a href="accessdaily.html">Daily Access Control</a></li>
                        <li data-feature="removal_view" data-requires-permission="removal_view"><a href="removalboard.html">Property Removal</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="logistics_view" data-requires-permission="logistics_view">
                    <a href="#"><i class="fas fa-truck"></i> Logistics</a>
                    <ul class="submenu">
                        <li data-feature="fleet_view" data-requires-permission="fleet_view"><a href="fleet.html">Fleet Management</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="accommodation_view" data-requires-permission="accommodation_view">
                    <a href="#"><i class="fas fa-bed"></i> Accommodation</a>
                    <ul class="submenu">
                        <li data-feature="camp_view" data-requires-permission="camp_view"><a href="camp.html">Camp Management</a></li>
                        <li data-feature="camp_settings_view" data-requires-permission="camp_settings_view"><a href="campset.html">Camp Settings</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="hr_view" data-requires-permission="hr_view">
                    <a href="#"><i class="fas fa-users"></i> HR</a>
                    <ul class="submenu">
                        <li data-feature="human_hr_view" data-requires-permission="human_hr_view"><a href="human-hr.html"><i class="fas fa-user-tie"></i> Human HR</a></li>
                        <li data-feature="staff_management_view" data-requires-permission="staff_management_view"><a href="staff.html">Staffing</a></li>
                        <li data-feature="authority_to_recruit_view" data-requires-permission="authority_to_recruit_view"><a href="recruit.html">Authority to Recruit</a></li>
                        <li data-feature="job_advertising_view" data-requires-permission="job_advertising_view"><a href="jobpost.html">Job Advertising</a></li>
                        <li data-feature="screening_view" data-requires-permission="screening_view"><a href="jobscreen.html">Screening</a></li>
                        <li data-feature="interview_view" data-requires-permission="interview_view"><a href="interview.html">Interview</a></li>
                        <li data-feature="offer_view" data-requires-permission="offer_view"><a href="offer.html">Offer Management</a></li>
                        <li data-feature="contract_view" data-requires-permission="contract_view"><a href="contract.html">Contract Management</a></li>
                        <li data-feature="onboarding_view" data-requires-permission="onboarding_view"><a href="onboard.html">Onboarding</a></li>
                        <li data-feature="chart_view" data-requires-permission="chart_view"><a href="chart.html">Chart Setup</a></li>
                        <li data-feature="chartboard_view" data-requires-permission="chartboard_view"><a href="chartboard.html">Org Chart</a></li>
                        <li data-feature="kpi_dashboard_view" data-requires-permission="kpi_dashboard_view"><a href="kpi.html">KPI</a></li>
                        <li data-feature="action_plan_view" data-requires-permission="action_plan_view"><a href="actionplan.html"><i class="fas fa-tasks"></i> Action Plan Board</a></li>
                    </ul>
                </li>
                <li class="menu-dropdown" data-feature="project_management_section">
                    <a href="#"><i class="fas fa-project-diagram"></i> Project Management</a>
                    <ul class="submenu">
                        <li data-feature="project_dashboard_view" data-requires-permission="project_dashboard_view"><a href="project-dashboard.html">Project Dashboard</a></li>
                        <li data-feature="project_create_view" data-requires-permission="project_create_view"><a href="project-create.html">Create Project</a></li>
                        <li data-feature="project_list_view" data-requires-permission="project_list_view"><a href="project-list.html">Project List</a></li>
                        <li data-feature="project_reports_view" data-requires-permission="project_reports_view"><a href="project-reports.html">Project Reports</a></li>
                    </ul>
                </li>
                <li data-feature="communication_view" data-requires-permission="communication_view"><a href="info.html"><i class="fas fa-comments"></i> Communication</a></li>
                <li class="menu-dropdown" data-feature="settings_view" data-requires-permission="settings_view">
                    <a href="#"><i class="fas fa-cog"></i> Settings</a>
                    <ul class="submenu">
                        <li data-feature="account_settings_view" data-requires-permission="account_settings_view"><a href="account.html">Account Settings</a></li>
                        <li data-feature="company_management_view" data-requires-permission="company_management_view"><a href="companymanagement.html">Company Management</a></li>
                        <li data-feature="approval_settings_view" data-requires-permission="approval_settings_view"><a href="approval-settings.html">Approval Flow Settings</a></li>
                        <li data-feature="field_setup_view" data-requires-permission="field_setup_view"><a href="fieldsetup.html">Field Setup</a></li>
                        <li data-feature="preferences_view" data-requires-permission="preferences_view"><a href="preferences.html">Preferences</a></li>
                        <li data-feature="notification_settings_view" data-requires-permission="notification_settings_view"><a href="notification-settings.html">Notification Settings</a></li>
                        <li data-feature="audit_log_view" data-requires-permission="audit_log_view"><a href="auditlog.html"><i class="fas fa-history"></i> Audit Log</a></li>
                        <li data-feature="user_management_view" data-requires-permission="user_management_view"><a href="users.html">User & Role Management</a></li>
                        <li data-feature="role_permissions_view" data-requires-permission="role_permissions_view"><a href="roles.html">Role Permissions</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
        
        <!-- Main Content -->
        <main class="main-content">
            <header class="top-nav">
                <div class="top-nav-left">
                    <button id="sidebarToggle" class="sidebar-toggle-btn" title="Toggle menu"><i class="fas fa-bars"></i></button>
                    <img id="headerCompanyLogo" alt="Company Logo">
                    <span id="headerCompanyName"></span>
                </div>
                <div class="top-nav-right">
                    <div class="notifications">
                        <button id="notificationBtn" class="notification-btn" aria-label="Notifications"><i class="fas fa-bell"></i><span class="notification-badge" style="display:none;">0</span></button>
                        <div class="notification-dropdown">
                            <div style="padding:.75rem;border-bottom:1px solid #eee;display:flex;justify-content:space-between;align-items:center;">
                                <strong style="font-size:.7rem;color:#2c3e50;">Notifications</strong>
                                <button class="mark-all-read" style="background:none;border:none;font-size:.6rem;color:var(--secondary-color);cursor:pointer;">Mark all read</button>
                            </div>
                            <div class="notification-list"></div>
                        </div>
                    </div>
                    <div class="user-profile">
                        <button id="userProfileBtn" class="profile-btn" aria-label="Profile">
                            <img id="userAvatarImg" src="" alt="User Avatar" style="display: none;">
                            <div id="userInitials" class="avatar-initials">U</div>
                        </button>
                        <div class="profile-dropdown"><ul></ul></div>
                    </div>
                </div>
            </header>
            <div style="padding-top:3.4rem;"></div>
            <div class="page-header">
                <div style="display: flex; align-items: center; gap: 0.6rem;">
                    <i class="fas fa-map-marked-alt"></i>
                    <span>Environmental Monitoring Map</span>
                </div>
                <button type="button" class="btn-add-new" onclick="toggleFilterControls()" title="Toggle Filter Controls">
                    <i class="fas fa-filter"></i>
                </button>
            </div>

            <!-- Map Board Content -->
            <main class="board-container">
                <div class="filters-container" id="filterControls">
                    <div class="filter-group">
                        <label for="date-filter">Date Range</label>
                        <select id="date-filter" class="form-control">
                            <option value="all">All Time</option>
                            <option value="today">Today</option>
                            <option value="week">This Week</option>
                            <option value="month">This Month</option>
                            <option value="quarter">Last 3 Months</option>
                            <option value="year">This Year</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="status-filter">Status</label>
                        <select id="status-filter" class="form-control">
                            <option value="all">All Status</option>
                            <option value="normal">Normal</option>
                            <option value="warning">Warning</option>
                            <option value="critical">Critical</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="location-filter">Location</label>
                        <select id="location-filter" class="form-control">
                            <option value="all">All Locations</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Parameter Types</label>
                        <div class="filter-chips">
                            <button class="filter-chip active" data-type="all">All Parameters</button>
                            <button class="filter-chip" data-type="noise">Noise</button>
                            <button class="filter-chip" data-type="soil">Soil</button>
                            <button class="filter-chip" data-type="water">Water</button>
                            <button class="filter-chip" data-type="heat">Heat</button>
                            <button class="filter-chip" data-type="vibration">Vibration</button>
                            <button class="filter-chip" data-type="light">Light</button>
                        </div>
                    </div>
                </div>

                <div class="map-container">
                    <div id="map"></div>
                    <div class="map-toolbar">
                <!-- Navigation Section -->
                <div class="toolbar-section">
                    <button class="toolbar-btn" id="zoom-in-btn">
                        <i class="fas fa-plus"></i>
                        <div class="toolbar-tooltip">Zoom In</div>
                    </button>
                    <button class="toolbar-btn" id="zoom-out-btn">
                        <i class="fas fa-minus"></i>
                        <div class="toolbar-tooltip">Zoom Out</div>
                    </button>
                    <button class="toolbar-btn" id="reset-view-btn">
                        <i class="fas fa-home"></i>
                        <div class="toolbar-tooltip">Reset View</div>
                    </button>
                </div>
                
                <div class="toolbar-divider"></div>
                
                <!-- Drawing Section -->
                <div class="toolbar-section">
                    <button class="toolbar-btn" id="draw-marker-btn">
                        <i class="fas fa-map-marker-alt"></i>
                        <div class="toolbar-tooltip">Add Marker</div>
                    </button>
                    <button class="toolbar-btn" id="draw-polygon-btn">
                        <i class="fas fa-draw-polygon"></i>
                        <div class="toolbar-tooltip">Draw Area</div>
                        <div class="toolbar-submenu">
                            <div class="submenu-item" data-shape="polygon">
                                <i class="fas fa-draw-polygon"></i>
                                <span>Polygon</span>
                            </div>
                            <div class="submenu-item" data-shape="rectangle">
                                <i class="fas fa-square"></i>
                                <span>Rectangle</span>
                            </div>
                            <div class="submenu-item" data-shape="circle">
                                <i class="fas fa-circle"></i>
                                <span>Circle</span>
                            </div>
                        </div>
                    </button>
                    <button class="toolbar-btn" id="draw-line-btn">
                        <i class="fas fa-slash"></i>
                        <div class="toolbar-tooltip">Draw Line</div>
                    </button>
                </div>
                
                <div class="toolbar-divider"></div>
                
                <!-- Measurement Section -->
                <div class="toolbar-section">
                    <button class="toolbar-btn" id="measure-distance-btn">
                        <i class="fas fa-ruler"></i>
                        <div class="toolbar-tooltip">Measure Distance</div>
                    </button>
                    <button class="toolbar-btn" id="measure-area-btn">
                        <i class="fas fa-vector-square"></i>
                        <div class="toolbar-tooltip">Measure Area</div>
                    </button>
                </div>
                
                <div class="toolbar-divider"></div>
                
                <!-- Tools Section -->
                <div class="toolbar-section">
                    <button class="toolbar-btn" id="save-map-btn">
                        <i class="fas fa-download"></i>
                        <div class="toolbar-tooltip">Save as Image</div>
                    </button>
                    <button class="toolbar-btn" id="save-state-btn">
                        <i class="fas fa-save"></i>
                        <div class="toolbar-tooltip">Save Map State</div>
                    </button>
                    <button class="toolbar-btn" id="load-state-btn">
                        <i class="fas fa-folder-open"></i>
                        <div class="toolbar-tooltip">Load Map State</div>
                    </button>
                    <button class="toolbar-btn" id="screenshot-btn">
                        <i class="fas fa-camera"></i>
                        <div class="toolbar-tooltip">Take Screenshot</div>
                    </button>
                    <button class="toolbar-btn" id="layers-btn">
                        <i class="fas fa-layer-group"></i>
                        <div class="toolbar-tooltip">Layer Control</div>
                    </button>
                    <button class="toolbar-btn" id="erase-btn">
                        <i class="fas fa-eraser"></i>
                        <div class="toolbar-tooltip">Erase Drawings</div>
                    </button>
                </div>
            </div>
            
            <!-- Drawing Controls -->
            <div class="drawing-controls" id="drawing-controls">
                <input type="color" class="color-picker" id="stroke-color" value="#3498db" title="Stroke Color">
                <input type="color" class="color-picker" id="fill-color" value="#3498db80" title="Fill Color">
                <button class="toolbar-btn" id="undo-btn">
                    <i class="fas fa-undo"></i>
                </button>
                <button class="toolbar-btn" id="save-drawing-btn">
                    <i class="fas fa-save"></i>
                </button>
            </div>
            
            <!-- Measurement Info -->
            <div class="measure-info" id="measure-info"></div>
        </div>

        <div class="layer-control-panel" id="layer-control-panel">
            <button class="close-panel" id="close-layer-panel">
                <i class="fas fa-times"></i>
            </button>
            <h3><i class="fas fa-layer-group"></i> Layer Control</h3>
            
            <div class="layer-group">
                <div class="layer-group-header">
                    <span><i class="fas fa-map"></i>Base Maps</span>
                </div>
                <div class="layer-item">
                    <label for="streets-layer">Streets</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="streets" checked id="streets-layer">
                    </div>
                </div>
                <div class="layer-item">
                    <label for="satellite-layer">Satellite</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="satellite" id="satellite-layer">
                    </div>
                </div>
                <div class="layer-item">
                    <label for="terrain-layer">Terrain</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="terrain" id="terrain-layer">
                    </div>
                </div>
                <div class="layer-item">
                    <label for="dark-layer">Dark Mode</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="dark" id="dark-layer">
                    </div>
                </div>
                <div class="layer-item">
                    <label for="light-layer">Light Mode</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="light" id="light-layer">
                    </div>
                </div>
                <div class="layer-item">
                    <label for="outdoors-layer">Outdoors</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="outdoors" id="outdoors-layer">
                    </div>
                </div>
                <div class="layer-item">
                    <label for="transport-layer">Transport</label>
                    <div class="basemap-input">
                        <input type="radio" name="basemap" value="transport" id="transport-layer">
                    </div>
                </div>
            </div>

            <div class="layer-group">
                <div class="layer-group-header">
                    <span><i class="fas fa-chart-line"></i>Environmental Data</span>
                </div>
                <div class="layer-item">
                    <div class="layer-main-controls">
                        <input type="checkbox" class="layer-visibility" checked id="noise-layer">
                        <label for="noise-layer">Noise Monitoring</label>
                        <input type="range" class="layer-opacity" min="0" max="100" value="100" data-layer="noise" title="Layer Opacity">
                        <button class="layer-toggle" onclick="toggleParameters('noise')"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="layer-parameters" id="noise-parameters">
                        <div class="parameter-row">
                            <span class="parameter-label">Decibel Range (dB)</span>
                            <span class="parameter-value">30-120</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Frequency Range (Hz)</span>
                            <span class="parameter-value">20-20000</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Time Weighted Average</span>
                            <span class="parameter-value">8h</span>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="noise-db-display" data-param="noise-db">
                            <label for="noise-db-display">Show dB values on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="noise-frequency-display" data-param="noise-frequency">
                            <label for="noise-frequency-display">Show frequency values on map</label>
                        </div>
                    </div>
                </div>
                <div class="layer-item">
                    <div class="layer-main-controls">
                        <input type="checkbox" class="layer-visibility" checked id="soil-layer">
                        <label for="soil-layer">Soil Quality</label>
                        <input type="range" class="layer-opacity" min="0" max="100" value="100" data-layer="soil" title="Layer Opacity">
                        <button class="layer-toggle" onclick="toggleParameters('soil')"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="layer-parameters" id="soil-parameters">
                        <div class="parameter-row">
                            <span class="parameter-label">pH Level</span>
                            <span class="parameter-value">0-14</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Organic Matter (%)</span>
                            <span class="parameter-value">0-10</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Moisture Content (%)</span>
                            <span class="parameter-value">0-100</span>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="soil-ph-display" data-param="soil-ph">
                            <label for="soil-ph-display">Show pH values on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="soil-organic-display" data-param="soil-organic">
                            <label for="soil-organic-display">Show organic matter on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="soil-moisture-display" data-param="soil-moisture">
                            <label for="soil-moisture-display">Show moisture content on map</label>
                        </div>
                    </div>
                </div>
                <div class="layer-item">
                    <div class="layer-main-controls">
                        <input type="checkbox" class="layer-visibility" checked id="water-layer">
                        <label for="water-layer">Water Quality</label>
                        <input type="range" class="layer-opacity" min="0" max="100" value="100" data-layer="water" title="Layer Opacity">
                        <button class="layer-toggle" onclick="toggleParameters('water')"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="layer-parameters" id="water-parameters">
                        <div class="parameter-row">
                            <span class="parameter-label">pH Level</span>
                            <span class="parameter-value">6.5-8.5</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Turbidity (NTU)</span>
                            <span class="parameter-value">0-10</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Dissolved Oxygen (mg/L)</span>
                            <span class="parameter-value">4-12</span>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="water-ph-display" data-param="water-ph">
                            <label for="water-ph-display">Show pH values on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="water-turbidity-display" data-param="water-turbidity">
                            <label for="water-turbidity-display">Show turbidity on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="water-oxygen-display" data-param="water-oxygen">
                            <label for="water-oxygen-display">Show dissolved oxygen on map</label>
                        </div>
                    </div>
                </div>
                <div class="layer-item">
                    <div class="layer-main-controls">
                        <input type="checkbox" class="layer-visibility" checked id="heat-layer">
                        <label for="heat-layer">Heat Map</label>
                        <input type="range" class="layer-opacity" min="0" max="100" value="100" data-layer="heat" title="Layer Opacity">
                        <button class="layer-toggle" onclick="toggleParameters('heat')"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="layer-parameters" id="heat-parameters">
                        <div class="parameter-row">
                            <span class="parameter-label">Temperature Range (°C)</span>
                            <span class="parameter-value">-20-50</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Humidity (%)</span>
                            <span class="parameter-value">0-100</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Heat Index</span>
                            <span class="parameter-value">Low-Extreme</span>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="heat-temp-display" data-param="heat-temp">
                            <label for="heat-temp-display">Show temperature on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="heat-humidity-display" data-param="heat-humidity">
                            <label for="heat-humidity-display">Show humidity on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="heat-index-display" data-param="heat-index">
                            <label for="heat-index-display">Show heat index on map</label>
                        </div>
                    </div>
                </div>
                <div class="layer-item">
                    <div class="layer-main-controls">
                        <input type="checkbox" class="layer-visibility" checked id="vibration-layer">
                        <label for="vibration-layer">Vibration Data</label>
                        <input type="range" class="layer-opacity" min="0" max="100" value="100" data-layer="vibration" title="Layer Opacity">
                        <button class="layer-toggle" onclick="toggleParameters('vibration')"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="layer-parameters" id="vibration-parameters">
                        <div class="parameter-row">
                            <span class="parameter-label">Frequency (Hz)</span>
                            <span class="parameter-value">1-1000</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Amplitude (mm/s)</span>
                            <span class="parameter-value">0-100</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Peak Velocity (mm/s)</span>
                            <span class="parameter-value">0-50</span>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="vibration-freq-display" data-param="vibration-freq">
                            <label for="vibration-freq-display">Show frequency on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="vibration-amplitude-display" data-param="vibration-amplitude">
                            <label for="vibration-amplitude-display">Show amplitude on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="vibration-peak-display" data-param="vibration-peak">
                            <label for="vibration-peak-display">Show peak velocity on map</label>
                        </div>
                    </div>
                </div>
                <div class="layer-item">
                    <div class="layer-main-controls">
                        <input type="checkbox" class="layer-visibility" checked id="light-layer">
                        <label for="light-layer">Light Intensity</label>
                        <input type="range" class="layer-opacity" min="0" max="100" value="100" data-layer="light" title="Layer Opacity">
                        <button class="layer-toggle" onclick="toggleParameters('light')"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="layer-parameters" id="light-parameters">
                        <div class="parameter-row">
                            <span class="parameter-label">Illuminance (lux)</span>
                            <span class="parameter-value">0-100000</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">Color Temperature (K)</span>
                            <span class="parameter-value">2000-6500</span>
                        </div>
                        <div class="parameter-row">
                            <span class="parameter-label">UV Index</span>
                            <span class="parameter-value">0-11+</span>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="light-illuminance-display" data-param="light-illuminance">
                            <label for="light-illuminance-display">Show illuminance on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="light-temperature-display" data-param="light-temperature">
                            <label for="light-temperature-display">Show color temperature on map</label>
                        </div>
                        <div class="parameter-toggle">
                            <input type="checkbox" id="light-uv-display" data-param="light-uv">
                            <label for="light-uv-display">Show UV index on map</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="parameter-legend">
            <h3>Legend</h3>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color status-noise"></div>
                    <span>Noise</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-soil"></div>
                    <span>Soil</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-water"></div>
                    <span>Water</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-heat"></div>
                    <span>Heat</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-vibration"></div>
                    <span>Vibration</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color status-light"></div>
                    <span>Light</span>
                </div>
            </div>
        </div>

        <div id="loading-overlay" class="loading-overlay" style="display: none;">
            <div class="loading-spinner"></div>
        </div>

        <div id="empty-state" class="empty-state" style="display: none;">
            <i class="fas fa-map-marked-alt"></i>
            <h3>No Data Available</h3>
            <p>No environmental monitoring data matches your current filters.</p>
        </div>
    </main>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet.draw plugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <!-- html2canvas for screenshots -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- Leaflet.measure for distance and area measurements -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.min.js"></script>
    <!-- Firebase scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="js/firebase-config.js"></script>
    <script src="js/header-loader.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Firebase
            const database = firebase.database();
            
            // Initialize map with disabled controls
            const map = L.map('map', {
                zoomControl: false,  // Disable default zoom control
                attributionControl: false  // Disable attribution control
            }).setView([0, 0], 2);
            
            // Add attribution in a custom position
            L.control.attribution({
                position: 'bottomright',
                prefix: false
            }).addTo(map);
            
            // Define base maps
            const baseMaps = {
                streets: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }),
                satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '© Esri',
                    maxZoom: 19
                }),
                terrain: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenTopoMap contributors',
                    maxZoom: 17
                }),
                dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    attribution: '© CARTO',
                    maxZoom: 19
                }),
                light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                    attribution: '© CARTO',
                    maxZoom: 19
                }),
                outdoors: L.tileLayer('https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=YOUR_API_KEY', {
                    attribution: '© Thunderforest',
                    maxZoom: 19
                }),
                transport: L.tileLayer('https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey=YOUR_API_KEY', {
                    attribution: '© Thunderforest',
                    maxZoom: 19
                })
            };

            // Add default base map
            let currentBaseMap = baseMaps.streets;
            currentBaseMap.addTo(map);

            // Update base map radio handlers
            document.querySelectorAll('input[name="basemap"]').forEach(input => {
                input.addEventListener('change', function() {
                    if (currentBaseMap) {
                        map.removeLayer(currentBaseMap);
                    }
                    currentBaseMap = baseMaps[this.value];
                    currentBaseMap.addTo(map);
                });
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            // Elements
            const loadingOverlay = document.getElementById('loading-overlay');
            const emptyState = document.getElementById('empty-state');
            const filterChips = document.querySelectorAll('.filter-chip');
            const dateFilter = document.getElementById('date-filter');
            const statusFilter = document.getElementById('status-filter');
            const locationFilter = document.getElementById('location-filter');
            const refreshBtn = document.getElementById('refresh-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const resetViewBtn = document.getElementById('reset-view-btn');

            // Store initial view settings
            let defaultView = {
                center: [0, 0],
                zoom: 2
            };

            // Toolbar button functionality
            zoomInBtn.addEventListener('click', () => {
                map.zoomIn();
            });

            zoomOutBtn.addEventListener('click', () => {
                map.zoomOut();
            });

            resetViewBtn.addEventListener('click', () => {
                // If we have markers, fit to their bounds
                const allBounds = [];
                Object.values(markerLayers).forEach(layer => {
                    layer.eachLayer(marker => {
                        allBounds.push(marker.getLatLng());
                    });
                });

                if (allBounds.length > 0) {
                    map.fitBounds(L.latLngBounds(allBounds));
                } else {
                    // Otherwise return to default view
                    map.setView(defaultView.center, defaultView.zoom);
                }
            });

            // Update default view when bounds are set
            map.on('moveend', () => {
                if (map.getBounds().isValid()) {
                    defaultView = {
                        center: map.getCenter(),
                        zoom: map.getZoom()
                    };
                }
            });

            // Marker layers for different parameters
            const markerLayers = {
                noise: L.layerGroup(),
                soil: L.layerGroup(),
                water: L.layerGroup(),
                heat: L.layerGroup(),
                vibration: L.layerGroup(),
                light: L.layerGroup()
            };

            // Add layers to map
            Object.values(markerLayers).forEach(layer => layer.addTo(map));

            // Load data
            function loadData() {
                loadingOverlay.style.display = 'flex';
                emptyState.style.display = 'none';

                // Clear existing markers
                Object.values(markerLayers).forEach(layer => layer.clearLayers());

                // Load data from different sources
                Promise.all([
                    database.ref('noise-quality-reports').once('value'),
                    database.ref('soil-quality-reports').once('value'),
                    database.ref('water-quality-reports').once('value')
                    // Add more data sources here
                ]).then(([noiseData, soilData, waterData]) => {
                    const bounds = [];

                    // Process noise data
                    if (noiseData.exists()) {
                        noiseData.forEach(report => {
                            const data = report.val();
                            if (data.latitude && data.longitude) {
                                const marker = createMarker(data, 'noise');
                                markerLayers.noise.addLayer(marker);
                                bounds.push([data.latitude, data.longitude]);
                            }
                        });
                    }

                    // Process soil data
                    if (soilData.exists()) {
                        soilData.forEach(report => {
                            const data = report.val();
                            if (data.latitude && data.longitude) {
                                const marker = createMarker(data, 'soil');
                                markerLayers.soil.addLayer(marker);
                                bounds.push([data.latitude, data.longitude]);
                            }
                        });
                    }

                    // Process water data
                    if (waterData.exists()) {
                        waterData.forEach(report => {
                            const data = report.val();
                            if (data.latitude && data.longitude) {
                                const marker = createMarker(data, 'water');
                                markerLayers.water.addLayer(marker);
                                bounds.push([data.latitude, data.longitude]);
                            }
                        });
                    }

                    // Fit map to bounds if markers exist
                    if (bounds.length > 0) {
                        map.fitBounds(bounds);
                        emptyState.style.display = 'none';
                    } else {
                        emptyState.style.display = 'block';
                    }

                    loadingOverlay.style.display = 'none';
                }).catch(error => {
                    console.error('Error loading data:', error);
                    loadingOverlay.style.display = 'none';
                    emptyState.style.display = 'block';
                });
            }

            // Create marker with popup
            function createMarker(data, type) {
                const icon = L.divIcon({
                    className: `marker-icon status-${type}`,
                    html: `<i class="fas fa-${getIcon(type)}"></i>`,
                    iconSize: [30, 30]
                });

                const marker = L.marker([data.latitude, data.longitude], { icon });
                
                const popupContent = `
                    <div class="marker-popup">
                        <h3>${getTitle(type)}</h3>
                        <p><strong>Location:</strong> ${data.location}</p>
                        <p><strong>Status:</strong> ${data.status || 'Normal'}</p>
                        <p><strong>Date:</strong> ${new Date(data.samplingDate).toLocaleDateString()}</p>
                        ${getParameterDisplay(data, type)}
                        <button onclick="window.location.href='${type}.html?id=${data.id}'" class="btn btn-primary btn-sm">
                            View Details
                        </button>
                    </div>
                `;

                marker.bindPopup(popupContent);
                return marker;
            }

            // Get icon for marker based on type
            function getIcon(type) {
                const icons = {
                    noise: 'volume-up',
                    soil: 'layer-group',
                    water: 'water',
                    heat: 'temperature-high',
                    vibration: 'wave-square',
                    light: 'lightbulb'
                };
                return icons[type] || 'map-marker-alt';
            }

            // Get title for popup based on type
            function getTitle(type) {
                return type.charAt(0).toUpperCase() + type.slice(1) + ' Quality Report';
            }

            // Get parameter display for popup
            function getParameterDisplay(data, type) {
                if (!data.parameters) return '';
                
                const params = Object.entries(data.parameters)
                    .slice(0, 3)
                    .map(([key, value]) => `<li>${key}: ${value}</li>`)
                    .join('');
                
                return `<p><strong>Key Parameters:</strong></p><ul>${params}</ul>`;
            }

            // Filter functionality
            filterChips.forEach(chip => {
                chip.addEventListener('click', () => {
                    filterChips.forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    
                    const type = chip.dataset.type;
                    Object.entries(markerLayers).forEach(([layerType, layer]) => {
                        if (type === 'all' || type === layerType) {
                            layer.addTo(map);
                        } else {
                            layer.removeFrom(map);
                        }
                    });
                });
            });

            // Refresh button
            refreshBtn.addEventListener('click', loadData);

            // Check authentication and load initial data
            firebase.auth().onAuthStateChanged(user => {
                if (user) {
                    loadData();
                } else {
                    window.location.href = 'login.html';
                }
            });

            // Initialize Leaflet.draw plugin with no controls
            const drawControl = new L.Control.Draw({
                position: 'topright',
                draw: false,
                edit: false
            });

            // Drawing layers
            window.drawnItems = new L.FeatureGroup().addTo(map);
            map.addControl(drawControl);

            // Drawing state
            let isDrawing = false;
            let currentDrawingTool = null;
            const drawingHistory = [];
            
            // Drawing tool handlers
            document.getElementById('draw-marker-btn').addEventListener('click', function() {
                toggleDrawingTool('marker', this);
            });

            document.getElementById('draw-line-btn').addEventListener('click', function() {
                toggleDrawingTool('polyline', this);
            });

            // Polygon submenu handlers
            document.querySelectorAll('#draw-polygon-btn .submenu-item').forEach(item => {
                item.addEventListener('click', function() {
                    const shape = this.dataset.shape;
                    toggleDrawingTool(shape, document.getElementById('draw-polygon-btn'));
                });
            });

            function toggleDrawingTool(tool, button) {
                // Deactivate current tool if any
                if (currentDrawingTool) {
                    document.querySelector('.toolbar-btn.active')?.classList.remove('active');
                    map.off('click');
                }

                // Toggle tool
                if (currentDrawingTool === tool) {
                    currentDrawingTool = null;
                    isDrawing = false;
                    document.getElementById('drawing-controls').classList.remove('active');
                } else {
                    currentDrawingTool = tool;
                    isDrawing = true;
                    button.classList.add('active');
                    document.getElementById('drawing-controls').classList.add('active');
                    activateDrawingTool(tool);
                }
            }

            function activateDrawingTool(tool) {
                switch(tool) {
                    case 'marker':
                        map.on('click', (e) => {
                            if (!isDrawing) return;
                            const marker = L.marker(e.latlng).addTo(drawnItems);
                            drawingHistory.push({
                                type: 'marker',
                                layer: marker
                            });
                        });
                        break;
                    case 'polygon':
                    case 'rectangle':
                    case 'circle':
                        new L.Draw[tool.charAt(0).toUpperCase() + tool.slice(1)]({
                            shapeOptions: {
                                color: document.getElementById('stroke-color').value,
                                fillColor: document.getElementById('fill-color').value
                            }
                        }).enable();
                        break;
                }
            }

            // Handle created shapes
            map.on(L.Draw.Event.CREATED, (e) => {
                const layer = e.layer;
                drawnItems.addLayer(layer);
                drawingHistory.push({
                    type: e.layerType,
                    layer: layer
                });
            });

            // Measurement tools
            const measureControl = {
                distance: null,
                area: null
            };

            function startMeasurement(type) {
                // Clear any existing measurements
                if (measureControl.distance) {
                    drawnItems.removeLayer(measureControl.distance);
                }
                if (measureControl.area) {
                    drawnItems.removeLayer(measureControl.area);
                }

                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';
                
                const measureInfo = document.getElementById('measure-info');
                measureInfo.style.display = 'block';
                measureInfo.classList.add('active');

                if (type === 'distance') {
                    let points = [];
                    let polyline = null;
                    let totalDistance = 0;
                    let tempLine = null;

                    function createDistanceLabel(point1, point2, labelPoint, distance) {
                        const segmentLabel = L.divIcon({
                            className: 'measure-label',
                            html: `
                                <div class="distance-label" style="cursor: pointer;">
                                    ${distance >= 1000 ? 
                                        `${(distance / 1000).toFixed(2)} km` : 
                                        `${distance.toFixed(0)} m`}
                                </div>`,
                        });
                        
                        const marker = L.marker(labelPoint, { 
                            icon: segmentLabel,
                            draggable: true
                        }).addTo(drawnItems);

                        // Add click handler for editing
                        marker.on('click', function() {
                            const newDistance = prompt('Enter new distance (in meters):', Math.round(distance));
                            if (newDistance && !isNaN(newDistance)) {
                                // Calculate scaling factor
                                const scaleFactor = newDistance / distance;
                                // Update the point positions
                                const p1 = L.latLng(point1);
                                const p2 = L.latLng(point2);
                                const bearing = p1.bearingTo(p2);
                                const newP2 = p1.destinationPoint(bearing, newDistance);
                                
                                // Update polyline
                                const lineIndex = points.indexOf(point2);
                                if (lineIndex > 0) {
                                    points[lineIndex] = newP2;
                                    polyline.setLatLngs(points);
                                    // Update the label
                                    marker.setLatLng([
                                        (p1.lat + newP2.lat) / 2,
                                        (p1.lng + newP2.lng) / 2
                                    ]);
                                    // Update marker icon with new distance
                                    marker.setIcon(L.divIcon({
                                        className: 'measure-label',
                                        html: `
                                            <div class="distance-label" style="cursor: pointer;">
                                                ${newDistance >= 1000 ? 
                                                    `${(newDistance / 1000).toFixed(2)} km` : 
                                                    `${newDistance.toFixed(0)} m`}
                                            </div>`
                                    }));
                                    
                                    // Update total distance
                                    updateTotalDistance();
                                }
                            }
                        });

                        // Add context menu for deletion
                        marker.on('contextmenu', function(e) {
                            const segmentIndex = points.indexOf(point2);
                            if (segmentIndex > 0) {
                                if (confirm('Delete this segment?')) {
                                    points.splice(segmentIndex, 1);
                                    polyline.setLatLngs(points);
                                    drawnItems.removeLayer(marker);
                                    updateTotalDistance();
                                }
                            }
                            L.DomEvent.preventDefault(e);
                        });

                        return marker;
                    }

                    function updateTotalDistance() {
                        totalDistance = 0;
                        for (let i = 1; i < points.length; i++) {
                            totalDistance += L.latLng(points[i-1]).distanceTo(points[i]);
                        }
                        
                        const displayDistance = totalDistance >= 1000 ? 
                            `${(totalDistance / 1000).toFixed(2)} km` : 
                            `${totalDistance.toFixed(0)} m`;
                        measureInfo.textContent = `Total Distance: ${displayDistance}`;
                    }

                    function onMapClick(e) {
                        points.push(e.latlng);
                        
                        if (points.length === 1) {
                            // Start new measurement
                            polyline = L.polyline([points[0]], {
                                color: '#3498db',
                                weight: 3,
                                opacity: 0.8
                            }).addTo(drawnItems);
                            
                            // Add measurement point marker
                            L.circleMarker(points[0], {
                                radius: 4,
                                color: '#3498db',
                                fillColor: '#ffffff',
                                fillOpacity: 1,
                                weight: 2
                            }).addTo(drawnItems);
                            
                            // Initialize temporary line for live preview
                            tempLine = L.polyline([points[0], points[0]], {
                                color: '#3498db',
                                weight: 2,
                                opacity: 0.5,
                                dashArray: '5,5'
                            }).addTo(map);
                            
                            measureInfo.textContent = 'Click to add points, double-click to finish';
                        } else {
                            // Update existing polyline
                            polyline.setLatLngs(points);
                            
                            // Add measurement point marker
                            L.circleMarker(points[points.length - 1], {
                                radius: 4,
                                color: '#3498db',
                                fillColor: '#ffffff',
                                fillOpacity: 1,
                                weight: 2
                            }).addTo(drawnItems);
                            
                            // Calculate distance and add label
                            const lastPoint = points[points.length - 2];
                            const currentPoint = points[points.length - 1];
                            const lastSegment = L.latLng(lastPoint).distanceTo(currentPoint);
                            
                            // Add distance label with edit functionality
                            const midPoint = L.latLng(
                                (lastPoint.lat + currentPoint.lat) / 2,
                                (lastPoint.lng + currentPoint.lng) / 2
                            );
                            
                            createDistanceLabel(lastPoint, currentPoint, midPoint, lastSegment);
                            
                            totalDistance += lastSegment;
                            updateTotalDistance();
                        }
                    }
                    
                    function onMouseMove(e) {
                        if (points.length > 0 && tempLine) {
                            tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                            
                            // Show live measurement
                            const hoverDistance = L.latLng(points[points.length - 1]).distanceTo(e.latlng);
                            const displayHoverDistance = hoverDistance >= 1000 ? 
                                `${(hoverDistance / 1000).toFixed(2)} km` : 
                                `${hoverDistance.toFixed(0)} m`;
                            
                            const liveTotalDistance = totalDistance + hoverDistance;
                            const displayLiveTotal = liveTotalDistance >= 1000 ? 
                                `${(liveTotalDistance / 1000).toFixed(2)} km` : 
                                `${liveTotalDistance.toFixed(0)} m`;
                                
                            measureInfo.textContent = `Current segment: ${displayHoverDistance} | Total: ${displayLiveTotal}`;
                        }
                    }
                    
                    function onDoubleClick(e) {
                        if (points.length > 1) {
                            if (tempLine) {
                                map.removeLayer(tempLine);
                            }
                            map.off('mousemove', onMouseMove);
                            map.off('click', onMapClick);
                            map.off('dblclick', onDoubleClick);
                            
                            // Add final measurement label
                            const finalLabel = L.divIcon({
                                className: 'measure-label measure-total',
                                html: `<strong>Total: ${totalDistance >= 1000 ? 
                                    (totalDistance / 1000).toFixed(2) + ' km' : 
                                    totalDistance.toFixed(0) + ' m'}</strong>`
                            });
                            
                            L.marker(points[points.length - 1], { 
                                icon: finalLabel,
                                zIndexOffset: 1000
                            }).addTo(drawnItems);
                            
                            document.getElementById('measure-distance-btn').classList.remove('active');
                            setTimeout(() => {
                                measureInfo.style.display = 'none';
                                map.getContainer().style.cursor = '';
                            }, 2000);
                        }
                    }

                    function onKeyDown(e) {
                        if (e.key === 'Escape') {
                            stopMeasurement();
                        }
                    }

                    function stopMeasurement() {
                        if (tempLine) {
                            map.removeLayer(tempLine);
                        }
                        map.off('click', onMapClick);
                        map.off('mousemove', onMouseMove);
                        map.off('dblclick', onDoubleClick);
                        document.removeEventListener('keydown', onKeyDown);
                        document.getElementById('measure-distance-btn').classList.remove('active');
                        map.getContainer().style.cursor = '';
                        setTimeout(() => {
                            measureInfo.style.display = 'none';
                        }, 2000);
                        removeStopButton();
                    }

                    // Start measurement mode
                    map.on('click', onMapClick);
                    map.on('mousemove', onMouseMove);
                    map.on('dblclick', onDoubleClick);
                    document.addEventListener('keydown', onKeyDown);
                    measureControl.distance = polyline;
                    ensureStopButton(stopMeasurement);
                }
                // ... existing code ...
                ensureStopButton(stopMeasurement);
                // ... existing code ...
                function stopMeasurement() {
                    // ... existing code ...
                    removeStopButton();
                    // ... existing code ...
                }
                // ... existing code ...
            }

            function startAreaMeasurement() {
                const measureInfo = document.getElementById('measure-info');
                measureInfo.style.display = 'block';
                let polygon = null;
                let points = [];
                let tempLine = null;
                
                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';

                function onMapClick(e) {
                    points.push(e.latlng);
                    
                    if (points.length === 1) {
                        // Start new polygon with just a point
                        polygon = L.polygon([points[0]], {
                            color: '#3498db',
                            weight: 2,
                            fillColor: '#3498db',
                            fillOpacity: 0.2
                        }).addTo(drawnItems);
                        
                        // Add marker for first point
                        L.circleMarker(points[0], {
                            radius: 4,
                            color: '#3498db',
                            fillColor: '#ffffff',
                            fillOpacity: 1,
                            weight: 2
                        }).addTo(drawnItems);
                        
                        // Create temporary line for preview
                        tempLine = L.polyline([points[0], points[0]], {
                            color: '#3498db',
                            weight: 2,
                            opacity: 0.5,
                            dashArray: '5,5'
                        }).addTo(map);
                        
                        measureInfo.textContent = 'Click to add points, double-click to close polygon';
                    } else {
                        // Add marker for each point
                        L.circleMarker(points[points.length - 1], {
                            radius: 4,
                            color: '#3498db',
                            fillColor: '#ffffff',
                            fillOpacity: 1,
                            weight: 2
                        }).addTo(drawnItems);
                        
                        // Update polygon with current points plus first point to close
                        const polygonPoints = [...points];
                        if (points.length >= 3) {
                            polygonPoints.push(points[0]); // Close the polygon for preview
                        }
                        polygon.setLatLngs(polygonPoints);
                        
                        // Update temporary line start point
                        if (tempLine) {
                            tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                        }
                        
                        // Calculate area if we have at least 3 points
                        if (points.length >= 3) {
                            const closePoints = [...points, points[0]];
                            const area = L.GeometryUtil.geodesicArea(closePoints);
                            const displayArea = area >= 1000000 ? 
                                `${(area / 1000000).toFixed(2)} km²` : 
                                `${area.toFixed(0)} m²`;
                            measureInfo.textContent = `Area: ${displayArea} (Double-click to finish)`;
                        }
                    }
                }
                
                function onMouseMove(e) {
                    if (points.length > 0 && tempLine) {
                        // Update temporary line
                        tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                        
                        // Show preview of polygon with current mouse position
                        if (points.length >= 2) {
                            const previewPoints = [...points, e.latlng];
                            if (points.length >= 3) {
                                previewPoints.push(points[0]); // Close polygon
                            }
                            polygon.setLatLngs(previewPoints);
                            
                            // Calculate preview area
                            if (points.length >= 2) {
                                const previewArea = L.GeometryUtil.geodesicArea([...points, e.latlng, points[0]]);
                                const displayArea = previewArea >= 1000000 ? 
                                    `${(previewArea / 1000000).toFixed(2)} km²` : 
                                    `${previewArea.toFixed(0)} m²`;
                                measureInfo.textContent = `Area: ${displayArea} (Click to add point, double-click to finish)`;
                            }
                        }
                    }
                }
                
                function onDoubleClick(e) {
                    if (points.length >= 3) {
                        if (tempLine) {
                            map.removeLayer(tempLine);
                        }
                        
                        // Close the polygon
                        points.push(points[0]);
                        polygon.setLatLngs(points);
                        
                        // Calculate final area
                        const area = L.GeometryUtil.geodesicArea(points);
                        const displayArea = area >= 1000000 ? 
                            `${(area / 1000000).toFixed(2)} km²` : 
                            `${area.toFixed(0)} m²`;
                        
                        // Add area label in the center of polygon
                        const center = polygon.getBounds().getCenter();
                        const areaLabel = L.divIcon({
                            className: 'measure-label measure-area',
                            html: `<strong>Area: ${displayArea}</strong>`
                        });
                        
                        L.marker(center, { icon: areaLabel }).addTo(drawnItems);
                        
                        // Clean up event listeners
                        map.off('click', onMapClick);
                        map.off('mousemove', onMouseMove);
                        map.off('dblclick', onDoubleClick);
                        document.removeEventListener('keydown', onKeyDown);
                        document.getElementById('measure-area-btn').classList.remove('active');
                        
                        setTimeout(() => {
                            measureInfo.style.display = 'none';
                            map.getContainer().style.cursor = '';
                        }, 2000);
                    }
                }

                function onKeyDown(e) {
                    if (e.key === 'Escape') {
                        stopAreaMeasurement();
                    } else if (e.key === 'Enter' && points.length >= 3) {
                        // Complete polygon on Enter
                        onDoubleClick(null);
                    }
                }

                function stopAreaMeasurement() {
                    if (tempLine) {
                        map.removeLayer(tempLine);
                    }
                    map.off('click', onMapClick);
                    map.off('mousemove', onMouseMove);
                    map.off('dblclick', onDoubleClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('measure-area-btn').classList.remove('active');
                    map.getContainer().style.cursor = '';
                    setTimeout(() => {
                        measureInfo.style.display = 'none';
                    }, 2000);
                    removeStopButton();
                }

                // Start measurement mode
                map.on('click', onMapClick);
                map.on('mousemove', onMouseMove);
                map.on('dblclick', onDoubleClick);
                document.addEventListener('keydown', onKeyDown);
                measureControl.area = polygon;
                ensureStopButton(stopAreaMeasurement);
                function stopAreaMeasurement() {
                    if (tempLine) {
                        map.removeLayer(tempLine);
                    }
                    map.off('click', onMapClick);
                    map.off('mousemove', onMouseMove);
                    map.off('dblclick', onDoubleClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('measure-area-btn').classList.remove('active');
                    map.getContainer().style.cursor = '';
                    setTimeout(() => {
                        measureInfo.style.display = 'none';
                    }, 2000);
                    removeStopButton();
                }
            }

            // Enhanced Polygon/Rectangle/Circle drawing
            function startDrawingTool(shape) {
                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';
                
                const drawingControls = document.getElementById('drawing-controls');
                drawingControls.classList.add('active');
                
                let drawObj = null;
                let isDrawing = false;
                let startPoint = null;
                let currentLayer = null;
                
                function onMapClick(e) {
                    if (shape === 'polygon') {
                        if (!isDrawing) {
                            // Start new polygon
                            startPoint = e.latlng;
                            drawObj = {
                                type: 'polygon',
                                points: [startPoint],
                                layer: L.polygon([startPoint], {
                                    color: document.getElementById('stroke-color').value,
                                    fillColor: document.getElementById('fill-color').value,
                                    fillOpacity: 0.3
                                }).addTo(drawnItems)
                            };
                            isDrawing = true;
                            
                            // Add temporary line for preview
                            currentLayer = L.polyline([startPoint, startPoint], {
                                color: document.getElementById('stroke-color').value,
                                dashArray: '5,5',
                                weight: 2
                            }).addTo(map);
                            
                        } else {
                            // Add point to existing polygon
                            drawObj.points.push(e.latlng);
                            drawObj.layer.setLatLngs(drawObj.points);
                            
                            // Update temporary line
                            if (currentLayer) {
                                currentLayer.setLatLngs([drawObj.points[drawObj.points.length - 1], e.latlng]);
                            }
                        }
                    } else if (shape === 'rectangle' || shape === 'circle') {
                        if (!isDrawing) {
                            startPoint = e.latlng;
                            isDrawing = true;
                            
                            if (shape === 'rectangle') {
                                drawObj = {
                                    type: 'rectangle',
                                    startPoint: startPoint,
                                    layer: L.rectangle([[startPoint.lat, startPoint.lng], [startPoint.lat, startPoint.lng]], {
                                        color: document.getElementById('stroke-color').value,
                                        fillColor: document.getElementById('fill-color').value,
                                        fillOpacity: 0.3
                                    }).addTo(drawnItems)
                                };
                            } else {
                                drawObj = {
                                    type: 'circle',
                                    center: startPoint,
                                    radius: 0,
                                    layer: L.circle(startPoint, {
                                        radius: 0,
                                        color: document.getElementById('stroke-color').value,
                                        fillColor: document.getElementById('fill-color').value,
                                        fillOpacity: 0.3
                                    }).addTo(drawnItems)
                                };
                            }
                        } else {
                            // Complete the shape on second click
                            isDrawing = false;
                            if (currentLayer) {
                                map.removeLayer(currentLayer);
                                currentLayer = null;
                            }
                            
                            drawingHistory.push({
                                type: shape,
                                layer: drawObj.layer
                            });
                            
                            map.off('mousemove', onMouseMove);
                            map.off('click', onMapClick);
                            document.removeEventListener('keydown', onKeyDown);
                            document.querySelector('.toolbar-btn.active')?.classList.remove('active');
                            drawingControls.classList.remove('active');
                            map.getContainer().style.cursor = '';
                        }
                    }
                }
                
                function onMouseMove(e) {
                    if (isDrawing) {
                        if (shape === 'polygon' && currentLayer) {
                            // Update temporary line for polygon preview
                            currentLayer.setLatLngs([drawObj.points[drawObj.points.length - 1], e.latlng]);
                            
                            // Show preview of complete polygon
                            if (drawObj.points.length > 2) {
                                const previewPoints = [...drawObj.points, e.latlng, drawObj.points[0]];
                                drawObj.layer.setLatLngs(previewPoints);
                            }
                        } else if (shape === 'rectangle') {
                            // Update rectangle dimensions
                            drawObj.layer.setBounds([
                                [startPoint.lat, startPoint.lng],
                                [e.latlng.lat, e.latlng.lng]
                            ]);
                        } else if (shape === 'circle') {
                            // Update circle radius
                            const radius = startPoint.distanceTo(e.latlng);
                            drawObj.radius = radius;
                            drawObj.layer.setRadius(radius);
                            
                            // Show radius while drawing
                            const drawingInfo = document.getElementById('measure-info');
                            drawingInfo.style.display = 'block';
                            drawingInfo.textContent = `Radius: ${radius >= 1000 ? (radius / 1000).toFixed(2) + ' km' : radius.toFixed(0) + ' m'}`;
                        }
                    }
                }
                
                function onDoubleClick(e) {
                    if (isDrawing && shape === 'polygon' && drawObj.points.length > 2) {
                        // Close polygon
                        drawObj.points.push(drawObj.points[0]);
                        drawObj.layer.setLatLngs(drawObj.points);
                        
                        if (currentLayer) {
                            map.removeLayer(currentLayer);
                        }
                        
                        // Add to drawing history
                        drawingHistory.push({
                            type: 'polygon',
                            layer: drawObj.layer
                        });
                        
                        // Clean up
                        isDrawing = false;
                        map.off('mousemove', onMouseMove);
                        map.off('click', onMapClick);
                        map.off('dblclick', onDoubleClick);
                        document.removeEventListener('keydown', onKeyDown);
                        document.querySelector('.toolbar-btn.active')?.classList.remove('active');
                        drawingControls.classList.remove('active');
                        map.getContainer().style.cursor = '';
                    }
                }
                
                function onKeyDown(e) {
                    if (e.key === 'Escape') {
                        // Cancel drawing
                        if (isDrawing) {
                            if (drawObj && drawObj.layer) {
                                drawnItems.removeLayer(drawObj.layer);
                            }
                            if (currentLayer) {
                                map.removeLayer(currentLayer);
                            }
                        }
                        
                        // Clean up
                        isDrawing = false;
                        map.off('mousemove', onMouseMove);
                        map.off('click', onMapClick);
                        map.off('dblclick', onDoubleClick);
                        document.removeEventListener('keydown', onKeyDown);
                        document.querySelector('.toolbar-btn.active')?.classList.remove('active');
                        drawingControls.classList.remove('active');
                        map.getContainer().style.cursor = '';
                        
                        // Hide measurement info if visible
                        const drawingInfo = document.getElementById('measure-info');
                        drawingInfo.style.display = 'none';
                    }
                }
                
                // Setup event handlers
                map.on('click', onMapClick);
                map.on('mousemove', onMouseMove);
                if (shape === 'polygon') {
                    map.on('dblclick', onDoubleClick);
                }
                document.addEventListener('keydown', onKeyDown);
                ensureStopButton(cancelDrawing);
                function cancelDrawing() {
                    if (isDrawing) {
                        if (drawObj && drawObj.layer) {
                            drawnItems.removeLayer(drawObj.layer);
                        }
                        if (currentLayer) {
                            map.removeLayer(currentLayer);
                        }
                    }
                    
                    // Clean up
                    isDrawing = false;
                    map.off('mousemove', onMouseMove);
                    map.off('click', onMapClick);
                    map.off('dblclick', onDoubleClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.querySelector('.toolbar-btn.active')?.classList.remove('active');
                    drawingControls.classList.remove('active');
                    map.getContainer().style.cursor = '';
                    
                    // Hide measurement info if visible
                    const drawingInfo = document.getElementById('measure-info');
                    drawingInfo.style.display = 'none';
                    removeStopButton();
                }
            }

            // Function to handle marker placement with live tracking
            function startMarkerPlacement() {
                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';
                
                const drawingControls = document.getElementById('drawing-controls');
                drawingControls.classList.add('active');
                
                // Create a temporary preview marker that follows mouse
                let previewMarker = null;
                
                function createPreviewMarker(latlng) {
                    return L.marker(latlng, {
                        icon: L.divIcon({
                            className: 'preview-marker',
                            html: `<i class="fas fa-map-marker-alt" style="color:${document.getElementById('stroke-color').value}; opacity:0.7; font-size:24px;"></i>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 24]
                        }),
                        zIndexOffset: 1000
                    }).addTo(map);
                }
                
                function onMouseMove(e) {
                    if (!previewMarker) {
                        previewMarker = createPreviewMarker(e.latlng);
                    } else {
                        previewMarker.setLatLng(e.latlng);
                    }
                    
                    // Show coordinates
                    const info = document.getElementById('measure-info');
                    info.style.display = 'block';
                    info.textContent = `Lat: ${e.latlng.lat.toFixed(6)}, Lng: ${e.latlng.lng.toFixed(6)}`;
                }
                
                function onMapClick(e) {
                    // Create permanent marker with popup for editing
                    const marker = L.marker(e.latlng, {
                        icon: L.divIcon({
                            className: 'custom-marker',
                            html: `<i class="fas fa-map-marker-alt" style="color:${document.getElementById('stroke-color').value}; font-size:24px;"></i>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 24]
                        }),
                        draggable: true // Make marker draggable
                    }).addTo(drawnItems);
                    
                    // Create a popup with editing options
                    const popupContent = `
                        <div class="marker-edit-popup">
                            <p>Marker at Lat: ${e.latlng.lat.toFixed(6)}, Lng: ${e.latlng.lng.toFixed(6)}</p>
                            <div class="marker-actions">
                                <button class="btn btn-sm" id="change-marker-color">Change Color</button>
                                <button class="btn btn-sm" id="delete-marker">Delete</button>
                                <button class="btn btn-sm" id="add-label">Add Label</button>
                            </div>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    
                    // Add event handlers for the popup buttons
                    marker.on('popupopen', function() {
                        setTimeout(() => {
                            const colorBtn = document.getElementById('change-marker-color');
                            const deleteBtn = document.getElementById('delete-marker');
                            const labelBtn = document.getElementById('add-label');
                            
                            if (colorBtn) {
                                colorBtn.addEventListener('click', function() {
                                    const color = document.getElementById('stroke-color').value;
                                    const newIcon = L.divIcon({
                                        className: 'custom-marker',
                                        html: `<i class="fas fa-map-marker-alt" style="color:${color}; font-size:24px;"></i>`,
                                        iconSize: [24, 24],
                                        iconAnchor: [12, 24]
                                    });
                                    marker.setIcon(newIcon);
                                    marker.closePopup();
                                });
                            }
                            
                            if (deleteBtn) {
                                deleteBtn.addEventListener('click', function() {
                                    drawnItems.removeLayer(marker);
                                    // Also remove from history if needed
                                    const index = drawingHistory.findIndex(item => item.layer === marker);
                                    if (index !== -1) {
                                        drawingHistory.splice(index, 1);
                                    }
                                });
                            }
                            
                            if (labelBtn) {
                                labelBtn.addEventListener('click', function() {
                                    const label = prompt('Enter label text:', '');
                                    if (label) {
                                        const newIcon = L.divIcon({
                                            className: 'custom-marker',
                                            html: `
                                                <div style="position:relative;">
                                                    <i class="fas fa-map-marker-alt" style="color:${document.getElementById('stroke-color').value}; font-size:24px;"></i>
                                                    <div style="position:absolute; bottom:-5px; left:50%; transform:translateX(-50%); background:white; padding:2px 5px; border-radius:3px; white-space:nowrap; border:1px solid #ccc; font-size:12px;">
                                                        ${label}
                                                    </div>
                                                </div>
                                            `,
                                            iconSize: [24, 36],
                                            iconAnchor: [12, 24]
                                        });
                                        marker.setIcon(newIcon);
                                        marker.closePopup();
                                    }
                                });
                            }
                        }, 10);
                    });
                    
                    // Update coordinates on drag
                    marker.on('dragend', function(e) {
                        const position = e.target.getLatLng();
                        const newPopupContent = `
                            <div class="marker-edit-popup">
                                <p>Marker at Lat: ${position.lat.toFixed(6)}, Lng: ${position.lng.toFixed(6)}</p>
                                <div class="marker-actions">
                                    <button class="btn btn-sm" id="change-marker-color">Change Color</button>
                                    <button class="btn btn-sm" id="delete-marker">Delete</button>
                                    <button class="btn btn-sm" id="add-label">Add Label</button>
                                </div>
                            </div>
                        `;
                        marker.setPopupContent(newPopupContent);
                    });
                    
                    // Add to history
                    drawingHistory.push({
                        type: 'marker',
                        layer: marker
                    });
                    
                    // Allow clicking multiple times to place multiple markers
                    // Continue tracking mouse for next marker
                }
                
                function onKeyDown(e) {
                    if (e.key === 'Escape') {
                        stopMarkerPlacement();
                    }
                }
                
                function stopMarkerPlacement() {
                    if (previewMarker) {
                        map.removeLayer(previewMarker);
                    }
                    
                    map.off('mousemove', onMouseMove);
                    map.off('click', onMapClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('draw-marker-btn').classList.remove('active');
                    map.getContainer().style.cursor = ''; // Reset cursor to default
                    drawingControls.classList.remove('active');
                    
                    const info = document.getElementById('measure-info');
                    info.style.display = 'none';
                    removeStopButton();
                }
                
                map.on('mousemove', onMouseMove);
                map.on('click', onMapClick);
                document.addEventListener('keydown', onKeyDown);
                ensureStopButton(stopMarkerPlacement);
            }

            // Enhanced line drawing with live preview
            function startLineDraw() {
                let points = [];
                let line = null;
                let isDrawing = true;
                let tempLine = null;
                
                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';
                
                // Show drawing controls
                const drawingControls = document.getElementById('drawing-controls');
                drawingControls.classList.add('active');

                // Add stop button to drawing controls if not already present
                let stopButton = document.getElementById('stop-drawing-btn');
                if (!stopButton) {
                    stopButton = document.createElement('button');
                    stopButton.className = 'toolbar-btn';
                    stopButton.id = 'stop-drawing-btn';
                    stopButton.innerHTML = '<i class="fas fa-stop"></i>';
                    stopButton.title = 'Stop Drawing';
                    stopButton.style.backgroundColor = '#e74c3c';
                    stopButton.style.color = 'white';
                    drawingControls.appendChild(stopButton);
                }

                stopButton.onclick = function() {
                    if (points.length > 1) {
                        finalizeLine();
                    } else {
                        cancelDrawing();
                    }
                };

                function finalizeLine() {
                    if (tempLine) {
                        map.removeLayer(tempLine);
                    }
                    if (line) {
                        drawingHistory.push({
                            type: 'line',
                            layer: line
                        });
                    }
                    cleanup();
                }

                function cancelDrawing() {
                    if (line) {
                        drawnItems.removeLayer(line);
                    }
                    if (tempLine) {
                        map.removeLayer(tempLine);
                    }
                    cleanup();
                }

                function cleanup() {
                    // Remove stop button
                    if (stopButton && stopButton.parentNode) {
                        stopButton.parentNode.removeChild(stopButton);
                    }
                    map.off('click', onMapClick);
                    map.off('mousemove', onMapMove);
                    map.off('dblclick', onDoubleClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('draw-line-btn').classList.remove('active');
                    drawingControls.classList.remove('active');
                    map.getContainer().style.cursor = '';
                    document.getElementById('measure-info').style.display = 'none';
                    isDrawing = false;
                }

                function onMapClick(e) {
                    points.push(e.latlng);
                    
                    if (points.length === 1) {
                        // Start new line
                        line = L.polyline([points[0]], {
                            color: document.getElementById('stroke-color').value,
                            weight: 3,
                            opacity: 0.8,
                            dashArray: '5, 10'
                        }).addTo(drawnItems);
                        
                        // Add point marker
                        L.circleMarker(points[0], {
                            radius: 4,
                            color: document.getElementById('stroke-color').value,
                            fillColor: '#ffffff',
                            fillOpacity: 1,
                            weight: 2
                        }).addTo(drawnItems);
                        
                        // Create temporary line for preview
                        tempLine = L.polyline([points[0], e.latlng], {
                            color: document.getElementById('stroke-color').value,
                            weight: 2,
                            opacity: 0.5,
                            dashArray: '5,5'
                        }).addTo(map);
                    } else {
                        // Add point to existing line
                        line.setLatLngs(points);
                        
                        // Add point marker
                        L.circleMarker(points[points.length - 1], {
                            radius: 4,
                            color: document.getElementById('stroke-color').value,
                            fillColor: '#ffffff',
                            fillOpacity: 1,
                            weight: 2
                        }).addTo(drawnItems);
                        
                        // Update temporary line start point
                        if (tempLine) {
                            tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                        }
                    }
                    
                    // Show measurement info
                    if (points.length > 1) {
                        let totalLength = 0;
                        for (let i = 1; i < points.length; i++) {
                            totalLength += L.latLng(points[i-1]).distanceTo(points[i]);
                        }
                        
                        const displayLength = totalLength >= 1000 ? 
                            `${(totalLength / 1000).toFixed(2)} km` : 
                            `${totalLength.toFixed(0)} m`;
                            
                        const info = document.getElementById('measure-info');
                        info.style.display = 'block';
                        info.textContent = `Line length: ${displayLength}`;
                    }
                }

                function onMapMove(e) {
                    if (points.length > 0 && tempLine) {
                        tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                        
                        if (points.length > 0) {
                            // Calculate current segment length
                            const hoverLength = L.latLng(points[points.length - 1]).distanceTo(e.latlng);
                            
                            // Calculate total length including previous segments
                            let totalLength = hoverLength;
                            for (let i = 1; i < points.length; i++) {
                                totalLength += L.latLng(points[i-1]).distanceTo(points[i]);
                            }
                            
                            const displayLength = totalLength >= 1000 ? 
                                `${(totalLength / 1000).toFixed(2)} km` : 
                                `${totalLength.toFixed(0)} m`;
                                
                            const info = document.getElementById('measure-info');
                            info.style.display = 'block';
                            info.textContent = `Line length: ${displayLength} (Double-click to finish)`;
                        }
                    }
                }

                function onDoubleClick(e) {
                    if (points.length > 1) {
                        finalizeLine();
                    }
                }

                function onKeyDown(e) {
                    if (e.key === 'Escape') {
                        cancelDrawing();
                    }
                }

                map.on('click', onMapClick);
                map.on('mousemove', onMapMove);
                map.on('dblclick', onDoubleClick);
                document.addEventListener('keydown', onKeyDown);
                ensureStopButton(() => {
                    if (points.length > 1) {
                        finalizeLine();
                    } else {
                        cancelDrawing();
                    }
                });
                function cleanup() {
                    // ... existing code ...
                    removeStopButton();
                    // ... existing code ...
                }
            }

            // Update tool activation functions
            document.getElementById('draw-marker-btn').addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    this.classList.remove('active');
                    map.off('click');
                    map.off('mousemove'); // Make sure to remove mousemove handler
                    document.removeEventListener('keydown', onKeyDown);
                    map.getContainer().style.cursor = ''; // Reset cursor to default
                    document.getElementById('drawing-controls').classList.remove('active');
                    document.getElementById('measure-info').style.display = 'none';
                } else {
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    startMarkerPlacement();
                }
            });

            document.getElementById('draw-line-btn').addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    this.classList.remove('active');
                    map.off('click');
                    map.off('mousemove');
                    map.off('dblclick');
                    document.removeEventListener('keydown', onKeyDown);
                    map.getContainer().style.cursor = '';
                    document.getElementById('drawing-controls').classList.remove('active');
                    document.getElementById('measure-info').style.display = 'none';
                    
                    // Remove stop button if it exists
                    if (document.getElementById('stop-drawing-btn')) {
                        document.getElementById('stop-drawing-btn').remove();
                    }
                } else {
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    startLineDraw();
                }
            });

            // Polygon submenu handlers
            document.querySelectorAll('#draw-polygon-btn .submenu-item').forEach(item => {
                item.addEventListener('click', function() {
                    const shape = this.dataset.shape;
                    const button = document.getElementById('draw-polygon-btn');
                    
                    if (button.classList.contains('active')) {
                        button.classList.remove('active');
                        map.off('click');
                        map.off('mousemove');
                        map.off('dblclick');
                        document.removeEventListener('keydown', onKeyDown);
                        map.getContainer().style.cursor = '';
                        document.getElementById('drawing-controls').classList.remove('active');
                        document.getElementById('measure-info').style.display = 'none';
                    } else {
                        document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        startDrawingTool(shape);
                    }
                });
            });

            document.getElementById('measure-distance-btn').addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    this.classList.remove('active');
                    if (measureControl.distance) {
                        drawnItems.removeLayer(measureControl.distance);
                        measureControl.distance = null;
                    }
                    document.getElementById('measure-info').style.display = 'none';
                    map.off('click');
                    map.off('mousemove');
                    map.getContainer().style.cursor = '';
                } else {
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    startMeasurement('distance');
                }
            });

            document.getElementById('measure-area-btn').addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    this.classList.remove('active');
                    if (measureControl.area) {
                        drawnItems.removeLayer(measureControl.area);
                        measureControl.area = null;
                    }
                    document.getElementById('measure-info').style.display = 'none';
                    map.off('click');
                    map.off('mousemove');
                    map.getContainer().style.cursor = '';
                } else {
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    startAreaMeasurement();
                }
            });
            
            // Add text annotation tool
            const textTool = document.createElement('button');
            textTool.className = 'toolbar-btn';
            textTool.id = 'text-annotation-btn';
            textTool.innerHTML = '<i class="fas fa-font"></i><div class="toolbar-tooltip">Add Text</div>';
            document.querySelector('.toolbar-section:nth-child(3)').appendChild(textTool);
            
            textTool.addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    this.classList.remove('active');
                    map.off('click');
                    map.getContainer().style.cursor = '';
                } else {
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    map.getContainer().style.cursor = 'crosshair';
                    
                    function addTextAnnotation(e) {
                        const text = prompt('Enter text for annotation:', '');
                        if (text) {
                            const textIcon = L.divIcon({
                                className: 'text-annotation',
                                html: `<div style="background:white; padding:5px; border-radius:4px; border:2px solid ${document.getElementById('stroke-color').value}; color:#333;">${text}</div>`,
                                iconAnchor: [0, 0]
                            });
                            
                            const marker = L.marker(e.latlng, {
                                icon: textIcon,
                                draggable: true
                            }).addTo(drawnItems);
                            
                            drawingHistory.push({
                                type: 'text',
                                layer: marker
                            });
                            
                            // Let user place multiple texts
                        }
                    }
                    
                    map.on('click', addTextAnnotation);
                }
            });
            
            // Add grid overlay tool
            const gridTool = document.createElement('button');
            gridTool.className = 'toolbar-btn';
            gridTool.id = 'grid-overlay-btn';
            gridTool.innerHTML = '<i class="fas fa-th"></i><div class="toolbar-tooltip">Toggle Grid</div>';
            document.querySelector('.toolbar-section:nth-child(5)').appendChild(gridTool);
            
            let gridLayer = null;
            
            gridTool.addEventListener('click', function() {
                this.classList.toggle('active');
                
                if (this.classList.contains('active')) {
                    // Create grid overlay
                    gridLayer = L.layerGroup().addTo(map);
                    
                    const bounds = map.getBounds();
                    const zoom = map.getZoom();
                    
                    // Calculate grid cell size based on zoom level
                    const cellSize = zoom > 12 ? 0.001 : 
                                    zoom > 10 ? 0.005 : 
                                    zoom > 8 ? 0.01 : 
                                    zoom > 6 ? 0.05 : 0.1;
                    
                    // Draw vertical lines
                    for (let lng = Math.floor(bounds.getWest() / cellSize) * cellSize; 
                        lng <= bounds.getEast(); 
                        lng += cellSize) {
                        L.polyline([
                            [bounds.getSouth(), lng],
                            [bounds.getNorth(), lng]
                        ], {
                            color: '#777',
                            weight: 1,
                            opacity: 0.5,
                            dashArray: '3,3'
                        }).addTo(gridLayer);
                    }
                    
                    // Draw horizontal lines
                    for (let lat = Math.floor(bounds.getSouth() / cellSize) * cellSize; 
                        lat <= bounds.getNorth(); 
                        lat += cellSize) {
                        L.polyline([
                            [lat, bounds.getWest()],
                            [lat, bounds.getEast()]
                        ], {
                            color: '#777',
                            weight: 1,
                            opacity: 0.5,
                            dashArray: '3,3'
                        }).addTo(gridLayer);
                    }
                } else {
                    // Remove grid
                    if (gridLayer) {
                        map.removeLayer(gridLayer);
                        gridLayer = null;
                    }
                }
            });
            
            // Color picker handlers
            document.getElementById('stroke-color').addEventListener('change', function(e) {
                if (drawnItems.getLayers().length > 0) {
                    drawnItems.eachLayer(layer => {
                        if (layer.setStyle) {
                            layer.setStyle({ color: e.target.value });
                        }
                    });
                }
            });

            document.getElementById('fill-color').addEventListener('change', function(e) {
                if (drawnItems.getLayers().length > 0) {
                    drawnItems.eachLayer(layer => {
                        if (layer.setStyle) {
                            layer.setStyle({ fillColor: e.target.value });
                        }
                    });
                }
            });

            function startAreaMeasurement() {
                const measureInfo = document.getElementById('measure-info');
                let polygon = null;
                let points = [];

                function onMapClick(e) {
                    points.push(e.latlng);
                    
                    if (points.length === 1) {
                        // Start new polygon
                        polygon = L.polygon([points[0]], {
                            color: '#3498db',
                            weight: 2,
                            fillColor: '#3498db',
                            fillOpacity: 0.2
                        }).addTo(drawnItems);
                    } else {
                        // Update polygon
                        polygon.setLatLngs(points);
                        
                        // Calculate area if we have at least 3 points
                        if (points.length >= 3) {
                            const area = L.GeometryUtil.geodesicArea(points);
                            const displayArea = area >= 1000000 ? 
                                `${(area / 1000000).toFixed(2)} km²` : 
                                `${area.toFixed(0)} m²`;
                            measureInfo.textContent = `Area: ${displayArea}`;
                            measureInfo.classList.add('active');
                        }
                    }
                }

                function onKeyDown(e) {
                    if (e.key === 'Escape') {
                        stopAreaMeasurement();
                    } else if (e.key === 'Enter' && points.length >= 3) {
                        // Complete polygon on Enter
                        points.push(points[0]); // Close the polygon
                        polygon.setLatLngs(points);
                        stopAreaMeasurement();
                    }
                }

                function stopAreaMeasurement() {
                    map.off('click', onMapClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('measure-area-btn').classList.remove('active');
                    setTimeout(() => {
                        measureInfo.classList.remove('active');
                    }, 2000);
                }

                // Start measurement mode
                map.on('click', onMapClick);
                document.addEventListener('keydown', onKeyDown);
                measureControl.area = polygon;
                ensureStopButton(stopAreaMeasurement);
                function stopAreaMeasurement() {
                    map.off('click', onMapClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('measure-area-btn').classList.remove('active');
                    setTimeout(() => {
                        measureInfo.classList.remove('active');
                    }, 2000);
                    removeStopButton();
                }
            }

            document.getElementById('measure-area-btn').addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    // Stop measurement
                    this.classList.remove('active');
                    if (measureControl.area) {
                        drawnItems.removeLayer(measureControl.area);
                        measureControl.area = null;
                    }
                    document.getElementById('measure-info').classList.remove('active');
                    map.off('click');
                } else {
                    // Start measurement
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    startAreaMeasurement();
                }
            });

            // Enhanced line drawing
            document.getElementById('draw-line-btn').addEventListener('click', function() {
                if (this.classList.contains('active')) {
                    // Stop drawing
                    this.classList.remove('active');
                    map.off('click');
                    document.removeEventListener('keydown', onKeyDown);
                } else {
                    // Start drawing
                    document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    startLineDraw();
                }
            });

            function startLineDraw() {
                let points = [];
                let line = null;
                let isDrawing = true;
                let tempLine = null;
                map.getContainer().style.cursor = 'crosshair';

                // Show drawing controls
                const drawingControls = document.getElementById('drawing-controls');
                drawingControls.classList.add('active');

                // Add stop button to drawing controls if not already present
                let stopButton = document.getElementById('stop-drawing-btn');
                if (!stopButton) {
                    stopButton = document.createElement('button');
                    stopButton.className = 'toolbar-btn';
                    stopButton.id = 'stop-drawing-btn';
                    stopButton.innerHTML = '<i class="fas fa-stop"></i>';
                    stopButton.title = 'Stop Drawing';
                    stopButton.style.backgroundColor = '#e74c3c';
                    stopButton.style.color = 'white';
                    drawingControls.appendChild(stopButton);
                }

                stopButton.onclick = function() {
                    if (points.length > 1) {
                        finalizeLine();
                    } else {
                        cancelDrawing();
                    }
                };

                function finalizeLine() {
                    if (tempLine) {
                        map.removeLayer(tempLine);
                    }
                    if (line) {
                        drawingHistory.push({
                            type: 'line',
                            layer: line
                        });
                    }
                    cleanup();
                }

                function cancelDrawing() {
                    if (line) {
                        drawnItems.removeLayer(line);
                    }
                    if (tempLine) {
                        map.removeLayer(tempLine);
                    }
                    cleanup();
                }

                function cleanup() {
                    // Remove stop button
                    if (stopButton && stopButton.parentNode) {
                        stopButton.parentNode.removeChild(stopButton);
                    }
                    map.off('click', onMapClick);
                    map.off('mousemove', onMapMove);
                    map.off('dblclick', onDoubleClick);
                    document.removeEventListener('keydown', onKeyDown);
                    document.getElementById('draw-line-btn').classList.remove('active');
                    drawingControls.classList.remove('active');
                    map.getContainer().style.cursor = '';
                    document.getElementById('measure-info').style.display = 'none';
                    isDrawing = false;
                    removeStopButton();
                }

                function onMapClick(e) {
                    points.push(e.latlng);
                    
                    if (points.length === 1) {
                        // Start new line
                        line = L.polyline([points[0]], {
                            color: document.getElementById('stroke-color').value,
                            weight: 3,
                            opacity: 0.8,
                            dashArray: '5, 10'
                        }).addTo(drawnItems);
                        
                        // Add point marker
                        L.circleMarker(points[0], {
                            radius: 4,
                            color: document.getElementById('stroke-color').value,
                            fillColor: '#ffffff',
                            fillOpacity: 1,
                            weight: 2
                        }).addTo(drawnItems);
                        
                        // Create temporary line for preview
                        tempLine = L.polyline([points[0], e.latlng], {
                            color: document.getElementById('stroke-color').value,
                            weight: 2,
                            opacity: 0.5,
                            dashArray: '5,5'
                        }).addTo(map);
                    } else {
                        // Add point to existing line
                        line.setLatLngs(points);
                        
                        // Add point marker
                        L.circleMarker(points[points.length - 1], {
                            radius: 4,
                            color: document.getElementById('stroke-color').value,
                            fillColor: '#ffffff',
                            fillOpacity: 1,
                            weight: 2
                        }).addTo(drawnItems);
                        
                        // Update temporary line start point
                        if (tempLine) {
                            tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                        }
                    }
                    
                    // Show measurement info
                    if (points.length > 1) {
                        let totalLength = 0;
                        for (let i = 1; i < points.length; i++) {
                            totalLength += L.latLng(points[i-1]).distanceTo(points[i]);
                        }
                        
                        const displayLength = totalLength >= 1000 ? 
                            `${(totalLength / 1000).toFixed(2)} km` : 
                            `${totalLength.toFixed(0)} m`;
                            
                        const info = document.getElementById('measure-info');
                        info.style.display = 'block';
                        info.textContent = `Line length: ${displayLength}`;
                    }
                }

                function onMapMove(e) {
                    if (points.length > 0 && tempLine) {
                        tempLine.setLatLngs([points[points.length - 1], e.latlng]);
                        
                        if (points.length > 0) {
                            // Calculate current segment length
                            const hoverLength = L.latLng(points[points.length - 1]).distanceTo(e.latlng);
                            
                            // Calculate total length including previous segments
                            let totalLength = hoverLength;
                            for (let i = 1; i < points.length; i++) {
                                totalLength += L.latLng(points[i-1]).distanceTo(points[i]);
                            }
                            
                            const displayLength = totalLength >= 1000 ? 
                                `${(totalLength / 1000).toFixed(2)} km` : 
                                `${totalLength.toFixed(0)} m`;
                                
                            const info = document.getElementById('measure-info');
                            info.style.display = 'block';
                            info.textContent = `Line length: ${displayLength} (Double-click to finish)`;
                        }
                    }
                }

                function onDoubleClick(e) {
                    if (points.length > 1) {
                        finalizeLine();
                    }
                }

                function onKeyDown(e) {
                    if (e.key === 'Escape') {
                        cancelDrawing();
                    }
                }

                map.on('click', onMapClick);
                map.on('mousemove', onMapMove);
                map.on('dblclick', onDoubleClick);
                document.addEventListener('keydown', onKeyDown);
                ensureStopButton(() => {
                    if (points.length > 1) {
                        finalizeLine();
                    } else {
                        cancelDrawing();
                    }
                });
            }

            // Mouse position tracking
            const mousePosition = L.control({position: 'bottomright'});
            mousePosition.onAdd = function(map) {
                this._container = L.DomUtil.create('div', 'mouse-position');
                return this._container;
            };
            mousePosition.addTo(map);

            map.on('mousemove', function(e) {
                mousePosition._container.textContent = 
                    `Lat: ${e.latlng.lat.toFixed(6)}, Lng: ${e.latlng.lng.toFixed(6)}`;
            });
        
            // Save Map functionality
            document.getElementById('save-state-btn').addEventListener('click', async function() {
                try {
                    if (!firebase.auth().currentUser) {
                        alert('Please sign in to save map state');
                        return;
                    }

                    const loadingOverlay = document.getElementById('loading-overlay');
                    loadingOverlay.style.display = 'flex';

                    // Get map state
                    const mapCenter = map.getCenter();
                    const mapState = {
                        center: {
                            lat: mapCenter.lat,
                            lng: mapCenter.lng
                        },
                        zoom: map.getZoom(),
                        baseMap: Object.keys(baseMaps).find(key => map.hasLayer(baseMaps[key])) || 'streets',
                        drawings: [],
                        markers: [],
                        timestamp: Date.now(),
                        name: prompt('Enter a name for this map state:', 'Map State ' + new Date().toLocaleString())
                    };

                    if (!mapState.name) {
                        loadingOverlay.style.display = 'none';
                        return;
                    }

                    // Save drawings
                    drawnItems.eachLayer(layer => {
                        if (layer instanceof L.Marker) {
                            const latlng = layer.getLatLng();
                            mapState.markers.push({
                                type: 'marker',
                                position: {
                                    lat: latlng.lat,
                                    lng: latlng.lng
                                }
                            });
                        } else if (layer instanceof L.Polyline) {
                            const isPolygon = layer instanceof L.Polygon;
                            mapState.drawings.push({
                                type: isPolygon ? 'polygon' : 'polyline',
                                points: layer.getLatLngs().map(latlng => ({
                                    lat: latlng.lat,
                                    lng: latlng.lng
                                })),
                                options: {
                                    color: layer.options.color || '#3388ff',
                                    weight: layer.options.weight || 3,
                                    fillColor: layer.options.fillColor || '#3388ff',
                                    fillOpacity: layer.options.fillOpacity || 0.2
                                }
                            });
                        }
                    });

                    // Save to Firebase
                    const userId = firebase.auth().currentUser.uid;
                    await firebase.database().ref(`users/${userId}/mapStates`).push(mapState);

                    loadingOverlay.style.display = 'none';
                    alert('Map state saved successfully!');
                } catch (error) {
                    console.error('Error saving map state:', error);
                    loadingOverlay.style.display = 'none';
                    alert('Failed to save map state. Please try again. Error: ' + error.message);
                }
            });

            // Load map state functionality
            document.getElementById('load-state-btn').addEventListener('click', async function() {
                if (!firebase.auth().currentUser) {
                    alert('Please sign in to load map states');
                    return;
                }

                const loadingOverlay = document.getElementById('loading-overlay');
                loadingOverlay.style.display = 'flex';

                try {
                    const userId = firebase.auth().currentUser.uid;
                    const snapshot = await firebase.database().ref(`users/${userId}/mapStates`).once('value');
                    
                    if (!snapshot.exists()) {
                        alert('No saved map states found');
                        loadingOverlay.style.display = 'none';
                        return;
                    }

                    const mapStates = [];
                    snapshot.forEach(childSnapshot => {
                        mapStates.push({
                            id: childSnapshot.key,
                            ...childSnapshot.val()
                        });
                    });

                    // Sort by timestamp, newest first
                    mapStates.sort((a, b) => b.timestamp - a.timestamp);
                    
                    // Create an enhanced selection dialog with preview and management options
                    const dialog = document.createElement('div');
                    dialog.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        padding: 0;
                        border-radius: 8px;
                        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                        z-index: 1001;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    `;

                    dialog.innerHTML = `
                        <div style="padding: 16px 20px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; display: flex; justify-content: space-between; align-items: center;">
                            <h3 style="margin: 0; font-size: 18px; color: #2c3e50;">Load Map State</h3>
                            <button id="close-map-dialog" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #6c757d;">×</button>
                        </div>
                        
                        <div style="padding: 20px; overflow-y: auto; max-height: 60vh;">
                            <div style="margin-bottom: 16px;">
                                <input type="text" id="search-map-states" placeholder="Search saved states..." style="width: 100%; padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box;">
                            </div>
                            
                            <div id="map-states-container" style="display: flex; flex-direction: column; gap: 12px;">
                                ${mapStates.map((state, index) => `
                                    <div class="map-state-item" data-id="${state.id}" style="border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; cursor: pointer; transition: all 0.2s; position: relative; ${index === 0 ? 'background-color: #f0f7ff; border-color: #b8daff;' : ''}">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <h4 style="margin: 0 0 8px 0; font-size: 16px; color: #343a40;">${state.name || 'Unnamed State'}</h4>
                                            <div style="display: flex; gap: 8px;">
                                                <button class="preview-map-btn" data-id="${state.id}" title="Preview" style="background: none; border: none; color: #007bff; cursor: pointer;">
                                                    <i class="fas fa-eye"></i>
                                                </button>
                                                <button class="delete-map-btn" data-id="${state.id}" title="Delete" style="background: none; border: none; color: #dc3545; cursor: pointer;">
                                                    <i class="fas fa-trash-alt"></i>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div style="font-size: 13px; color: #6c757d; margin-bottom: 8px;">
                                            Created: ${new Date(state.timestamp).toLocaleString()}
                                        </div>
                                        
                                        <div style="font-size: 13px; color: #6c757d; display: flex; gap: 12px;">
                                            <span><i class="fas fa-map-marker-alt"></i> ${state.markers ? state.markers.length : 0} markers</span>
                                            <span><i class="fas fa-draw-polygon"></i> ${state.drawings ? state.drawings.length : 0} drawings</span>
                                            <span><i class="fas fa-map"></i> ${state.baseMap || 'streets'}</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="padding: 16px 20px; background: #f8f9fa; border-top: 1px solid #e9ecef; display: flex; justify-content: flex-end; gap: 10px;">
                            <button class="btn btn-secondary" id="cancel-load" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; background-color: #6c757d; color: white;">Cancel</button>
                            <button class="btn btn-primary" id="confirm-load" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; background-color: #007bff; color: white;" ${mapStates.length > 0 ? '' : 'disabled'}>Load Selected</button>
                        </div>
                    `;

                    document.body.appendChild(dialog);
                    
                    // Add overlay to prevent interaction with the background
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                    `;
                    document.body.appendChild(overlay);
                    
                    loadingOverlay.style.display = 'none';
                    
                    // Handlers for the dialog
                    let selectedStateId = mapStates.length > 0 ? mapStates[0].id : null;
                    const confirmLoadBtn = document.getElementById('confirm-load');
                    
                    // Search functionality
                    document.getElementById('search-map-states').addEventListener('input', function(e) {
                        const searchTerm = e.target.value.toLowerCase();
                        const container = document.getElementById('map-states-container');
                        const items = container.querySelectorAll('.map-state-item');
                        
                        items.forEach(item => {
                            const stateName = item.querySelector('h4').textContent.toLowerCase();
                            if (stateName.includes(searchTerm)) {
                                item.style.display = 'block';
                            } else {
                                item.style.display = 'none';
                            }
                        });
                    });
                    
                    // Select state item
                    document.querySelectorAll('.map-state-item').forEach(item => {
                        item.addEventListener('click', function() {
                            document.querySelectorAll('.map-state-item').forEach(i => {
                                i.style.backgroundColor = '';
                                i.style.borderColor = '#e9ecef';
                            });
                            
                            this.style.backgroundColor = '#f0f7ff';
                            this.style.borderColor = '#b8daff';
                            selectedStateId = this.dataset.id;
                            confirmLoadBtn.removeAttribute('disabled');
                        });
                    });
                    
                    // Preview button
                    document.querySelectorAll('.preview-map-btn').forEach(btn => {
                        btn.addEventListener('click', function(e) {
                            e.stopPropagation(); // Prevent triggering the parent item click
                            const previewStateId = this.dataset.id;
                            const previewState = mapStates.find(state => state.id === previewStateId);
                            
                            // Create a preview popup
                            showMapPreview(previewState);
                        });
                    });
                    
                    // Delete button
                    document.querySelectorAll('.delete-map-btn').forEach(btn => {
                        btn.addEventListener('click', function(e) {
                            e.stopPropagation(); // Prevent triggering the parent item click
                            const deleteStateId = this.dataset.id;
                            
                            if (confirm('Are you sure you want to delete this map state? This action cannot be undone.')) {
                                deleteMapState(deleteStateId, userId).then(() => {
                                    // Remove from UI
                                    const itemToRemove = document.querySelector(`.map-state-item[data-id="${deleteStateId}"]`);
                                    if (itemToRemove) {
                                        itemToRemove.remove();
                                    }
                                    
                                    // If no more states, close dialog
                                    if (document.querySelectorAll('.map-state-item').length === 0) {
                                        closeDialog();
                                        alert('No more saved states. Dialog closed.');
                                    }
                                    
                                    // If the deleted state was selected, disable the load button
                                    if (deleteStateId === selectedStateId) {
                                        selectedStateId = null;
                                        confirmLoadBtn.setAttribute('disabled', 'disabled');
                                    }
                                }).catch(error => {
                                    console.error('Error deleting map state:', error);
                                    alert('Failed to delete map state: ' + error.message);
                                });
                            }
                        });
                    });
                    
                    // Close button and cancel button
                    const closeDialog = () => {
                        document.body.removeChild(dialog);
                        document.body.removeChild(overlay);
                    };
                    
                    document.getElementById('close-map-dialog').addEventListener('click', closeDialog);
                    document.getElementById('cancel-load').addEventListener('click', closeDialog);
                    
                    // Load state button
                    document.getElementById('confirm-load').addEventListener('click', async () => {
                        if (!selectedStateId) return;
                        
                        loadingOverlay.style.display = 'flex';
                        closeDialog();
                        
                        try {
                            const selectedState = mapStates.find(state => state.id === selectedStateId);
                            console.log('Loading selected state:', selectedState);
                            
                            // Clear current state
                            drawnItems.clearLayers();

                            // Restore map view
                            map.setView([selectedState.center.lat, selectedState.center.lng], selectedState.zoom);

                            // Restore base map
                            Object.values(baseMaps).forEach(layer => map.removeLayer(layer));
                            const baseMapToLoad = baseMaps[selectedState.baseMap] || baseMaps.streets;
                            baseMapToLoad.addTo(map);
                            currentBaseMap = baseMapToLoad;
                            
                            // Update radio button for base map
                            const baseMapRadio = document.querySelector(`input[name="basemap"][value="${selectedState.baseMap}"]`);
                            if (baseMapRadio) {
                                baseMapRadio.checked = true;
                            }

                            // Restore drawings
                            if (selectedState.drawings && Array.isArray(selectedState.drawings)) {
                                console.log('Restoring drawings:', selectedState.drawings.length);
                                selectedState.drawings.forEach(item => {
                                    try {
                                        if (item.type === 'polygon') {
                                            L.polygon(item.points, item.options || {}).addTo(drawnItems);
                                        } else if (item.type === 'polyline' || item.type === 'line') {
                                            L.polyline(item.points, item.options || {}).addTo(drawnItems);
                                        } else if (item.type === 'circle' && item.center && item.radius) {
                                            L.circle(item.center, { radius: item.radius, ...item.options }).addTo(drawnItems);
                                        } else if (item.type === 'rectangle' && item.bounds) {
                                            L.rectangle(item.bounds, item.options || {}).addTo(drawnItems);
                                        }
                                    } catch (drawError) {
                                        console.error('Error restoring drawing:', drawError, item);
                                    }
                                });
                            }
                            
                            // Restore markers
                            if (selectedState.markers && Array.isArray(selectedState.markers)) {
                                console.log('Restoring markers:', selectedState.markers.length);
                                selectedState.markers.forEach(item => {
                                    try {
                                        let marker;
                                        if (item.position) {
                                            if (item.icon) {
                                                const icon = L.divIcon(item.icon);
                                                marker = L.marker(item.position, { icon }).addTo(drawnItems);
                                            } else {
                                                marker = L.marker(item.position).addTo(drawnItems);
                                            }
                                            
                                            // Add popup if exists
                                            if (item.popup) {
                                                marker.bindPopup(item.popup);
                                            }
                                        }
                                    } catch (markerError) {
                                        console.error('Error restoring marker:', markerError, item);
                                    }
                                });
                            }
                            
                            loadingOverlay.style.display = 'none';
                            alert('Map state loaded successfully!');
                        } catch (error) {
                            console.error('Error loading map state:', error);
                            loadingOverlay.style.display = 'none';
                            alert('Error loading map state: ' + error.message);
                        }
                    });
                } catch (error) {
                    console.error('Error loading map states:', error);
                    loadingOverlay.style.display = 'none';
                    alert('Failed to load map states: ' + error.message);
                }
            });

            // ...existing code...
        });

        // Utility: Add stop button to drawing controls if not present
        function ensureStopButton(stopCallback) {
            const drawingControls = document.getElementById('drawing-controls');
            let stopButton = document.getElementById('stop-drawing-btn');
            if (!stopButton) {
                stopButton = document.createElement('button');
                stopButton.className = 'toolbar-btn';
                stopButton.id = 'stop-drawing-btn';
                stopButton.innerHTML = '<i class="fas fa-stop"></i>';
                stopButton.title = 'Stop Drawing';
                stopButton.style.backgroundColor = '#e74c3c';
                stopButton.style.color = 'white';
                drawingControls.appendChild(stopButton);
            }
            stopButton.onclick = stopCallback;
            stopButton.style.display = 'inline-flex';
        }
        function removeStopButton() {
            const stopButton = document.getElementById('stop-drawing-btn');
            if (stopButton && stopButton.parentNode) {
                stopButton.parentNode.removeChild(stopButton);
            }
        }

        // Layer control functionality
        document.getElementById('layers-btn').addEventListener('click', function() {
            document.getElementById('layer-control-panel').classList.add('active');
        });

        document.getElementById('close-layer-panel').addEventListener('click', function() {
            document.getElementById('layer-control-panel').classList.remove('active');
        });

        // Save Map functionality
        document.getElementById('save-map-btn').addEventListener('click', function() {
            // Show loading spinner
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.style.display = 'flex';
            
            // Get timestamp for filename
            const date = new Date();
            const timestamp = date.toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const filename = `environmental-map-${timestamp}.png`;
            
            // Get map container
            const mapContainer = document.getElementById('map');
            
            // Use html2canvas to capture the map
            html2canvas(mapContainer, {
                useCORS: true,
                allowTaint: false,
                scrollX: 0,
                scrollY: 0,
                windowWidth: document.documentElement.offsetWidth,
                windowHeight: document.documentElement.offsetHeight,
                scale: window.devicePixelRatio || 2 // Higher resolution
            }).then(canvas => {
                // Create download link
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = filename;
                
                // Hide loading spinner
                loadingOverlay.style.display = 'none';
                
                // Trigger download
                link.click();
            }).catch(error => {
                console.error('Error saving map:', error);
                loadingOverlay.style.display = 'none';
                alert('Failed to save map. Please try again.');
            });
        });
        
        // Screenshot button functionality (for compatibility with existing code)
        document.getElementById('screenshot-btn').addEventListener('click', function() {
            // Show loading spinner
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.style.display = 'flex';
            
            // Get timestamp for filename
            const date = new Date();
            const timestamp = date.toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const filename = `map-screenshot-${timestamp}.png`;
            
            // Get map container
            const mapContainer = document.getElementById('map');
            
            // Use html2canvas to capture the map
            html2canvas(mapContainer, {
                useCORS: true,
                allowTaint: false,
                scrollX: 0,
                scrollY: 0
            }).then(canvas => {
                // Create download link
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = filename;
                
                // Hide loading spinner
                loadingOverlay.style.display = 'none';
                
                // Trigger download
                link.click();
            }).catch(error => {
                console.error('Error taking screenshot:', error);
                loadingOverlay.style.display = 'none';
                alert('Failed to take screenshot. Please try again.');
            });
        });

        // Base map controls
        const baseMaps = {
            streets: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '© Esri'
            })
        };

        baseMaps.streets.addTo(map);

        document.querySelectorAll('input[name="basemap"]').forEach(input => {
            input.addEventListener('change', function() {
                Object.values(baseMaps).forEach(layer => map.removeLayer(layer));
                baseMaps[this.value].addTo(map);
            });
        });

        // Layer visibility controls
        document.querySelectorAll('.layer-visibility').forEach(checkbox => {
            if (checkbox.id === 'drawings-layer' || checkbox.id === 'measurements-layer') {
                checkbox.addEventListener('change', function() {
                    const layer = checkbox.id === 'drawings-layer' ? drawnItems : measureControl.distance;
                    if (this.checked) {
                        layer && map.addLayer(layer);
                    } else {
                        layer && map.removeLayer(layer);
                    }
                });
            } else {
                const layerType = checkbox.id.split('-')[0];
                checkbox.addEventListener('change', function() {
                    const layer = markerLayers[layerType];
                    if (this.checked) {
                        layer && map.addLayer(layer);
                    } else {
                        layer && map.removeLayer(layer);
                    }
                });
            }
        });

        // Layer opacity controls
        document.querySelectorAll('.layer-opacity').forEach(slider => {
            slider.addEventListener('input', function() {
                const layerType = this.dataset.layer;
                const opacity = this.value / 100;
                
                if (layerType === 'drawings') {
                    drawnItems.eachLayer(layer => {
                        if (layer.setOpacity) layer.setOpacity(opacity);
                        if (layer.setStyle) layer.setStyle({ opacity, fillOpacity: opacity * 0.2 });
                    });
                } else if (layerType === 'measurements') {
                    if (measureControl.distance) {
                        measureControl.distance.setStyle({ opacity });
                    }
                } else {
                    const layer = markerLayers[layerType];
                    if (layer) {
                        layer.eachLayer(marker => {
                            marker.setOpacity(opacity);
                        });
                    }
                }
            });
        });

        // Add this function to your existing JavaScript
        function toggleParameters(type) {
            const parameters = document.getElementById(`${type}-parameters`);
            const button = parameters.previousElementSibling.querySelector('.layer-toggle');
            parameters.classList.toggle('active');
            button.classList.toggle('active');
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize map and controls
            // ...existing code...

            // Create layer groups for parameter labels
            const parameterLabelLayers = {
                'noise-db': L.layerGroup(),
                'noise-frequency': L.layerGroup(),
                'soil-ph': L.layerGroup(),
                'soil-organic': L.layerGroup(),
                'soil-moisture': L.layerGroup(),
                'water-ph': L.layerGroup(),
                'water-turbidity': L.layerGroup(),
                'water-oxygen': L.layerGroup(),
                'heat-temp': L.layerGroup(),
                'heat-humidity': L.layerGroup(),
                'heat-index': L.layerGroup(),
                'vibration-freq': L.layerGroup(),
                'vibration-amplitude': L.layerGroup(),
                'vibration-peak': L.layerGroup(),
                'light-illuminance': L.layerGroup(),
                'light-temperature': L.layerGroup(),
                'light-uv': L.layerGroup()
            };

            // Add toggle functionality for parameter checkboxes
            document.querySelectorAll('.parameter-toggle input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const paramId = this.dataset.param;
                    if (this.checked) {
                        parameterLabelLayers[paramId].addTo(map);
                    } else {
                        parameterLabelLayers[paramId].removeFrom(map);
                    }
                });
            });
            
            // Function to toggle parameter details display
            function toggleParameters(type) {
                const parameters = document.getElementById(`${type}-parameters`);
                const button = parameters.previousElementSibling.querySelector('.layer-toggle');
                parameters.classList.toggle('active');
                button.classList.toggle('active');
            }
            
            // Make toggleParameters function globally accessible
            window.toggleParameters = toggleParameters;
            
            // Function to create parameter labels on the map
            function createParameterLabel(lat, lng, text, layerType, offsetY = 0) {
                const icon = L.divIcon({
                    className: 'map-parameter-label',
                    html: text,
                    iconAnchor: [0, offsetY]
                });
                
                // Add a slight offset to prevent overlapping
                const offsetLat = lat + (offsetY ? 0.0001 : 0);
                
                const labelMarker = L.marker([offsetLat, lng], {
                    icon: icon,
                    interactive: false // Make it non-interactive
                });
                
                parameterLabelLayers[layerType].addLayer(labelMarker);
                
                // Check if we need to display this parameter
                if (document.querySelector(`input[data-param="${layerType}"]`).checked) {
                    if (!map.hasLayer(parameterLabelLayers[layerType])) {
                        parameterLabelLayers[layerType].addTo(map);
                    }
                }
            }
            
            // Function to load data and display on map
            function loadData() {
                // ...existing code...
                
                // Process marker data and add parameter labels
                // Example for noise data:
                database.ref('noise-quality-reports').once('value').then(noiseData => {
                    if (noiseData.exists()) {
                        noiseData.forEach(report => {
                            const data = report.val();
                            if (data.latitude && data.longitude) {
                                const marker = createMarker(data, 'noise');
                                markerLayers.noise.addLayer(marker);
                                
                                // Add parameter labels for each data point
                                if (data.parameters) {
                                    if (data.parameters.decibel) {
                                        createParameterLabel(data.latitude, data.longitude, `${data.parameters.decibel} dB`, 'noise-db');
                                    }
                                    if (data.parameters.frequency) {
                                        createParameterLabel(data.latitude, data.longitude, `${data.parameters.frequency} Hz`, 'noise-frequency', 30);
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Similar pattern for soil, water, heat, vibration, light data
                // ...existing code...
            }
            
            // Initialize map and load data
            // ...existing code...
        });
    </script>
    <script>
        // Save Map functionality
        document.getElementById('save-state-btn').addEventListener('click', async function() {
            if (!firebase.auth().currentUser) {
                alert('Please sign in to save map state');
                return;
            }

            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.style.display = 'flex';

            try {
                const center = map.getCenter();
                console.log('Map center:', center); // Debug log

                const mapState = {
                    center: {
                        lat: parseFloat(center.lat),
                        lng: parseFloat(center.lng)
                    },
                    zoom: map.getZoom(),
                    baseMap: Object.keys(baseMaps).find(key => map.hasLayer(baseMaps[key])) || 'streets',
                    drawings: [],
                    markers: [],
                    timestamp: Date.now(),
                    name: prompt('Enter a name for this map state:', 'Map State ' + new Date().toLocaleString())
                };

                if (!mapState.name) {
                    loadingOverlay.style.display = 'none';
                    return;
                }

                console.log('Preparing map state:', mapState); // Debug log

                // Save drawings and measurements
                drawnItems.eachLayer(layer => {
                    try {
                        if (layer instanceof L.Marker) {
                            const latlng = layer.getLatLng();
                            const markerData = {
                                type: 'marker',
                                position: {
                                    lat: parseFloat(latlng.lat),
                                    lng: parseFloat(latlng.lng)
                                }
                            };

                            // Save icon data if exists
                            if (layer.options.icon && layer.options.icon.options) {
                                markerData.icon = {
                                    className: layer.options.icon.options.className || '',
                                    html: layer.options.icon.options.html || '',
                                    iconSize: layer.options.icon.options.iconSize || [24, 24],
                                    iconAnchor: layer.options.icon.options.iconAnchor || [12, 24]
                                };
                            }

                            // Save popup content if exists
                            if (layer._popup) {
                                markerData.popup = layer._popup._content;
                            }

                            mapState.markers.push(markerData);
                        } else if (layer instanceof L.Polyline) {
                            const isPolygon = layer instanceof L.Polygon;
                            const latlngs = layer.getLatLngs();

                            // Convert nested LatLng objects to plain objects
                            const serializeLatLngs = (coords) => {
                                if (Array.isArray(coords)) {
                                    return coords.map(coord => {
                                        if (coord instanceof L.LatLng) {
                                            return {
                                                lat: parseFloat(coord.lat),
                                                lng: parseFloat(coord.lng)
                                            };
                                        }
                                        return serializeLatLngs(coord);
                                    });
                                }
                                return {
                                    lat: parseFloat(coords.lat),
                                    lng: parseFloat(coords.lng)
                                };
                            };

                            mapState.drawings.push({
                                type: isPolygon ? 'polygon' : 'polyline',
                                points: serializeLatLngs(latlngs),
                                options: {
                                    color: layer.options.color || '#3388ff',
                                    weight: layer.options.weight || 3,
                                    fillColor: layer.options.fillColor || '#3388ff',
                                    fillOpacity: layer.options.fillOpacity || 0.2
                                }
                            });
                        }
                    } catch (layerError) {
                        console.error('Error processing layer:', layerError);
                    }
                });

                console.log('Final map state to save:', mapState); // Debug log

                // Save to Firebase
                const userId = firebase.auth().currentUser.uid;
                console.log('Saving to user ID:', userId); // Debug log

                const dbRef = firebase.database().ref(`users/${userId}/mapStates`);
                await dbRef.push(mapState);

                loadingOverlay.style.display = 'none';
                alert('Map state saved successfully!');
            } catch (error) {
                console.error('Error saving map state:', error);
                console.error('Error details:', {
                    code: error.code,
                    message: error.message,
                    stack: error.stack
                });
                loadingOverlay.style.display = 'none';
                alert('Failed to save map state. Please try again. Error: ' + error.message);
            }
        });

        // Load map state functionality
        document.getElementById('load-state-btn').addEventListener('click', async function() {
            if (!firebase.auth().currentUser) {
                alert('Please sign in to load map states');
                return;
            }

            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.style.display = 'flex';

            try {
                const userId = firebase.auth().currentUser.uid;
                const snapshot = await firebase.database().ref(`users/${userId}/mapStates`).once('value');
                
                if (!snapshot.exists()) {
                    alert('No saved map states found');
                    loadingOverlay.style.display = 'none';
                    return;
                }

                const mapStates = [];
                snapshot.forEach(childSnapshot => {
                    mapStates.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });

                // Sort by timestamp, newest first
                mapStates.sort((a, b) => b.timestamp - a.timestamp);
                
                // Create an enhanced selection dialog with preview and management options
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    padding: 0;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    z-index: 1001;
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                `;

                dialog.innerHTML = `
                    <div style="padding: 16px 20px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; display: flex; justify-content: space-between; align-items: center;">
                        <h3 style="margin: 0; font-size: 18px; color: #2c3e50;">Load Map State</h3>
                        <button id="close-map-dialog" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #6c757d;">×</button>
                    </div>
                    
                    <div style="padding: 20px; overflow-y: auto; max-height: 60vh;">
                        <div style="margin-bottom: 16px;">
                            <input type="text" id="search-map-states" placeholder="Search saved states..." style="width: 100%; padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box;">
                        </div>
                        
                        <div id="map-states-container" style="display: flex; flex-direction: column; gap: 12px;">
                            ${mapStates.map((state, index) => `
                                <div class="map-state-item" data-id="${state.id}" style="border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; cursor: pointer; transition: all 0.2s; position: relative; ${index === 0 ? 'background-color: #f0f7ff; border-color: #b8daff;' : ''}">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <h4 style="margin: 0 0 8px 0; font-size: 16px; color: #343a40;">${state.name || 'Unnamed State'}</h4>
                                        <div style="display: flex; gap: 8px;">
                                            <button class="preview-map-btn" data-id="${state.id}" title="Preview" style="background: none; border: none; color: #007bff; cursor: pointer;">
                                                <i class="fas fa-eye"></i>
                                            </button>
                                            <button class="delete-map-btn" data-id="${state.id}" title="Delete" style="background: none; border: none; color: #dc3545; cursor: pointer;">
                                                <i class="fas fa-trash-alt"></i>
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div style="font-size: 13px; color: #6c757d; margin-bottom: 8px;">
                                        Created: ${new Date(state.timestamp).toLocaleString()}
                                    </div>
                                    
                                    <div style="font-size: 13px; color: #6c757d; display: flex; gap: 12px;">
                                        <span><i class="fas fa-map-marker-alt"></i> ${state.markers ? state.markers.length : 0} markers</span>
                                        <span><i class="fas fa-draw-polygon"></i> ${state.drawings ? state.drawings.length : 0} drawings</span>
                                        <span><i class="fas fa-map"></i> ${state.baseMap || 'streets'}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div style="padding: 16px 20px; background: #f8f9fa; border-top: 1px solid #e9ecef; display: flex; justify-content: flex-end; gap: 10px;">
                        <button class="btn btn-secondary" id="cancel-load" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; background-color: #6c757d; color: white;">Cancel</button>
                        <button class="btn btn-primary" id="confirm-load" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; background-color: #007bff; color: white;" ${mapStates.length > 0 ? '' : 'disabled'}>Load Selected</button>
                    </div>
                `;

                document.body.appendChild(dialog);
                
                // Add overlay to prevent interaction with the background
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                `;
                document.body.appendChild(overlay);
                
                loadingOverlay.style.display = 'none';
                
                // Handlers for the dialog
                let selectedStateId = mapStates.length > 0 ? mapStates[0].id : null;
                const confirmLoadBtn = document.getElementById('confirm-load');
                
                if (selectedStateId) {
                    confirmLoadBtn.removeAttribute('disabled');
                }
                
                // Search functionality
                document.getElementById('search-map-states').addEventListener('input', function(e) {
                    const searchTerm = e.target.value.toLowerCase();
                    const container = document.getElementById('map-states-container');
                    const items = container.querySelectorAll('.map-state-item');
                    
                    items.forEach(item => {
                        const stateName = item.querySelector('h4').textContent.toLowerCase();
                        if (stateName.includes(searchTerm)) {
                            item.style.display = 'block';
                        } else {
                            item.style.display = 'none';
                        }
                    });
                });
                
                // Select state item
                document.querySelectorAll('.map-state-item').forEach(item => {
                    item.addEventListener('click', function() {
                        document.querySelectorAll('.map-state-item').forEach(i => {
                            i.style.backgroundColor = '';
                            i.style.borderColor = '#e9ecef';
                        });
                        
                        this.style.backgroundColor = '#f0f7ff';
                        this.style.borderColor = '#b8daff';
                        selectedStateId = this.dataset.id;
                        confirmLoadBtn.removeAttribute('disabled');
                    });
                });
                
                // Preview button
                document.querySelectorAll('.preview-map-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent triggering the parent item click
                        const previewStateId = this.dataset.id;
                        const previewState = mapStates.find(state => state.id === previewStateId);
                        
                        // Create a preview popup
                        showMapPreview(previewState);
                    });
                });
                
                // Delete button
                document.querySelectorAll('.delete-map-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent triggering the parent item click
                        const deleteStateId = this.dataset.id;
                        
                        if (confirm('Are you sure you want to delete this map state? This action cannot be undone.')) {
                            deleteMapState(deleteStateId, userId).then(() => {
                                // Remove from UI
                                const itemToRemove = document.querySelector(`.map-state-item[data-id="${deleteStateId}"]`);
                                if (itemToRemove) {
                                    itemToRemove.remove();
                                }
                                
                                // If no more states, close dialog
                                if (document.querySelectorAll('.map-state-item').length === 0) {
                                    closeDialog();
                                    alert('No more saved states. Dialog closed.');
                                }
                                
                                // If the deleted state was selected, disable the load button
                                if (deleteStateId === selectedStateId) {
                                    selectedStateId = null;
                                    confirmLoadBtn.setAttribute('disabled', 'disabled');
                                }
                            }).catch(error => {
                                console.error('Error deleting map state:', error);
                                alert('Failed to delete map state: ' + error.message);
                            });
                        }
                    });
                });
                
                // Close button and cancel button
                const closeDialog = () => {
                    document.body.removeChild(dialog);
                    document.body.removeChild(overlay);
                };
                
                document.getElementById('close-map-dialog').addEventListener('click', closeDialog);
                document.getElementById('cancel-load').addEventListener('click', closeDialog);
                
                // Load state
                document.getElementById('confirm-load').addEventListener('click', async () => {
                    if (!selectedStateId) return;
                    
                    loadingOverlay.style.display = 'flex';
                    closeDialog();
                    
                    try {
                        const selectedState = mapStates.find(state => state.id === selectedStateId);
                        await loadMapState(selectedState);
                        loadingOverlay.style.display = 'none';
                        alert('Map state loaded successfully!');
                    } catch (error) {
                        console.error('Error loading map state:', error);
                        loadingOverlay.style.display = 'none';
                        alert('Error loading map state: ' + error.message);
                    }
                });
            } catch (error) {
                console.error('Error loading map states:', error);
                loadingOverlay.style.display = 'none';
                alert('Failed to load map states: ' + error.message);
            }
        });

        // Function to show map preview
        function showMapPreview(state) {
            // Create preview container
            const previewContainer = document.createElement('div');
            previewContainer.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 0;
                border-radius: 8px;
                box-shadow: 0 4px 25px rgba(0, 0, 0, 0.2);
                z-index: 1002;
                width: 80%;
                max-width: 700px;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            `;
            
            previewContainer.innerHTML = `
                <div style="padding: 16px 20px; background: #f8f9fa; border-bottom: 1px solid #e9ecef; display: flex; justify-content: space-between; align-items: center;">
                    <h3 style="margin: 0; font-size: 18px; color: #2c3e50;">Preview: ${state.name || 'Unnamed State'}</h3>
                    <button id="close-preview" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #6c757d;">×</button>
                </div>
                
                <div id="preview-map" style="height: 400px; width: 100%;"></div>
                
                <div style="padding: 16px 20px; background: #f8f9fa; border-top: 1px solid #e9ecef; display: flex; justify-content: center;">
                    <button id="load-preview" class="btn btn-primary" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; background-color: #007bff; color: white;">
                        Load This State
                    </button>
                </div>
            `;
            
            document.body.appendChild(previewContainer);
            
            // Create a new map instance for preview
            const previewMap = L.map('preview-map', {
                zoomControl: true,
                attributionControl: false,
                dragging: true,
                scrollWheelZoom: true
            }).setView([state.center.lat, state.center.lng], state.zoom);
            
            // Add base layer
            const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(previewMap);
            
            // Add preview items
            const previewItems = L.featureGroup().addTo(previewMap);
            
            // Add drawings
            if (state.drawings && Array.isArray(state.drawings)) {
                state.drawings.forEach(item => {
                    try {
                        if (item.type === 'polygon') {
                            L.polygon(item.points, item.options || {}).addTo(previewItems);
                        } else if (item.type === 'polyline' || item.type === 'line') {
                            L.polyline(item.points, item.options || {}).addTo(previewItems);
                        } else if (item.type === 'circle' && item.center && item.radius) {
                            L.circle(item.center, { radius: item.radius, ...item.options }).addTo(previewItems);
                        } else if (item.type === 'rectangle' && item.bounds) {
                            L.rectangle(item.bounds, item.options || {}).addTo(previewItems);
                        }
                    } catch (error) {
                        console.error('Error adding preview item:', error);
                    }
                });
            }
            
            // Add markers
            if (state.markers && Array.isArray(state.markers)) {
                state.markers.forEach(item => {
                    try {
                        if (item.position) {
                            let marker;
                            if (item.icon) {
                                const icon = L.divIcon(item.icon);
                                marker = L.marker(item.position, { icon }).addTo(previewItems);
                            } else {
                                marker = L.marker(item.position).addTo(previewItems);
                            }
                        }
                    } catch (error) {
                        console.error('Error adding preview marker:', error);
                    }
                });
            }
            
            // If we have items, fit bounds
            if (previewItems.getBounds().isValid()) {
                previewMap.fitBounds(previewItems.getBounds());
            }
            
            // Close preview
            document.getElementById('close-preview').addEventListener('click', function() {
                document.body.removeChild(previewContainer);
                previewMap.remove();
            });
            
            // Load state from preview
            document.getElementById('load-preview').addEventListener('click', async function() {
                document.body.removeChild(previewContainer);
                previewMap.remove();
                
                const loadingOverlay = document.getElementById('loading-overlay');
                loadingOverlay.style.display = 'flex';
                
                try {
                    // Get the main map instance
                    const mainMap = window.map; // This references the global map variable
                    
                    // Clear current state
                    drawnItems.clearLayers();

                    // Restore map view
                    mainMap.setView([state.center.lat, state.center.lng], state.zoom);

                    // Restore base map
                    Object.values(baseMaps).forEach(layer => mainMap.removeLayer(layer));
                    const baseMapToLoad = baseMaps[state.baseMap] || baseMaps.streets;
                    baseMapToLoad.addTo(mainMap);
                    currentBaseMap = baseMapToLoad;
                    
                    // Update radio button for base map
                    const baseMapRadio = document.querySelector(`input[name="basemap"][value="${state.baseMap}"]`);
                    if (baseMapRadio) {
                        baseMapRadio.checked = true;
                    }

                    // Restore drawings and markers
                    if (state.drawings && Array.isArray(state.drawings)) {
                        state.drawings.forEach(item => {
                            try {
                                if (item.type === 'polygon') {
                                    L.polygon(item.points, item.options || {}).addTo(drawnItems);
                                } else if (item.type === 'polyline' || item.type === 'line') {
                                    L.polyline(item.points, item.options || {}).addTo(drawnItems);
                                } else if (item.type === 'circle' && item.center && item.radius) {
                                    L.circle(item.center, { radius: item.radius, ...item.options }).addTo(drawnItems);
                                } else if (item.type === 'rectangle' && item.bounds) {
                                    L.rectangle(item.bounds, item.options || {}).addTo(drawnItems);
                                }
                            } catch (error) {
                                console.error('Error restoring drawing:', error);
                            }
                        });
                    }
                    
                    if (state.markers && Array.isArray(state.markers)) {
                        state.markers.forEach(item => {
                            try {
                                if (item.position) {
                                    let marker;
                                    if (item.icon) {
                                        const icon = L.divIcon(item.icon);
                                        marker = L.marker(item.position, { icon }).addTo(drawnItems);
                                    } else {
                                        marker = L.marker(item.position).addTo(drawnItems);
                                    }
                                    
                                    if (item.popup) {
                                        marker.bindPopup(item.popup);
                                    }
                                }
                            } catch (error) {
                                console.error('Error restoring marker:', error);
                            }
                        });
                    }
                    
                    // Close the main dialog if it's still open
                    const mainDialog = document.querySelector('.map-state-item')?.closest('div')?.parentNode?.parentNode;
                    const overlay = document.querySelector('div[style*="background: rgba(0, 0, 0, 0.5)"]');
                    if (mainDialog) document.body.removeChild(mainDialog);
                    if (overlay) document.body.removeChild(overlay);
                    
                    loadingOverlay.style.display = 'none';
                    alert('Map state loaded successfully!');
                } catch (error) {
                    console.error('Error loading map state from preview:', error);
                    loadingOverlay.style.display = 'none';
                    alert('Error loading map state: ' + error.message);
                }
            });
        }

        // Function to delete map state
        async function deleteMapState(stateId, userId) {
            return firebase.database().ref(`users/${userId}/mapStates/${stateId}`).remove();
        }

        // Function to load map state
        async function loadMapState(selectedState) {
            // Clear current state
            drawnItems.clearLayers();

            // Restore map view
            map.setView([selectedState.center.lat, selectedState.center.lng], selectedState.zoom);

            // Restore base map
            Object.values(baseMaps).forEach(layer => map.removeLayer(layer));
            const baseMapToLoad = baseMaps[selectedState.baseMap] || baseMaps.streets;
            baseMapToLoad.addTo(map);
            currentBaseMap = baseMapToLoad;
            
            // Update radio button for base map
            const baseMapRadio = document.querySelector(`input[name="basemap"][value="${selectedState.baseMap}"]`);
            if (baseMapRadio) {
                baseMapRadio.checked = true;
            }

            // Restore drawings
            if (selectedState.drawings && Array.isArray(selectedState.drawings)) {
                console.log('Restoring drawings:', selectedState.drawings.length);
                selectedState.drawings.forEach(item => {
                    try {
                        if (item.type === 'polygon') {
                            L.polygon(item.points, item.options || {}).addTo(drawnItems);
                        } else if (item.type === 'polyline' || item.type === 'line') {
                            L.polyline(item.points, item.options || {}).addTo(drawnItems);
                        } else if (item.type === 'circle' && item.center && item.radius) {
                            L.circle(item.center, { radius: item.radius, ...item.options }).addTo(drawnItems);
                        } else if (item.type === 'rectangle' && item.bounds) {
                            L.rectangle(item.bounds, item.options || {}).addTo(drawnItems);
                        }
                    } catch (drawError) {
                        console.error('Error restoring drawing:', drawError, item);
                    }
                });
            }
            
            // Restore markers
            if (selectedState.markers && Array.isArray(selectedState.markers)) {
                console.log('Restoring markers:', selectedState.markers.length);
                selectedState.markers.forEach(item => {
                    try {
                        let marker;
                        if (item.position) {
                            if (item.icon) {
                                const icon = L.divIcon(item.icon);
                                marker = L.marker(item.position, { icon }).addTo(drawnItems);
                            } else {
                                marker = L.marker(item.position).addTo(drawnItems);
                            }
                            
                            // Add popup if exists
                            if (item.popup) {
                                marker.bindPopup(item.popup);
                            }
                        }
                    } catch (markerError) {
                        console.error('Error restoring marker:', markerError, item);
                    }
                });
            }
            
            return true;
        }
    </script>
    <script>
        // Load state button
        document.getElementById('confirm-load').addEventListener('click', async () => {
            if (!selectedStateId) return;
            
            loadingOverlay.style.display = 'flex';
            
            try {
                const selectedState = mapStates.find(state => state.id === selectedStateId);
                console.log('Loading selected state:', selectedState);
                
                if (!selectedState) {
                    throw new Error('Selected state not found');
                }

                // Clear current state
                drawnItems.clearLayers();

                // Restore map view - ensure valid coordinates
                const lat = parseFloat(selectedState.center.lat) || 0;
                const lng = parseFloat(selectedState.center.lng) || 0;
                const zoom = parseInt(selectedState.zoom) || 2;
                
                map.setView([lat, lng], zoom);

                // Restore base map
                Object.values(baseMaps).forEach(layer => {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                });
                
                const baseMapToLoad = baseMaps[selectedState.baseMap] || baseMaps.streets;
                baseMapToLoad.addTo(map);
                
                // Update radio button for base map
                const baseMapRadio = document.querySelector(`input[name="basemap"][value="${selectedState.baseMap}"]`);
                if (baseMapRadio) {
                    baseMapRadio.checked = true;
                }

                // Restore drawings with error handling
                if (selectedState.drawings && Array.isArray(selectedState.drawings)) {
                    console.log('Restoring drawings:', selectedState.drawings.length);
                    for (const item of selectedState.drawings) {
                        try {
                            if (item.type === 'polygon' && Array.isArray(item.points)) {
                                const polygon = L.polygon(item.points, item.options || {});
                                drawnItems.addLayer(polygon);
                            } else if ((item.type === 'polyline' || item.type === 'line') && Array.isArray(item.points)) {
                                const polyline = L.polyline(item.points, item.options || {});
                                drawnItems.addLayer(polyline);
                            } else if (item.type === 'circle' && item.center && item.radius) {
                                const circle = L.circle(item.center, { 
                                    radius: parseFloat(item.radius), 
                                    ...item.options 
                                });
                                drawnItems.addLayer(circle);
                            } else if (item.type === 'rectangle' && item.bounds) {
                                const rectangle = L.rectangle(item.bounds, item.options || {});
                                drawnItems.addLayer(rectangle);
                            }
                        } catch (drawError) {
                            console.error('Error restoring drawing:', drawError, item);
                        }
                    }
                }
                
                // Restore markers with error handling
                if (selectedState.markers && Array.isArray(selectedState.markers)) {
                    console.log('Restoring markers:', selectedState.markers.length);
                    for (const item of selectedState.markers) {
                        try {
                            if (item.position && item.position.lat && item.position.lng) {
                                let markerOptions = {};
                                
                                if (item.icon) {
                                    markerOptions.icon = L.divIcon(item.icon);
                                }
                                
                                const marker = L.marker(
                                    [parseFloat(item.position.lat), parseFloat(item.position.lng)],
                                    markerOptions
                                );
                                
                                if (item.popup) {
                                    marker.bindPopup(item.popup);
                                }
                                
                                drawnItems.addLayer(marker);
                            }
                        } catch (markerError) {
                            console.error('Error restoring marker:', markerError, item);
                        }
                    }
                }

                // Fit bounds if there are layers
                if (drawnItems.getLayers().length > 0) {
                    map.fitBounds(drawnItems.getBounds());
                }
                
                closeDialog();
                loadingOverlay.style.display = 'none';
                alert('Map state loaded successfully!');
            } catch (error) {
                console.error('Error loading map state:', error);
                loadingOverlay.style.display = 'none';
                alert('Error loading map state: ' + error.message);
            }
        });

        function closeDialog() {
            const dialog = document.querySelector('.map-state-item').closest('div').parentNode.parentNode;
            const overlay = document.querySelector('div[style*="background: rgba(0, 0, 0, 0.5)"]');
            if (dialog) dialog.remove();
            if (overlay) overlay.remove();
        }
    </script>
</body>
</html>
